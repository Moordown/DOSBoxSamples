@np@pl72@lm0@rm64@tm4@bm68@ff1
@np@dh1@ce- @pa -

          @e1Научно-технологический центр "Форум"@e0


@i1
                Программно-технические средства
               персональных ЭВМ семейства IBM PC
@i0









                       @e1Ю. С. Лукач@e0

@e1
     М И К Р О П Р О Ц Е С С О Р Ы   Ф И Р М Ы   I N T E L
          Часть 1. Микpопpоцессоpы Intel 8086 и 80286
@e0

                        Второе издание











           Цикл издается под редакцией Ю. С. Лукача




────────────────────────────────────────────────────────────
              (C) Научно-технологический центр "Форум", 1991

              Полное   или  частичное   воспроизведение  или
              размножение каким бы то ни было способом мате-
              риалов,  опубликованных  в  настоящем издании,
              допускается  только  с  письменного разрешения
              НТЦ "Форум".



                        Свердловск
                           1991
@pb1
                       @e1Содержание@e0

Введение  . . . . . . . . . . . . . . . . . . . . . . . .   2
Обозначения . . . . . . . . . . . . . . . . . . . . . . .   3
1. 16-разрядные микропроцессоры 8086 и 8088 . . . . . . .   4
1.1. Техническое описание . . . . . . . . . . . . . . . .   4
1.1.1. Общая характеристика . . . . . . . . . . . . . . .   4
1.1.2. Функциональное описание  . . . . . . . . . . . . .  10
1.1.3. Организация памяти . . . . . . . . . . . . . . . .  12
1.1.4. Регистры и флаги . . . . . . . . . . . . . . . . .  13
1.1.5. Методы адресации . . . . . . . . . . . . . . . . .  16
1.1.6. Форматы команд . . . . . . . . . . . . . . . . . .  18
1.1.7. Стек и система прерываний  . . . . . . . . . . . .  19
1.1.8. Форматы данных . . . . . . . . . . . . . . . . . .  22
1.2. Система команд . . . . . . . . . . . . . . . . . . .  23
1.2.1. Команды передачи данных  . . . . . . . . . . . . .  23
1.2.2. Арифметические операции. . . . . . . . . . . . . .  27
1.2.3. Логические операции. . . . . . . . . . . . . . . .  36
1.2.4. Команды работы со строками . . . . . . . . . . . .  41
1.2.5. Команды передачи управления  . . . . . . . . . . .  45
1.2.6. Команды управления процессором . . . . . . . . . .  50
2. 16-разрядный микропроцессор 80286  . . . . . . . . . .  53
2.1. Техническое описание . . . . . . . . . . . . . . . .  53
2.1.1. Общая характеристика . . . . . . . . . . . . . . .  53
2.1.2. Функциональное описание  . . . . . . . . . . . . .  57
2.1.3. Регистры и флаги . . . . . . . . . . . . . . . . .  57
2.1.4. Прерывания . . . . . . . . . . . . . . . . . . . .  59
2.1.5. Защищенный режим . . . . . . . . . . . . . . . . .  62
2.2. Система команд . . . . . . . . . . . . . . . . . . .  72
2.2.1. Команды реального режима . . . . . . . . . . . . .  72
2.2.2. Команды защищенного режима . . . . . . . . . . . .  76
2.2.3. Выполнение команд в защищенном режиме  . . . . . .  83
@pb
                        @e1Введение@e0

     Данный документ содержит  подробное описание микропроцессо-
ров  фирмы  Intel,  на  базе  которых  строятся персональные ЭВМ
семейства  IBM  PC.  В   нем  приведена  краткая  характеристика
аппаратной реализации этих процессоров и детальная информация об
их архитектуре и системе команд.

     Изложение  основано  на  технических  описаниях фирмы Intel
(Intel Microprocessor and Peripheral Handbooks) и многочисленных
статьях  и монографиях,  содержащих информацию,  отсутствующую в
фирменных  публикациях.  Кроме  того,  по  мере возможности, был
учтен  опыт авторов  по  написанию  программ на  ассемблере этих
микропроцессоров: он выразился  в многочисленных рекомендациях и
примечаниях, разбросанных по тексту.

     Следует   учитывать,  что   предлагаемый  Вашему   вниманию
документ  не  является  справочником  по  ассемблеру,  т.  е. не
охватывает  и  не  учитывает   особенностей  и  ограничений  его
синтаксиса.   Для   понимания   приведенного   здесь   материала
достаточно владения общими архитектурными принципами процессоров
ЭВМ;  незнакомые  или  малознакомые  термины  Вы  можете найти в
глоссарии справочника.

     Справочник состоит из трех частей. Первая часть, предлагае-
мая Вашему  вниманию, содержит описание  процессоров 8086/8088 и
80286;  вторая -  описание процессора  80386; третья  - описание
арифметических сопроцессоров 8087, 80287, 80387 и указатели.

     Авторы  будут благодарны  за любые  указания на неточности,
замечания и  дополнения, которые мы просим  сообщать по телефону
или присылать по адресу:

     620075, г. Свердловск,
     ул. Луначарского, 81
     Внедренческий научно-технологический центр "Форум",
     тел. 56-92-54, 56-92-88.
@pb
                       @e1Обозначения@e0

     Десятичные  числа  записываются  в  тексте обычным образом,
шестнадцатиричные  отличаются  от  них  добавлением  буквы "h" в
конце. Например, 256 и 100h обозначают десятичное число 256.

     Размеры таблиц и их полей приводятся в байтах, если явно не
оговорено противное.

     В  некоторых  случаях  алгоритмы  сопровождаются формулами.
Операции  в формулах  обозначаются, как  принято в  языке Си,  а
именно:

     арифметические: +, -, *, /, % (взятие остатка)
     логические:     & (И), | (ИЛИ), ~ (НЕ)

     В описаниях команд используются следующие сокращения:

     src       Операнд-источник
     dst       Операнд-приемник
     opr       Операнд
     reg       Регистр
     disp      Смешение
     addr(...) Адрес ...
     [...]     Содержимое адреса ...
     port      Порт ввода-вывода
     flg       Регистр флагов
     cnt       Счетчик

     Прочие обозначения вводятся в  тексте по мере изложения или
являются общепринятыми.
@pb
       @e11. 16-разрядные микропроцессоры 8086 и 8088@e0
                @e11.1. Техническое описание@e0

@e1     1.1.1. Общая характеристика@e0

     16-разрядный  МП  Intel  8086  содержит  на кристалле около
29000 транзисторов и производится по высококачественной МОП-тех-
нологии. Он имеет одну из следующих тактовых частот: 5 (8086), 8
(8086-2)  или 10  (8086-1) Мгц.  МП 8086  может использоваться в
одно-   и   многопроцессорных    конфигурациях.   Разводка   его
40-штырькового корпуса приведена на рис. 1.1.

                    ┌────┐ ┌────┐
Земля ----->   GND [│ 1  └─┘ 40 │] Vcc    <---- Питание + 5 В
          --        │           │
         /    AD14 [│ 2      39 │] AD15   <---- Адрес/данные
        |           │           │              --
        |     AD13 [│ 3      38 │] A16/S3        \
        |           │           │                 |
        |     AD12 [│ 4      37 │] A17/S4         |
        |           │           │                  > Адрес/
        |     AD11 [│ 5      36 │] A18/S5         |  управление
        |           │           │                 |
        |     AD10 [│ 6      35 │] A19/S6        /
        |           │           │  ___         --
        |      AD9 [│ 7      34 │] BHE/S7        \
        |           │           │     __          |
        |      AD8 [│ 8      33 │] MN/MX          |
        |           │           │  __             |
Адрес/ <       AD7 [│ 9      32 │] RD             |
данные  |           │           │  __ ___         |
        |      AD6 [│ 10     31 │] RQ/GT0 (HOLD)  |
        |           │           │  __ ___         |
        |      AD5 [│ 11     30 │] RQ/GT1 (HDLA)  |
        |           │           │  ____    __     |
        |      AD4 [│ 12     29 │] LOCK   (WR)    |
        |           │           │  __        __   |
        |      AD3 [│ 13     28 │] S2     (M/IO)  |
        |           │           │  __         _    > Управление
        |      AD2 [│ 14     27 │] S1     (DT/R)  |
        |           │           │  __      ___    |
        |      AD1 [│ 15     26 │] S0     (DEN)   |
        |           │           │                 |
        |      AD0 [│ 16     25 │] QS0    (ALE)   |
         \__        │           │          ____   |
           /   NMI [│ 17     24 │] QS1    (INTA)  |
Управление<         │           │  ____           |
           \  INTR [│ 18     23 │] TEST           |
                    │           │                 |
Синхронизация  CLK [│ 19     22 │] READY          |
                    │           │                 |
Земля ----->   GND [│ 20     21 │] RESET          |
                    └───────────┘              __/

         Рис. 1.1. Разводка контактов корпуса МП 8086

     МП  8088  представляет  собой  8-разрядный  микропроцессор,
который программно полностью совместим с  8086. Он имеет 8 линий
данных  и тактовую  частоту 4,77  Мгц, но  его архитектура  ана-
логична МП 8086. Разводка контактов  его корпуса такая же, как у
8086,  но  линии  адреса  AD15  -  AD8  используются  только для
адресов, а линия BHE заменена  линией состояния, так как МП 8088
может  адресоваться только  к  байтам  (см. рис.  1.2). Детально
отличия МП 8088 от 8086 описаны ниже.

                    ┌────┐ ┌────┐
Земля ----->   GND [│ 1  └─┘ 40 │] Vcc    <---- Питание + 5 В
          --        │           │
         /     A14 [│ 2      39 │] AD15   <---- Адрес/данные
        |           │           │              --
        |      A13 [│ 3      38 │] A16/S3        \
        |           │           │                 |
        |      A12 [│ 4      37 │] A17/S4         |
        |           │           │                  > Адрес/
        |      A11 [│ 5      36 │] A18/S5         |  управление
        |           │           │                 |
        |      A10 [│ 6      35 │] A19/S6        /
        |           │           │  ___         --
        |       A9 [│ 7      34 │] SS0    (HIGH) \
        |           │           │     __          |
        |       A8 [│ 8      33 │] MN/MX          |
        |           │           │  __             |
Адрес/ <        A7 [│ 9      32 │] RD             |
данные  |           │           │  __ ___         |
        |      AD6 [│ 10     31 │] RQ/GT0 (HOLD)  |
        |           │           │  __ ___         |
        |      AD5 [│ 11     30 │] RQ/GT1 (HDLA)  |
        |           │           │  ____    __     |
        |      AD4 [│ 12     29 │] LOCK   (WR)    |
        |           │           │  __        __   |
        |      AD3 [│ 13     28 │] S2     (M/IO)  |
        |           │           │  __         _    > Управление
        |      AD2 [│ 14     27 │] S1     (DT/R)  |
        |           │           │  __      ___    |
        |      AD1 [│ 15     26 │] S0     (DEN)   |
        |           │           │                 |
        |      AD0 [│ 16     25 │] QS0    (ALE)   |
         \__        │           │          ____   |
           /   NMI [│ 17     24 │] QS1    (INTA)  |
Управление<         │           │  ____           |
           \  INTR [│ 18     23 │] TEST           |
                    │           │                 |
Синхронизация  CLK [│ 19     22 │] READY          |
                    │           │                 |
Земля ----->   GND [│ 20     21 │] RESET          |
                    └───────────┘              __/

         Рис. 1.2. Разводка контактов корпуса МП 8088
@pb
     Для расширения  области применения оба МП  имеют два режима
работы: минимальный и  максимальный. Минимальный режим рассчитан
на небольшие однопроцессорные системы, в которых все необходимые
сигналы  управления  шиной  генерируются  самим ЦП. Максимальный
режим обеспечивает работу средних и  больших (в том числе много-
процессорных) систем. В этом режиме МП кодируют основные сигналы
управления шиной  в 3 бита состояния,  а освободившиеся контакты
используются для   дополнительной   информации,   требующейся  в
многопроцессорных конфигурациях. Режим  работы определяется кон-
тактом  33 (MN/MX).  Контакты,  общие  для обоих  режимов, имеют
следующее назначение.

────────────────────────────────────────────────────────────────
Контакт(ы) Обозначение Вход/выход            Описание
                         3-сост.
────────────────────────────────────────────────────────────────
    1          GND       ---       ЗЕМЛЯ
   2-16     AD14-AD0   ВХ/ВЫХ-3    ШИНА АДРЕСА/ДАННЫХ: Эти линии
                                   в первой части цикла содержат
                                   адрес, в остальных вводят или
                                   выводят данные. В МП 8088
                                   линии A15-A8 служат только
                                   для вывода адреса.
    17         NMI      ВХОД       НЕМАСКИРУЕМОЕ ПРЕРЫВАНИЕ:
                                   вход, вызывающий прерывание 2
                                   и не маскируемый программно.
    18         INTR     ВХОД       ЗАПРОС МАСКИРУЕМОГО ПРЕРЫВА-
                                   НИЯ: вызов прерывания, зада-
                                   ваемого уровнем.
    19         CLK      ВХОД       СИНХРОНИЗАЦИЯ с заполнением
                                   33% и частотой, зависящей от
                                   типа МП.
    20         GND       ---       ЗЕМЛЯ
    21         RESET    ВХОД       СБРОС: прекращает работу МП,
                                   обнуляет PSW, IP, DS, SS, ES
                                   и очередь команд, засылает в
                                   CS 0FFFFF0h.
    22         READY    ВХОД       ГОТОВНОСТЬ: подтверждение от
                                   памяти или интерфейса ввода-
                                   вывода о том, что ЦП может
               ____                закончить текущий цикл шины.
    23         TEST     ВХОД       ТЕСТ: команда WAIT заставляет
                                   ЦП ждать появления на этом
                                   входе нуля.
  24-31         ***      ***       Зависят от режима.
               __
    32         RD      ВЫХОД-3     ЧТЕНИЕ: показывает выполнение
                                   считывания   из   памяти  или
                 __                ввода-вывода.
    33        MN/MX     ВХОД       МИНИМУМ/МАКСИМУМ: при зазем-
                                   лении этого входа МП работает
                                   в максимальном режиме, при
                                   подключении его к питанию - в
              ___                  минимальном.
    34        BNE/S7   ВЫХОД-3     СОСТОЯНИЕ: В первой части
────────────────────────────────────────────────────────────────
Контакт(ы) Обозначение Вход/выход            Описание
                         3-сост.
────────────────────────────────────────────────────────────────
                                   цикла указывает линии
                                   передачи байта по шине:
                                   AD15-AD8 (0) или AD7-AD0 (1).
                                   В МП 8088 обозначен SS0 и
                                   применяется в минимальном ре-
                                   жиме для указания состояния.
  35-38       A19/S6-  ВЫХОД-3     АДРЕС/СОСТОЯНИЕ: В первой
              A16/S3               части цикла шины содержит
                                   4 старших бита адреса, в
                                   остальных частях S6=0, S5
                                   содержит флаг IF, S4 и S3
                                   указывают на сегментный
                                   регистр:
                                     S4  S3  Регистр
                                     0   0     ES
                                     0   1     SS
                                     1   0     CS или никакой
                                     1   1     DS
    39         AD15    ВХ/ВЫХ-3    см. AD14-AD0
    40         Vcc        ---      напряжение питания +5 В
────────────────────────────────────────────────────────────────
@pb
     В  минимальном   режиме  контакты  24-31   имеют  следующее
назначение:

────────────────────────────────────────────────────────────────
Контакт(ы) Обозначение Вход/выход            Описание
                         3-сост.
────────────────────────────────────────────────────────────────
               ____
    24         INTA     ВЫХОД-3    INTA: Строб распознавания
                                   запроса прерывания.
    25          ALE     ВЫХОД      ЗАЩЕЛКА АДРЕСА: Импульс в
                                   начале цикла шины, показываю-
                ___                щий наличие адреса на линиях.
    26          DEN     ВЫХОД-3    ЗАЩЕЛКА ДАННЫХ: Импульс в
                                   конце цикла шины, сообщающий
                                   что ЦП готов к приему или
                  _                передаче данных.
    27         DT/R     ВЫХОД-3    ПРИЕМ/ПЕРЕДАЧА ДАННЫХ: Задает
                                   направление обмена данными:
                 __                в ЦП (1) или из ЦП (0).
    28         M/IO     ВЫХОД-3    ЛИНИЯ СОСТОЯНИЯ: Различает
                                   доступ к памяти (1) или
                __                 вводу-выводу (0).
    29          WR      ВЫХОД-3    ЗАПИСЬ: Показывает, что
                                   идет операция записи.
    30         HDLA     ВЫХОД      Разрешение шины запрашиваю-
                                   щему ведущему.
    31         HOLD     ВХОД       Запросы шины от других веду-
                                   щих. ЦП не получает управле-
                                   ния шиной до снятия этого
                                   сигнала.
────────────────────────────────────────────────────────────────

     Таким   образом,   в   минимальном   режиме   тип  передачи
определяется сигналами M/IO, RD и WR:

──────────────────────────────────
  __  __  __
M/IO  RD  WR  Тип передачи
──────────────────────────────────
  0   0   1   Чтение ввода-вывода
  0   1   0   Запись ввода-вывода
  1   0   1   Чтение из памяти
  1   1   0   Запись в память
──────────────────────────────────
@pb
     В  максимальном  режиме   контакты  24-31  имеют  следующее
назначение:

────────────────────────────────────────────────────────────────
Контакт(ы) Обозначение Вход/выход            Описание
                         3-сост.
────────────────────────────────────────────────────────────────
  24-25     QS1,QS0     ВЫХОД      СОСТОЯНИЕ ОЧЕРЕДИ КОМАНД:
                                    QS1  QS0    Состояние
                                     0    0  Нет операции
                                     0    1  Первый байт команды
                                     1    0  Очистить очередь
             __ __                   1    1  Следующий байт
  26-28      S0-S2      ВЫХОД-3    СОСТОЯНИЕ ПЕРЕДАЧИ:
                                    S2 S1 S0   Тип передачи
                                    0  0  0  Подтв-ние прерывания
                                    0  0  1  Чтение ввода-вывода
                                    0  1  0  Запись ввода-вывода
                                    0  1  1  Останов
                                    1  0  0  Выборка команды
                                    1  0  1  Чтение из памяти
                                    1  1  0  Запись в память
             ____                   1  1  1  Пассивный
   29        LOCK       ВЫХОД-3     ЗАХВАТ ШИНЫ: Инициируется
            ______                  префиксом LOCK.
   30       RQ/GT1      ВХ/ВЫХ      ЗАПРОС ШИНЫ: Используется
            ______                  другими ведущими.
   31       RQ/GT0      ВХ/ВЫХ      То же, что RQ/GT1, но с
                                    высшим приоритетом.
────────────────────────────────────────────────────────────────
@pb
@e1     1.1.2. Функциональное описание@e0

     МП   8086/8088   логически   состоит   из  двух  устройств:
устройства сопряжения канала (УСК или  BIU - Bus Interface Unit)
и устройства обработки (УО или  EU - Execution Unit). Блок-схема
МП приведена на рис. 1.3.

     УСК обеспечивает  выборку команд и  помещение их в  очередь
размером 6  (в МП 8088 -  4) байтов, загрузку и  сохранение опе-
рандов, вычисление  абсолютных адресов. УО  извлекает команды из
очереди и исполняет их.
@pb
 Устройство обработки  Устройство сопряжения канала
╔═════════════════════╗ ╔══════════════════════╗
 ┌───────────────────┐   ┌────────────────────┐
 │Регистры-указатели,│   │ Сегментные регистры│
 │общие и индексные  │   │ и указатель команд │
 │регистры           │   │                    │
 └───────────────────┘   └────────────────────┘
          / \                     / \
           ║                       ║
           ╠═══════════╦═══════════╣
           ║           ║           ║
          \ /          ║          \ /
  ┌──────────────────┐ ║ ┌────────────────────┐    ___
  │16-разрядное АЛУ  │ ║ │                    │--->BHE/S7
  ├──────────────────┤ ║ │                    │
  │     Флаги        │ ║ │                    │--->A19/S6-
  └──────────────────┘ ║ │     Интерфейс      │    A16/S3
                       ║ │                    │
                       ║ │      с шиной       │<-->AD15-AD0
                       ║ │                    │    ____ __ __
                       ║ │                    │--->INTA,RD,WR
                       ║ │                    │       _ ___
                       ║ │                    │--->DT/R,DEN,ALE
                       ║ └─────────╥──────────┘
                       ║           ║
                       ║          \ /
                       ║ ┌────────────────────┐
                       ╠═╡   Очередь команд   │
                       ║ └────────────────────┘
                       ║
                      \ /
   ____    ┌────────────────────────┐    ____
   TEST--->│                        │--->LOCK
           │                        │
    INT--->│                        │
           │                        │
    NMI--->│      Управление и      │
__ ____    │                        │--->QS0,QS1
RQ/GT01<-->│      синхронизация     │
           │                        │
   HOLD--->│                        │
           │                        │    __ __ __
   HLDA<---│                        │--->S2,S1,S0
           └────────────────────────┘
            ^    ^     ^     ^    ^
            |    |     |     |    |
            |    |     |     |    |
           CLK RESET READY MN/MX GND
                                 Vcc

     Рис. 1.3. Блок-схема МП 8086/8088
@pb
@e1     1.1.3. Организация памяти@e0

     МП  8086/8088  обеспечивают  20-битовую  адресацию к байтам
памяти. Тем самым возможно  использование 1 Мбайта памяти, адре-
суемой  от  00000h  до  FFFFFh.  Структурными  единицами  памяти
являются байт, слово, двойное слово  и сегмент.

     Байт - это минимальная  адресуемая единица памяти, хранящая
8 бит данных. Слово занимает два последовательных байта памяти и
может  может  располагаться  как  с  четного,  так и с нечетного
адреса. При  этом младщий байт  слова располагается по  младшему
адресу. Чтение и запись слова, расположенного по четному адресу,
требует  одного  обращения  к  памяти,  а  по  нечетному - двух.
Двойное слово занимает два последовательных слова памяти и также
может размещаться с любого адреса.

     Сегмент памяти - это участок памяти размером от 16 до 65536
байтов, который начинается с  адреса, кратного 10h (такие адреса
называются номерами параграфов).  Каждому сегменту соответствует
непрерывная и  отдельно адресуемая область  памяти. МП позволяет
одновременно адресовать 4 сегмента памяти, называемые сегментами
команд, данных, стека и дополнительным сегментом.

     Часть адресуемой памяти резервируется для специальных дейс-
твий ЦП.  Адреса с FFFF0h по  FFFFFh резервируются для процедуры
начальной загрузки, т. к. общий  сброс МП передает управление по
адресу FFFF0h. Область памяти с 00000h по 003FFh зарезервирована
для векторов прерываний.

     МП 8086/8088 могут адресовать до 64К байтовых регистров или
до  32К  словных  регистров  ввода-вывода.  Помните, что регистр
ввода с  адресом XXXX и регистр  вывода с тем же  адресом - это,
вообще говоря, разные регистры.
@pb
@e1     1.1.4. Регистры и флаги@e0

     МП 8086/8088 имеют следующие регистры.

              15     8 7      0
              ┌───────┬───────┐
Регистры    AX│  AH   │  AL   │ Аккумулятор
              ├───────┼───────┤
обшего      BX│  BH   │  BL   │ База
              ├───────┼───────┤
назначения  CX│  CH   │  CL   │ Счетчик
              ├───────┼───────┤
            DX│  DH   │  DL   │ Данные
              └───────┴───────┘
              ┌───────────────┐
Регистры-     │      SP       │ Указатель стека
              ├───────────────┤
указатели     │      BP       │ Указатель базы
              ├───────────────┤
Индексные     │      SI       │ Индекс источника
              ├───────────────┤
регистры      │      DI       │ Индекс приемника
              └───────────────┘
              ┌───────────────┐
              │      IP       │ Указатель команд
              ├───────────────┤
              │    Флаги      │ Флаги условий
              └───────────────┘
              ┌───────────────┐
Сегментные    │      CS       │ Сегмент кодов
              ├───────────────┤
              │      DS       │ Сегмент данных
              ├───────────────┤
регистры      │      SS       │ Сегмент стека
              ├───────────────┤
регистры      │      ES       │ Дополнительный сегмент
              └───────────────┘

     Регистры общего назначения могут использоваться в арифмети-
ческих  операциях  без  ограничений.  В  некоторых  командах они
используются  специальным  образом.  Каждый  из  них  может рас-
сматриваться как  слово (AX, BX,  CX, DX) или  как два отдельных
байта (AL и AH и т. д.). При этом байт XL является младшим, а XH
- старшим.

     Регистры-указатели (BP,  SP) и индексные  регистры (SI, DI)
обычно  содержат смещения,  используемые для  вычисления адресов
операндов в сегменте. Они также могут использоваться в арифмети-
ческих операциях. Кроме того, SI  и DI имеют особое применение в
операциях  над строками.  Разница между  указателями и индексами
состоит в  том, что смещение  в указателях берется  относительно
сегмента стека, а в индексах - относительно сегмента данных.

     Сегментные  регистры  предназначены  для  хранения  базовых
адресов  соответствующих  сегментов.   Абсолютный  адрес  любого
операнда  вычисляется как  сумма базового  адреса его  сегмента,
умноженного на  10h, и смещения  относительно начала этого  сег-
мента.  При этом  бит переноса  не учитывается,  т. е.  за самым
старшим  адресом  сегмента  следует  его  самый младший сегмент.
Символически  так формируемый  адрес принято  записывать в  виде
сегмент:смещение.

────────────────────────────────────────────────────────────────
Регистр  Сегмент      Правила обращения к сегменту
────────────────────────────────────────────────────────────────
  CS     Коды       Все команды автоматически выбираются отсюда.
  SS     Стек       Операции со стеком (PUSH и POP) и адресация
                    относительно регистра BP.
  DS     Данные     Обращение к данным.
  ES     Дополни-   Приемник строковых команд; используется как
         тельный    дополнительный сегмент данных.
────────────────────────────────────────────────────────────────

     Указатель команд содержит  адрес текущего байта исполняемой
команды относительно  сегмента кодов. Изменение  его содержимого
происходит автоматически при выборке  очередного байта команды и
при выполнении команд передачи управления.

     Регистр  флагов условий  отображает информацию  о состоянии
центрального процессора. Он имеет вид:

 1 1 1 1  1  1
┌5┬4┬3┬2┬─1┬─0┬─9┬─8┬─7┬─6┬5┬─4┬3┬─2┬1┬─0┐
│* * * *│OF│DF│IF│TF│SF│ZF│*│AF│*│PF│*│CF│ Бит:           Маска:
└─┴─┴─┴─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴─┴┬─┴─┴┬─┴─┴┬─┘
         │  │  │  │  │  │    │    │    └──> 0: Перенос       01h
         │  │  │  │  │  │    │    └───────> 2: Четность      04h
         │  │  │  │  │  │    └────────────> 4: Всп. перенос  10h
         │  │  │  │  │  └─────────────────> 6: Нуль          40h
         │  │  │  │  └────────────────────> 7: Знак          80h
         │  │  │  └───────────────────────> 8: Трассировка  100h
         │  │  └──────────────────────────> 9: Прерывания   200h
         │  └─────────────────────────────>10: Направление  400h
         └────────────────────────────────>11: Переполнение 800h

     Назначение флагов условий следующее:

     CF устанавливается, если  при выполнении сложения возникает
перенос,  а при  выполнении вычитания  - заем  из старшего  бита
результата;

     PF устанавливается, если сумма по модулю два младшего байта
результата равна нулю;

     АF устанавливается, если  при выполнении сложения возникает
перенос,  а  при  выполнении  сложения  -  заем из старшего бита
младшей тетрады результата;

     ZF устанавливается, если результат операции равен нулю;

     SF  устанавливается, если  старший бит  результата операции
равен нулю;

     Установка бита TF  переводит МП в пошаговый режим,  т. е. в
режим,  вызывающий прерывание  Int 01h  после выполнения  каждой
команды процессора;

     Установка бита  IF разрешает маскируемые  прерывания работы
МП, т. е. прерывания от внешних устройств;

     Если  бит  DF  установлен,  то  строковые команды уменьшают
адрес операндов; если он сброшен, то увеличивают;

     OF устанавливается, если  возникает переполнение результата
арифметической операции;  иными словами, при  сложении возникает
перенос  в старший  бит и   нет переноса  из старшего  бита, или
наоборот; при вычитании - возникает  заем из старшего бита и нет
заема в старший бит, или наоборот.
@pb
@e1     1.1.5. Методы адресации@e0

     МП 8086/8088  имеют несколько режимов  адресации, обеспечи-
вающих доступ к операндам,  хранящимся в памяти и/или регистрах,
а именно:

     1. Регистровая  адресация:  операндом  является  содержимое
регистра, указанного в команде, например  ADD AX,BX заносит в AX
сумму AX и BX.

     2. Неявная регистровая адресация: операндом является содер-
жимое регистра, заданного кодом команды, например MUL CL заносит
в AX произведение регистров CL и AL.

     3. Непосредственная адресация:  операнд задается в команде,
напринер MOV AX,1 засылает в регистр AX единицу.

     4. Прямая адресация: в  команде задается либо адрес памяти,
либо адрес порта ввода-вывода;  например, JMP 1000h осуществляет
переход по адресу памяти 1000h, a IN AL,60h вводит байт из порта
60h.

     5. Косвенная  регистровая  адресация: исполнительный  адрес
операнда задается  как смещение, равное  сумме содержимого базо-
вого  регистра,  индексного  регистра  и  смещения,  заданного в
команде (любое из слагаемых может отсутствовать). Примеры:

     MOV mem,AL
     MOV mem[BX],AL
     MOV mem[BX][SI],AL

Здесь mem - некоторая символическая метка адреса памяти.

     Кроме  того,  ряд   команд  использует  специальные  методы
адресации при работе со стеком и строками байтов.

Метод  адресации  задается  байтом  адресации,  который является
вторым байтом машинной команды и имеет следующую структуру:

┌7┬6┬5┬4┬3┬2┬1┬0┐
│MOD│ REG │ R/M │ Биты:                       Маска:
└─┼─┴─┴┬┴─┴─┴┬┴─┘ ─────                       ──────
  │    │     └───> 0-2: Регистр/память         07h
  │    └─────────> 3-5: Поле регистра          38h
  └──────────────> 6-7: Метод адресации        C0h

Исполнительные адреса операндов команды формируются в соответст-
вии со следующей таблицей.
@pb
─────┬─────────────────────────────────────────────────────
     │                        MOD
 R/M ├────────────┬──────────────┬───────────────┬─────────
     │    00      │      01      │       10      │   11
─────┼────────────┼──────────────┼───────────────┼────┬────
     │            │              │               │W=0 │W=1
     │            │              │               ├────┼────
 000 │ [BX]+[SI]  │ [BX]+[SI]+D8 │ [BX]+[SI]+D16 │ AL │ AX
 001 │ [BX]+[DI]  │ [BX]+[DI]+D8 │ [BX]+[DI]+D16 │ CL │ CX
 010 │ [BP]+[SI]  │ [BP]+[SI]+D8 │ [BP]+[SI]+D16 │ DL │ DX
 011 │ [BP]+[DI]  │ [BP]+[DI]+D8 │ [BP]+[DI]+D16 │ BL │ BX
 100 │   [SI]     │   [SI]+D8    │   [SI]+D16    │ AH │ SP
 101 │   [DI]     │   [DI]+D8    │   [DI]+D16    │ CH │ BP
 110 │Прямой адрес│   [BP]+D8    │   [BP]+D16    │ DH │ SI
 111 │   [BX]     │   [BX]+D8    │   [BX]+D16    │ BH │ DI
─────┴────────────┴──────────────┴───────────────┴────┴────

  Здесь бит  W задает байтовую/словную инструкцию.  D8/D16 - это
8- или 16-разрядное смещение (см. 1.1.6).

     Вычисление полного исполнительного  адреса операнда зависит
от  адреса сегмента,  в котором  операнд расположен.  В качестве
базового регистра  могут использоваться регистры  BX и BP.  Если
базовым является регистр BX, то по умолчанию операнд находится в
сегменте  данных, если  регистр BP,  то в  сегменте стека.  Если
базового  регистра  нет,  то  операнд  по  умолчанию находится в
сегменте данных.

     Для изменения  регистра сегмента команде  можно предпослать
префикс сегмента, например:

     MOV AL,mem     ; заслать в AL байт из DS:mem
     MOV AL,ES:mem  ; заслать в AL байт из ES:mem

     Таким  образом можно  указать сегмент  любого операнда,  за
исключением трех случаев:

     - извлечение команд всегда производится по адресу CS:IP;

     - SP  всегда используется только  как смещение относительно
сегмента SS;

     - команды  работы со строками, использующие  регистр ES, не
могут использовать вместо него другие регистры сегментов.
@pb
@e1     1.1.6. Форматы команд@e0

     Формат команды зависит от кода операции, метода адресации и
длины  данных,  непосредственно   заданных  в  команде.  Поэтому
команда занимает от 1 до 6 байтов:

┌─────┐
│ Код │
└─────┘
┌─────┐ ┌───┬───┬───┐
│ Код │ │MOD│ R1│ R2│
└─────┘ └───┴───┴───┘
┌─────┐ ┌───────┬───┐ ┌───────┐
│ Код │ │       │R/M│ │ data8 │
└─────┘ └───────┴───┘ └───────┘
┌─────┐ ┌───────┬───┐ ┌───────┐ ┌───────┐
│ Код │ │       │R/M│ │ d16-L │ │ d16-H │
└─────┘ └───────┴───┘ └───────┘ └───────┘
┌─────┐ ┌───┬───┬───┐ ┌───────┐ ┌───────┐ ┌───────┐
│ Код │ │MOD│REG│R/M│ │ d16-L │ │ d16-H │ │ data8 │
└─────┘ └───┴───┴───┘ └───────┘ └───────┘ └───────┘
┌─────┐ ┌───┬───┬───┐ ┌───────┐ ┌───────┐ ┌───────┐ ┌───────┐
│ Код │ │MOD│REG│R/M│ │ d16-L │ │ d16-H │ │ d16-L │ │ d16-H │
└─────┘ └───┴───┴───┘ └───────┘ └───────┘ └───────┘ └───────┘

     Здесь data8 - байт  непосредственных данных или 8-разрядное
смещение, d16-L и d16-H - соответственно младший и старший байты
слова непосредственных данных или 16-разрядного смещения.

     Первый байт команды всегда содержит код операции:

┌7┬6┬5┬4┬3┬2┬1┬0┐
│    коп    │D│W│ Бит:
└─┴─┴─┼─┴─┴─┴┬┴┬┘
      │      │ └─> 0: 0=обмен словами, 1=обмен байтами
      │      └───> 1: 0=пересылка из регистра
      │               1=пересылка в регистр
      └──────────> 2-7: код инструкции МП

     Второй  байт команды содержит байт  адресации. Байты  3 - 6
содержат непосредственные  данные или смещения,  задающие адреса
операндов.
@pb
@e1     1.1.7. Стек и система прерываний@e0

     Стек  представляет собой  область памяти,  используемую для
временного хранения  данных; он базируется на  сегменте стека. В
регистре  SS задается  базовый адрес  стека, в  SP -  наибольшее
допустимое смещение  в стековом сегменте.  Засылка (вталкивание)
данных в стек производится в  направлении меньших адресов, т. е.
уменьшением регистра SP; извлечение (выталкивание) данных проис-
ходит в обратном направлении.  Адрес стека, на который указывает
SP,  называется  вершиной  стека.  Ряд  команд  используют  стек
неявным  образом: вызов  подпрограмм засылает  адрес возврата  в
стек, а  возврат из подпрограммы извлекает  этот адрес из стека.
Кроме того, стек используется для обработки прерываний.

     МП 8086/8088  использует адреса памяти 00000h  - 003FFh для
хранения  т.  н.  векторов  прерываний.  Вектор  прерывания (ВП)
занимает  двойное  слово  и  содержит  адрес программы обработки
данного  прерывания в  формате сегмент:смещение.  Таким образом,
имеется 255  векторов прерываний, нумеруемых с  0 по FFh; вектор
прерывания n располагается по адресу 4*n.

     Всякий раз,  когда происходит прерывание,  текущие значения
CS, IP и регистра флагов  вталкиваются в стек и управление пере-
дается по  адресу, заданному в  соответствующем векторе прерыва-
ний.  Программа  обработки   прерывания  завершает  свою  работу
командой  IRET, которая  выталкивает из  стека регистр  флагов и
регистры CS и IP, продолжая работу прерванной программы.

     Вектора  прерываний 0  - 4  зарезервированы для  внутренних
прерываний процессора. Все они не маскируются сбросом флага IF.

@e1     1.1.7.1. Int 00h - Деление на нуль@e0

     Прерывание 0 (адрес ВП 00000h) происходит всякий раз, когда
результат команды  деления (DIV или  IDIV) не помещается  в опе-
ранд-приемник (в частности, при делении на нуль). Пример:

     MOV  AX,4000h       ; делимое
     MOV  BL,2           ; делитель
     DIV  BL             ; 4000h/2=2000h не помещается в AL,
                         ; поэтому выполняется Int 00h

или просто

     MOV  BX,0
     DIV  BX             ; деление на нуль

     При  написании своей  программы обработки  Int 00h  следует
учитывать, что МП  8086 и 8088 вталкивают в  стек CS:IP команды,
следующей за командой деления,  вызвавшей прерывание, а МП 80286
и 80386 - CS:IP самой команды DIV  или IDIV. Кроме того, 80286 и
80386  способны выдать  наибольшее отрицательное  число (80h или
8000h) в качестве частного, а  8086/8088 в этой ситуации генери-
рует Int 00h.

@e1     1.1.7.2. Int 01h - Пошаговое прерывание@e0

     Если установлен флаг TF, то после выполнения каждой команды
МП генерирует  это прерывание (ВП  00004h). Однако, при  входе в
любое прерывание  этот флаг автоматически  сбрасывается, так что
программа обработки прерываний выполняется  в обычном режиме. По
исполнении команды IRET восстанавливаются старые флаги условий и
пошаговый режим возобновляется.

     Это  прерывание обычно  используется отладчиками  для трас-
сировки  отлаживаемых программ.  Для перехода  в пошаговый режим
обычно используется следующий метод:

     PUSHF
     POP  AX             ; AX=флаги условий
     OR   AX,100h        ; установить бит TF
     PUSH AX             ; втолкнуть в стек
     MOV  AX,new_cs      ; занести в стек
     PUSH AX             ; адрес, на который нужно
     MOV  AX,new_ip      ; передать управление
     PUSH AX             ; в стек
     IRET                ; и вытолкнуть CS:IP и флаги

@e1     1.1.7.3. Int 02h - Немаскируемое прерывание@e0

     Прерывание 2  (адрес ВП 00008h)  связано с входом  МП NMI и
является  наиболее приоритетным  немаскируемым прерыванием.  Оно
резервируется  для  катастрофических  сбоев,  таких,  как потеря
питания.  Это   единственное   внешнее  прерывание,  которое  не
маскируется инструкцией CLI.

@e1     1.1.7.4. Int 03h - Прерывание по точке останова@e0

     Это   прерывание   (ВП   0000Ch)   вызывается   специальной
однобайтовой  инструкцией INT  3 и  предназначено для  установки
точек  останова  в  отлаживаемой  программе. Обычно используется
только программами-отладчиками.

@e1     1.1.7.5. Int 04h - Переполнение@e0

     Прерывание 4  (ВП 00010h) происходит,  если установлен флаг
OF  и  выполняется  инструкция  INTO.  Это  облегчает  написание
подпрограмм-ловушек арифметических переполнений. Пример:

     MOV  AX,var_1
     ADD  AX,var_2
     INTO           ; 2-байтовый тест на переполнение
     . . .

@e1     1.1.7.6. Внешние прерывания@e0

     Помимо прерываний по инициативе МП, возможны внешние преры-
вания,  определенные  пользователем.  Программные  внешние  пре-
рывания генерируются командой INT  nn. Обработка этих прерываний
происходит обычным образом.

     Внешние аппаратные прерывания инициируются внешними устрой-
ствами через вход INTR и маскируются битом IF. Вход INTR опраши-
вается  МП по  завершении каждой  команды; если  есть запрос  от
внешнего устройства, то генерируется соответствующее прерывание.
Имеется несколько исключений из этого правила, а именно:

     -  если выполнялась  команда засылки  в сегментный  регистр
(MOV или  POP), то опрос  входа INTR будет  произведен только по
окончании  следующей за  ней инструкции;  поэтому следующая пара
команд всегда выполняется без прерывания между ними:

     MOV  SS,stack_seg
     MOV  SP,stack_offs

     -  во  время  выполнения  команды  WAIT,  ожидающей низкого
уровня на входе TEST прерывания возможны; по завершении обработ-
ки прерывания гарантируется возврат к команде WAIT;

     - команда с предшествующим префиксом рассматривается МП как
единая команда; однако, строковые  команды с префиксом REP могут
быть прерваны  по окончании каждой из  строковых операций внутри
цикла (даже если команде предпослан префикс LOCK).

     Следует  обратить  внимание  на  тот  случай, когда команде
предшествуют   несколько  префиксов.   Дело  в   том,  что   при
возникновении  прерывания  МП  отслеживает  только  один префикс
команды,  что  может  привести   к  неверной  работе  прерванной
программы. Например, команда

     LOCK REP MOVSB CS:

может  быть  прервана  по  окончании  передачи  очередного байта
командой  MOVSB. После  обработки прерывания  префикс CS:  будет
корректно обработан  МП, но остальные префиксы  будут утеряны, и
пересылка  строки  не  дойдет  до  конца.  Для  преодоления этой
сложности рекомендуется следующая схема:

Block_Move:
     LOCK REP MOVSB CS:
     AND  CX,CX
     JNZ  Block_Move
@pb
@e1     1.1.8. Форматы данных@e0

     МП 8086/8088 поддерживает следующие формaты данных:

     - целое со знаком (байт и слово); знаковым является старший
бит, отрицательные числа представляются в дополнительном коде;

     - целое без знака (байт или слово);

     - указатель - двойное слово, задающее адрес памяти; младшее
слово содержит смещение, старшее - сегмент;

     - символ, т. е. байт в кодировке ASCII;

     - строка  - последовательность байтов или  слов длиной от 1
байта до 64 Кбайт;

     - неупакованное двоично-десятичное (BCD) число; каждый байт
содержит десятичную цифру;

     - упакованнное   двоично-десятичное   (BCD)  число;  каждая
тетрада содержит десятичную цифру.

     При   наличии   арифметического    сопроцессора   8087   МП
поддерживает дополнительно длинные целые  и плавающие числа (см.
гл. 4).
@pb
                   @e11.2. Система команд@e0

     Команды МП 8086/8088 подразделяются на следующие группы:

     - команды передачи данных;
     - ариметические операции;
     - логические операции;
     - команды работы со строками;
     - команды передачи управления;
     - команды управления процессором.

             @e11.2.1. Команды передачи данных@e0

@e1     1.2.1.1. Пересылка данных@e0

     MOV  dst,src                       Флаги: не изменяются

     Действие: dst <- src

     Копирует  src (байт  или слово)  в dst.  Возможны следующие
режимы пересылки:

     - из регистра в регистр;
     - из непосредственного операнда в регистр;
     - из непосредственного операнда в память;
     - из памяти в регистр;
     - из регистра в память;
     - из регистра или памяти в сегментный регистр (кроме CS);
     - из сегментного регистра в регистр или память.

     Примеры:  MOV  BX,AX
               MOV  AL,20h
               MOV  ES:[2],0FE00h
               MOV  DL,CS:[BX]
               MOV  DS:[SI],AX
               MOV  DS,CX
               MOV  CX,CS

@e1     1.2.1.2. Загрузка исполнительного адреса@e0

     LEA  reg,src                      Флаги: не изменяются

     Действие: reg <- addr(src)

     Заносит в reg исполнительный адрес операнда src. Src должен
быть  ссылкой  к  памяти,  reg  -  16-разрядным регистром общего
назначения. Примеры:

     LEA  DX,print_me
     LEA  AX,table[BX]
@pb
     1.2.1.3. Обмен значениями

     XCHG  opr,reg                       Флаги: не изменяются

     Действие: opr <-> reg

     Производит  обмен значениями  между  opr  и reg.  Opr может
регистром или словом/байтом памяти, reg - регистром. Примеры:

     XCHG  AX,SI
     LOCK  XCHG  mem,DX

     Сочетание   этой   команды   с   префиксом  LOCK  позволяет
реализовывать  семафоры для  управления совместно  используемыми
ресурсами.

@e1     1.2.1.4. Загрузка указателей@e0

     LDS  reg,src                       Флаги: не изменяются

     Действие: reg <- [src], DS <- [src+2]

     LES  reg,src                       Флаги: не изменяются

     Действие: reg <- [src], ES <- [src+2]

     Команда  LDS загружает  в регистры  DS и  reg указатель  из
адреса памяти  src (формат указателя  см. в 1.1.8).  Команда LES
загружает  указатель  в  регистры  ES  и  reg.  Reg  должен быть
16-разрядным регистром. Примеры:

     LDS  BX,DS:[0]
     LES  DI,table[BX]

@e1     1.2.1.5. Засылка в стек@e0

     PUSH  src                           Флаги: не изменяются

     Действие: SP <- SP-2, [SS:SP] <- src

     Вталкивает src в  стек, т. е. уменьшает SP  на 2 и засылает
src  по адресу  SS:SP.  Src  может быть  16-разрядным регистром,
сегментным  регистром  или  ссылкой  к  памяти.  Даже  если  src
указывает на байт памяти, в стек вталкивается слово. Примеры:

     PUSH AX
     PUSH CS
     PUSH ES:[4]

     Мы не  рекомендуем использовать команду PUSH  SP, т. к. она
по-разному исполняется на МП  8086/8088 и 80826/80386. 8086/8088
сначала  уменьшает SP,  а затем  вталкивает его  в стек; 80286 и
80386  вталкивают SP  в стек,  а затем  уменьшают его. Для того,
чтобы программа  не зависела от  процессора следует использовать
вместо PUSH SP следующий фрагмент:

     PUSH BP
     MOV  BP,SP
     XCHG BP,[BP]

@e1     1.2.1.6. Выборка из стека@e0

     POP  dst                           Флаги: не изменяются

     Действие: dst <- [SS:SP], SP <- SP+2

     Выталкивает вершину стека в dst,  т. е. пересылает слово из
SS:SP в src  и увеличивает SP на 2.  Dst может быть 16-разрядным
регистром, сегментным регистром (кроме CS) или ссылкой к памяти.

@e1     1.2.1.7. Трансляция@e0

     XLAT                               Флаги: не изменяются

     Действие: AL <- [BX+AL]

     Регистр BX должен содержать  адрес таблицы трансляции, AL -
перекодируемый   байт.   Команда   XLAT   извлекает  из  таблицы
трансляции  байт с  номером AL   и заносит  его в  AL. Следующий
пример  перекодирует  десятичное  число  от  0  до  15  в  соот-
ветствующую 16-ричную цифру:

     LEA  BX,hex_table
     MOV  AL,dec_digit
     XLAT
     . . .
hex_table DB   '0123456789ABCDEF'

@e1     1.2.1.8. Ввод данных@e0

     IN   acc,port                      Флаги: не изменяются

     Действие: acc <- [port]

     Вводит байт или слово из порта ввода-вывода port в acc. Acc
может быть регистром  AL (ввод байта) или AX  (ввод слова). Порт
может быть  задан либо непосредственным  байтом (от 0  до 0FFh),
либо содержимым регистра DX (любой порт). Примеры:

     IN   AL,21h
     IN   AL,DX
     IN   AX,DX

@e1     1.2.1.9. Вывод данных@e0

     OUT  port,acc                      Флаги: не изменяются

     Действие: [port] <- acc

     Выводит байт или слово из acc в порт ввода-вывода port. Acc
может быть регистром AL (вывод байта) или AX (вывод слова). Порт
может быть  задан либо непосредственным  байтом (от 0  до 0FFh),
либо содержимым регистра DX (любой порт). Примеры:

     OUT  20h,AX
     OUT  DX,AL

@e1     1.2.1.10. Загрузка флагов в аккумулятор@e0

     LAHF                               Флаги: не изменяются

     Действие: AH <- flg

     Загружает в регистр AH  младший байт регистра флагов. После
этой команды биты 1, 3 и 5 в AH не определены.

@e1     1.2.1.11. Загрузка флагов из аккумулятора@e0

     SAHF                               Флаги: O D I T S Z A P C
                                               - - - - * * * * *
     Действие: flg <- AH


     Загружает регистр AH в младший байт регистра флагов.

@e1     1.2.1.12. Засылка флагов в стек@e0

     PUSHF                              Флаги: не изменяются

     Действие: SP <- SP-2, [SS:SP] <- flg

     Вталкивает регистр флагов в стек, т. е. уменьшает SP на 2 и
засылает слово флагов по адресу SS:SP.

@e1     1.2.1.13. Выборка флагов из стека@e0

     POPF                               Флаги: O D I T S Z A P C
                                               * * * * * * * * *
     Действие: flg <- [SS:SP], SP <- SP+2

     Выталкивает флаги из стека, т. е. пересылает слово из SS:SP
в регистр флагов и увеличивает SP на 2.
@pb
@e1     1.2.2. Арифметические операции@e0

@e1     1.2.2.1. Сложение@e0

     ADD  dst,src                       Флаги: O D I T S Z A P C
                                               * - - - * * * * *
     Действие: dst <- src+dst

     Засылает сумму операндов src и dst (байтов или слов) в dst.
Операнды могут двоичными целыми числами со знаком или без знака.
Src  может быть  регистром, ячейкой  памяти или непосредственной
константой, dst - регистром или ячейкой памяти. Примеры:

     ADD  AX,BX
     ADD  CL,10
     ADD  DX,ES:[BX]
     ADD  total,AX
     ADD  sum,200h

@e1     1.2.2.2. Сложение с переносом@e0

     ADC  dst,src                       Флаги: O D I T S Z A P C
                                               * - - - * * * * *
     Действие: dst <- src+dst+CF

     Засылает  сумму операндов  src и  dst (байтов  или слов)  и
флага  CF  в  dst.  Операнды  могут  двоичными целыми числами со
знаком или  без знака. Src может  быть регистром, ячейкой памяти
или  непосредственной константой,  dst -  регистром или  ячейкой
памяти.  Эта команда  позволяет складывать  числа двойной длины,
например:

     MOV  AX,op_1        ; сложить младшие слова
     ADD  AX,op_2
     MOV  sum,AX         ; сохранить результат
     MOV  AX,op_1+2      ; сложить старшие слова
     ADC  AX,op_2+2      ; с учетом переноса
     MOV  sum+2,AX       ; и сохранить

@e1     1.2.2.3. Вычитание@e0

     SUB  dst,src                       Флаги: O D I T S Z A P C
                                               * - - - * * * * *
     Действие: dst <- dst-src

     Засылает разность dst-src (байтов или слов) в dst. Операнды
могут  двоичными целыми  числами со  знаком или  без знака.  Src
может  быть  регистром,   ячейкой  памяти  или  непосредственной
константой, dst - регистром или ячейкой памяти. Примеры:

     SUB  AX,BX
     SUB  CL,10
     SUB  DX,ES:[BX]
     SUB  total,AX
     SUB  sum,200h

     При   вычитании  байтовой   непосредственной  константы  из
слова-приемника перед вычитанием константа преобразуется в слово
расширением знакового бита.

@e1     1.2.2.4. Вычитание с заемом@e0

     SBB  dst,src                       Флаги: O D I T S Z A P C
                                               * - - - * * * * *
     Действие: dst <- dst-src-CF

     Засылает  разность  dst-src-CF  (байтов  или  слов)  в dst.
Операнды могут двоичными целыми числами со знаком или без знака.
Src  может быть  регистром, ячейкой  памяти или непосредственной
константой,  dst -  регистром  или  ячейкой памяти.  Эта команда
позволяет вычитать числа двойной длины, например:

     MOV  AX,op_1        ; извлечь первый операнд в DX:AX
     MOV  DX,op_1+2
     SUB  AX,op_2        ; вычесть второй операнд
     SBB  DX,op_2+2      ; с учетом заема
     MOV  sum,AX         ; и сохранить
     MOV  sum+2,DX

     При   вычитании  байтовой   непосредственной  константы  из
слова-приемника перед вычитанием константа преобразуется в слово
расширением знакового бита.

@e1     1.2.2.5. Увеличение на 1@e0

     INC  dst                           Флаги: O D I T S Z A P C
                                               * - - - * * * * -
     Действие: dst <- dst+1

     Увеличивает dst (байт или  слово) на единицу. Dst считается
беззнаковым  целым и  может быть  8- или  16-разрядным регистром
либо ячейкой  памяти. Эта команда  не изменяет флаг  CF, поэтому
для  сложения  длинного  целого  с  единицей  нужно использовать
команды ADD и ADC. Примеры:

     INC  AX
     INC  CL
     INC  table[BX]

@e1     1.2.2.6. Уменьшение на 1@e0

     DEC  dst                           Флаги: O D I T S Z A P C
                                               * - - - * * * * -
     Действие: dst <- dst+1

     Уменьшает dst  (байт или слово)  на единицу. Dst  считается
беззнаковым  целым и  может быть  8- или  16-разрядным регистром
либо ячейкой  памяти. Эта команда  не изменяет флаг  CF, поэтому
для  вычитания  единицы  из  длинного  целого нужно использовать
команды SUB и SBB. Примеры:

     DEC  AX
     DEC  CL
     DEC  table[BX]

@e1     1.2.2.7. Сравнение@e0

     CMP  dst,src                       Флаги: O D I T S Z A P C
                                               * - - - * * * * *
     Действие: flg <- (dst-src)

     Устанавливает флаги в соответствии с операцией dst-src. Dst
и src  не  изменяются.  Операнды   могут  байтами  или  словами,
двоичными  целыми  со  знаком  или  без  знака.  Src  может быть
регистром, ячейкой памяти или непосредственной константой, dst -
регистром или ячейкой памяти. Примеры:

     CMP  AX,BX
     CMP  CL,10
     CMP  DX,ES:[BX]
     CMP  total,AX
     CMP  sum,200h

     При сравнении байтовой непосредственной константы со словом
перед  вычитанием  константа  преобразуется  в слово расширением
знакового бита.

@e1     1.2.2.8. Обращение знака@e0

     NEG  dst                           Флаги: O D I T S Z A P C
                                               * - - - * * * * *
     Действие: dst <- -dst

     Вычитает dst (байт или слово) из  нуля и заносит в dst. Dst
считается  целым  со  знаком  и  может  быть 8- или 16-разрядным
регистром либо  ячейкой памяти. CF  сбрасывается, если dst=0,  и
устанавливается  в  остальных  случаях.  Если  NEG применяется к
байту   -128  или   слову  -32768,   то  dst   не  изменяется  и
устанавливается флаг OF. Примеры:

     NEG  AX
     NEG  CL
     NEG  table[BX]

@e1     1.2.2.9. Преобразование байта в слово@e0

     CBW                                Флаги: не изменяются

     Действие: if (AL<80h) then AH <- 0 else AH <- 0FFh

     Преобразует байт AL в слово AX расширением знакового бита.
AL  считается   целым  со  знаком.   Эта  команда  полезна   для
преобразования байта в слово перед делением на байт.
@pb
@e1     1.2.2.10. Преобразование слова в двойное слово@e0

     CWD                                Флаги: не изменяются

     Действие: if (AX<8000h) then DX <- 0 else DX <- 0FFFFh

     Преобразует  слово  AX  в  двойное  слово DX:AX расширением
знакового  бита.  AX  считается  целым  со  знаком.  Эта команда
полезна для преобразования слова  в двойное слово перед делением
на слово.

@e1     1.2.2.11. Умножение чисел без знака@e0

     MUL  src                           Флаги: O D I T S Z A P C
                                               * - - - ? ? ? ? *
     Действие: AX <- src * AL    (умножение байтов)
           или DX:AX <- src * AX (умножение слов)

     Выполняет умножение целых чисел без знака. Если src - байт,
то его произведение  на AL заносится в AX; если  src - слово, то
его  произведение  на  AX  заносится  в  двойное слово DX:AX (DX
содержит старшее  слово результата). Флаги CF  и OF устанавлива-
ются,  если старшая  половина  результата  (AH или  DX) содержит
значащие цифры результата. Src  может быть регистром или ячейкой
памяти, например:

     MUL  CH
     MUL  BX
     MUL  addr

@e1     1.2.2.12. Умножение чисел со знаком@e0

     IMUL  src                           Флаги: O D I T S Z A P C
                                                * - - - ? ? ? ? *
     Действие: AX <- src * AL    (умножение байтов)
           или DX:AX <- src * AX (умножение слов)

     Выполняет умножение целых чисел со знаком. Если src - байт,
то его произведение  на AL заносится в AX; если  src - слово, то
его  произведение  на  AX  заносится  в  двойное слово DX:AX (DX
содержит старшее  слово результата). Флаги CF  и OF устанавлива-
ются,  если старшая  половина  результата  (AH или  DX) содержит
значащие цифры результата. Src  может быть регистром или ячейкой
памяти, например:

     IMUL  CH
     IMUL  BX
     IMUL  addr
@pb
@e1     1.2.2.13. Деление чисел без знака@e0

     DIV  src                           Флаги: O D I T S Z A P C
                                               ? - - - ? ? ? ? ?

     Действие: AL <- AX / src, AH <- AX % src (деление байтов)
      или AX <- DX:AX / src, DX <-DX:AX % src (деление слов)

     Выполняет деление  целых чисел без знака.  Если src - байт,
то в  AL заносится частное,  а в AH  - остаток от  деления AX на
src;  если src  - слово,  то в  AX заносится  частное, а  в DX -
остаток  от  деления  DX:AX  на  src  (DX содержит старшее слово
делимого).  Флаги после  деления не  определены. Src  может быть
регистром или ячейкой памяти, например:

     DIV  CH
     DIV  BX
     DIV  addr

     Если  делимое  не  помещается  в  приемник, то генерируется
прерывание Int 00h и результат не определен.

@e1     1.2.2.14. Деление чисел со знаком@e0

     IDIV  src                          Флаги: O D I T S Z A P C
                                               ? - - - ? ? ? ? ?

     Действие: AL <- AX / src, AH <- AX % src (деление байтов)
      или AX <- DX:AX / src, DX <-DX:AX % src (деление слов)

     Выполняет деление  целых чисел со знаком.  Если src - байт,
то в  AL заносится частное,  а в AH  - остаток от  деления AX на
src;  если src  - слово,  то в  AX заносится  частное, а  в DX -
остаток  от  деления  DX:AX  на  src  (DX содержит старшее слово
делимого). Флаги после деления  не определены. Частное и остаток
имеют знак,  прочем знак остатка  совпадает со знаком  делимого.
Src может быть регистром или ячейкой памяти, например:

     IDIV  CH
     IDIV  BX
     IDIV  addr

     Если  делимое  не  помещается  в  приемник, то генерируется
прерывание Int 00h и результат не определен.

@e1     1.2.2.15. Символьная корректировка сложения@e0

     AAA                                Флаги: O D I T S Z A P C
                                               ? - - - ? ? * ? *
     Действие: if (AL & 0Fh > 9) or (AF=1)
                 then
                    AL <- AL+6, AH <- AH+1, AF <- 1, CF <- 1
                 else
                    AF <- 0, CF <- 0
               AL <- AL & 0Fh

     Выполняет  коррекцию  младшей  тетрады  AL  в неупакованный
BCD-формат,   предполагая,   что   AL   получен  сложением  двух
неупакованных  BCD-чисел  (старшая  тетрада  AL обнуляется). Эта
команда  используется  для   сложения  неупакованных  BCD-чисел.
Следующий  пример  показывает,  как  производится сложение таких
двухразрядных чисел (результат в DX):

     MOV  AL,op1         ; сложить младшие цифры
     ADD  AL,op2
     AAA                 ; и скорректировать
     MOV  DL,AL          ; сохранить результат
     MOV  AL,op1+1       ; сложить старшие цифры
     ADC  AL,op2+1       ; с учетом переноса
     AAA                 ; скорректировать
     MOV  DH,AL          ; и сохранить

@e1     1.2.2.16. Символьная корректировка вычитания@e0

     AAS                                Флаги: O D I T S Z A P C
                                               ? - - - ? ? * ? *
     Действие: if (AL & 0Fh > 9) or (AF=1)
                 then
                    AL <- AL-6, AH <- AH-1, AF <- 1, CF <- 1
                 else
                    AF <- 0, CF <- 0
               AL <- AL & 0Fh

     Выполняет  коррекцию  младшей  тетрады  AL  в неупакованный
BCD-формат,   предполагая,   что   AL   получен  вычитанием  двух
неупакованных  BCD-чисел  (старшая  тетрада  AL обнуляется). Эта
команда  используется  для   вычитания  неупакованных  BCD-чисел.
Следующий  пример  показывает,  как  производится вычитание таких
двухразрядных чисел (результат в DX):

     MOV  AL,op1         ; вычесть младшие цифры
     SUB  AL,op2
     AAS                 ; и скорректировать
     MOV  DL,AL          ; сохранить результат
     MOV  AL,op1+1       ; вычесть старшие цифры
     SBB  AL,op2+1       ; с учетом заема
     AAS                 ; скорректировать
     MOV  DH,AL          ; и сохранить

@e1     1.2.2.17. Символьная корректировка умножения@e0

     AAM                                Флаги: O D I T S Z A P C
                                               ? - - - * * ? * ?
     Действие: AH <- AL / 10, AL <- AL % 10

     Выполняет   коррекцию   AX   в   неупакованный  BCD-формат,
предполагая,  что  AX   получен  умножением  двух  неупакованных
BCD-чисел.  Старшие тетрады  AH и  AL должны  быть нулевыми. Эта
команда  используется  для  умножения  неупакованных  BCD-чисел.
Следующий  пример показывает,  как производится  умножение таких
двухразрядных чисел (a и b - сомножители, c - результат, u и v -
промежуточные результаты при умножении столбиком):

     MOV  AL,a
     MUL  b
     AAM
     MOV  u,AX
     MOV  AL,a+1
     MUL  b
     AAM
     ADD  AL,u+1
     AAA
     MOV  u+1,AX
     MOV  AL,a
     MUL  b+1
     AAM
     MOV  v,AX
     MOV  AL,a+1
     MUL  b+1
     AAM
     ADD  AL,v+1
     AAA
     MOV  v+1,AX
     MOV  AL,u
     MOV  c,AL
     MOV  AL,u+1
     ADD  AL,v
     AAA
     MOV  c+1,AL
     MOV  AL,v+2
     ADC  AL,u+1
     AAA
     MOV  c+2,AL
     MOV  AL,0
     ADC  AL,v+2
     AAA
     MOV  c+3,AL

@e1     1.2.2.18. Символьная корректировка деления@e0

     AAD                                Флаги: O D I T S Z A P C
                                               ? - - - * * ? * ?
     Действие: AL <- AH * 10 + AL, AH <- 0

     Выполняет  коррекцию  AX  в  неупакованный BCD-формат перед
делением двух  неупакованных BCD-чисел. Последующая  команда DIV
даст  в  результате  верные  неупакованныe  BCD-числа. Следующий
пример показывает, как производится деление двухразрядного числа
b на одноразрядное a (результат в c, остаток в r):

     MOV  AH,0
     MOV  AL,b+1
     DIV  a
     MOV  c+1,AL
     MOV  AL,b
     AAD
     DIV  a
     MOV  c,AL
     MOV  r,AH

@e1     1.2.2.19. Десятичная корректировка сложения@e0

     DAA                                Флаги: O D I T S Z A P C
                                               ? - - - * * * * *
     Действие: if (AL & 0Fh > 9) or (AF=1)
                 then
                    AL <- AL+6, AF <- 1
                 else
                    AF <- 0
               if (AL > 9Fh) or (CF=1)
                 then
                    AL <- AL+60h, CF <- 1
                 else
                    CF <- 0

     Выполняет   коррекцию   AL    в   упакованный   BCD-формат,
предполагая,   что   AL   получен   сложением  двух  упакованных
BCD-чисел.  Эта  команда  используется  для сложения упакованных
BCD-чисел.  Следующий пример  показывает, как  производится сло-
жение таких 4-разрядных чисел (результат в DX):

     MOV  AL,op1         ; сложить младшие цифры
     ADD  AL,op2
     DAA                 ; и скорректировать
     MOV  DL,AL          ; сохранить результат
     MOV  AL,op1+1       ; сложить старшие цифры
     ADC  AL,op2+1       ; с учетом переноса
     DAA                 ; скорректировать
     MOV  DH,AL          ; и сохранить

@e1     1.2.2.20. Десятичная корректировка вычитания@e0

     DAS                                Флаги: O D I T S Z A P C
                                               ? - - - ? ? * ? *
     Действие: if (AL & 0Fh > 9) or (AF=1)
                 then
                    AL <- AL-6, AF <- 1
                 else
                    AF <- 0
               if (AL > 9Fh) or (CF=1)
                 then
                    AL <- AL-60h, CF <- 1
                 else
                    CF <- 0

     Выполняет   коррекцию   AL    в   упакованный   BCD-формат,
предполагая,   что  AL   получен  вычитанием   двух  упакованных
BCD-чисел.  Эта команда  используется для  вычитания упакованных
BCD-чисел. Следующий  пример показывает, как  производится вычи-
тание таких 4-разрядных чисел (результат в DX):

     MOV  AL,op1         ; вычесть младшие цифры
     SUB  AL,op2
     DAS                 ; и скорректировать
     MOV  DL,AL          ; сохранить результат
     MOV  AL,op1+1       ; вычесть старшие цифры
     SBB  AL,op2+1       ; с учетом заема
     DAS                 ; скорректировать
     MOV  DH,AL          ; и сохранить

     Отметим,  что  команды   умножения  и  деления  упакованных
BCD-чисел в МП фирмы Intel отсутствуют.
@pb
@e1     1.2.3. Логические операции@e0

@e1     1.2.3.1. Логические сдвиги@e0

     SHR  dst,cnt                       Флаги: O D I T S Z A P C
                                               * - - - * * ? * *
     Действие:
                   ┌─────┐    ┌────┐
              0 -> │ dst │ -> │ CF │
                   └─────┘    └────┘
     SHL  dst,cnt                       Флаги: O D I T S Z A P C
                                               * - - - * * ? * *
     Действие:
              ┌────┐    ┌─────┐
              │ CF │ <- │ dst │ <- 0
              └────┘    └─────┘

     Команды логических  сдвигов сдвигают содержимое  dst (байта
или слова) на cnt битов вправо (SHR) или влево (SHL). Освобожда-
ющиеся  биты заполняются  нулями.  Счетчик  cnt может  быть либо
равен 1,  либо задается содержимым CL.  Dst может быть регистром
или ячейкой памяти. Примеры:

     SHL  AL,1
     SHR  SI,CL
     SHR  mem,1
     SHL  mem,CL

     Флаг CF  равен содержимому последнего  бита, выдвинутому из
dst. Если cnt = 1, то  флаг OF сбрасывается, если старшие 2 бита
исходного  операнда были  одинаковы, и  сбрасывается в противном
случае. Если cnt > 1, то OF неопределен.

     МП 80286  и 80386 ограничивают значениe  cnt диапазоном 0 -
31, т. е. используют величину счетчика, равную cnt % 32.

     Следующий  пример  показывает  преобразование 16-разрядного
неупакованного BCD-числа в упакованное:

     MOV  DX,8           ; счетчик цикла
     MOV  CL,4           ; счетчик сдвигов
     LEA  SI,Unpacked    ; адрес неупакованного BCD-числа
     LEA  DI,Packed      ; адрес упакованного BCD-числа
     PUSH DS
     POP  ES             ; ES <- DS
     CLD                 ; направление "вперед"
Convert:
     LODSW               ; AX <- DS:SI, SI <- SI+2
     SHL  AL,CL          ; упаковка AX
     SHR  AX,CL          ; в AL
     STOSB               ; ES:DI <- AL, DI <- DI+1
     DEC  DX             ; уменьшить счетчик цикла
     JNZ  Convert        ; повторять, пока он не нуль
@pb
@e1     1.2.3.2. Арифметические сдвиги@e0

     SAR  dst,cnt                       Флаги: O D I T S Z A P C
                                               * - - - * * ? * *
     Действие: ┌──┐
               │ ┌┴────┐    ┌────┐
               └>│ dst │ -> │ CF │
                 └─────┘    └────┘
     SAL  dst,cnt                       Флаги: O D I T S Z A P C
                                               * - - - * * ? * *
     Действие:
              ┌────┐    ┌─────┐
              │ CF │ <- │ dst │ <- 0
              └────┘    └─────┘

     Команды  арифметических  сдвигов  сдвигают  содержимое  dst
(байта  или слова)  на cnt  битов вправо  (SAR) или влево (SAL).
Освобождающиеся биты заполняются нулями в команде SAL и знаковым
разрядом  в команде  SAR. Счетчик  cnt может  быть либо равен 1,
либо  задается  содержимым  CL.  Dst  может  быть  регистром или
ячейкой  памяти.  Очевидно,  команды  SAL  и  SHL  эквивалентны.
Примеры:

     SAL  AL,1
     SAR  SI,CL
     SAR  mem,1
     SAL  mem,CL

     Флаг CF  равен содержимому последнего  бита, выдвинутому из
dst. Если cnt = 1, то флаг  OF сбрасывается; если cnt > 1, то OF
неопределен.

     МП 80286  и 80386 ограничивают значениe  cnt диапазоном 0 -
31, т. е. используют величину счетчика, равную cnt % 32.

@e1     1.2.3.3. Циклические сдвиги@e0

     ROR  dst,cnt                       Флаги: O D I T S Z A P C
                                               * - - - - - - - *
     Действие:  ┌────────┐
                │ ┌─────┐│  ┌────┐
                └>│ dst ├┴─>│ CF │
                  └─────┘   └────┘
     ROL  dst,cnt                       Флаги: O D I T S Z A P C
                                               * - - - - - - - *
     Действие:        ┌────────┐
              ┌────┐  │┌─────┐ │
              │ CF │<─┴┤ dst │<┘
              └────┘   └─────┘

     Команды циклических сдвигов  сдвигают содержимое dst (байта
или  слова) на  cnt битов  вправо (ROR)  или влево  (ROL). Биты,
выдвигающиеся из  операнда, вдвигаются в  него с другого  конца.
Счетчик cnt  может быть либо  равен 1, либо  задается содержимым
CL. Dst может быть регистром или ячейкой памяти. Примеры:

     ROL  AL,1
     ROR  SI,CL
     ROR  mem,1
     ROL  mem,CL

     Флаг CF  равен содержимому последнего  бита, выдвинутому из
dst. Если cnt = 1, то  флаг OF сбрасывается, если старшие 2 бита
исходного  операнда были  одинаковы, и  сбрасывается в противном
случае. Если cnt > 1, то OF неопределен.

     МП 80286  и 80386 ограничивают значениe  cnt диапазоном 0 -
31, т. е. используют величину счетчика, равную cnt % 32.

@e1     1.2.3.4. Циклические сдвиги через перенос@e0

     RCR  dst,cnt                       Флаги: O D I T S Z A P C
                                               * - - - - - - - *
     Действие:  ┌─────────────┐
                │ ┌─────┐   ┌─┴──┐
                └>│ dst ├──>│ CF │
                  └─────┘   └────┘
     RCL  dst,cnt                       Флаги: O D I T S Z A P C
                                               * - - - - - - - *
     Действие:  ┌──────────────┐
              ┌─┴──┐   ┌─────┐ │
              │ CF │<──┤ dst │<┘
              └────┘   └─────┘

     Команды   циклических   сдвигов   через   перенос  сдвигают
содержимое dst (байта  или слова) на cnt битов  вправо (RCR) или
влево (RCL). Биты, выдвигающиеся  из операнда, вдвигаются в него
с другого  конца,  проходя  через  флаг  CF  (иными  словами, CF
рассматривается  как дополнительный  бит операнда).  Счетчик cnt
может быть либо равен 1,  либо задается содержимым CL. Dst может
быть регистром или ячейкой памяти. Примеры:

     RCL  AL,1
     RCR  SI,CL
     RCR  mem,1
     RCL  mem,CL

     Флаг CF  равен содержимому последнего  бита, выдвинутому из
dst. Если cnt = 1, то  флаг OF сбрасывается, если старшие 2 бита
исходного  операнда были  одинаковы, и  сбрасывается в противном
случае. Если cnt > 1, то OF неопределен.

     МП 80286  и 80386 ограничивают значениe  cnt диапазоном 0 -
31, т. е. используют величину счетчика, равную cnt % 32.

@e1     1.2.3.5. Логическое "И"@e0

     AND  dst,src                       Флаги: O D I T S Z A P C
                                               0-------* * ? * 0
     Действие: dst <- src & dst

     Засылает  поразрядное логическое  "И" операндов  src и  dst
(байтов  или  слов)  в  dst.  Src  может быть регистром, ячейкой
памяти  или  непосредственной  константой,  dst  - регистром или
ячейкой памяти. Примеры:

     AND  AX,BX
     AND  CL,1
     AND  DX,mask
     AND  flags,AL
     AND  mem,200h

@e1     1.2.3.6. Логическое "ИЛИ"@e0

     OR   dst,src                       Флаги: O D I T S Z A P C
                                               0-------* * ? * 0
     Действие: dst <- src & dst

     Засылает поразрядное  логическое "ИЛИ" операндов  src и dst
(байтов  или  слов)  в  dst.  Src  может быть регистром, ячейкой
памяти  или  непосредственной  константой,  dst  - регистром или
ячейкой памяти. Примеры:

     OR   AX,BX
     OR   CL,10
     OR   DX,mask
     OR   flags,AL
     OR   mem,200h

@e1     1.2.3.7. Сложение по модулю два@e0

     XOR  dst,src                       Флаги: O D I T S Z A P C
                                               0-------* * * * 0
     Действие: dst <- src XOR dst

     Засылает поразрядную  сумму по модулю  два операндов src  и
dst (байтов или  слов) в dst. Src может  быть регистром, ячейкой
памяти  или  непосредственной  константой,  dst  - регистром или
ячейкой памяти. Примеры:

     XOR  AX,BX
     XOR  CL,10
     XOR  DX,mask
     XOR  flags,AL
     XOR  mem,200h

     Эта  команда  часто  используется  для  обнуления регистра:
например,  XOR AX,AX эквивалентна MOV AX,0 и выполняется на такт
быстрее (но изменяет флаги условий).

@e1     1.2.3.8. Логическое отрицание@e0

     NOT  dst                           Флаги: не изменяются

     Действие: dst <- ~ dst

     Засылает  поразрядное  логическое  отрицание  операнда  dst
(байта или  слова) в dst.  Dst может быть  регистром или ячейкой
памяти. Примеры:

     NOT  DX
     NOT  AL
     NOT  mask[BX]

@e1     1.2.3.9. Проверка битов@e0

     TEST dst,src                       Флаги: O D I T S Z A P C
                                               0 - - - * * ? * 0
     Действие: flg <- (dst & src)

     Устанавливает флаги  в соответствии с операцией  dst & src,
т. е. выполняет поразрядное логическое  "И" операндов. Dst и src
не  изменяются. Src  может  быть  регистром, ячейкой  памяти или
непосредственной константой, dst - регистром или ячейкой памяти.
Примеры:

     TEST SI,DX
     TEST BL,mask
     TEST AX,0F000h
     TEST param,1F1Fh

     Эта команда полезна для проверки, установлены ли определен-
ные биты в байте или слове.
@pb
@e1     1.2.4. Команды работы со строками@e0

     Для  работы  со  строками  байтов  или  слов в МП 8086/8088
предусмотрены 5  специальных команд, имеющих  общие особенности.
Каждая команда имеет две модификации, именуемые

     имяB - для работы с байтами, и
     имяW - для работы со словами.

     Операндом-источником  для  всех  строковых  команд является
содержимое  адреса DS:SI  (регистр DS  может быть  переопределен
префиксом  другого  сегментного  регистра). Операндом-приемником
всегда явлется ячейка памяти с адресом ES:DI.

     После  выполнения  строковой  команды  содержимое  SI  и DI
автоматически изменяются  на 1, если это  байтовая команда, и на
2, если  команда словная. Направление  изменения задается флагом
DF:  если DF  = 0,  то регистры  увеличиваются; если  DF = 1, то
уменьшаются.

@e1     1.2.4.1. Пересылка строки@e0

     MOVSB                              Флаги: не изменяются

     Действие: [ES:DI] <- [DS:SI] (байт)
               if DF = 0
                then SI <- SI+1, DI <- DI+1
                else SI <- SI-1, DI <- DI-1
     MOVSW                              Флаги: не изменяются

     Действие: [ES:DI] <- [DS:SI] (слово)
               if DF = 0
                then SI <- SI+2, DI <- DI+2
                else SI <- SI-2, DI <- DI-2

     Копирует байт (MOVSB) или слово  (MOVSW) из адреса DS:SI по
адресу  ES:DI. После  этого модифицирует  SI и  DI, как  описано
выше. Эта команда часто используется с префиксом REP для копиро-
вания строк.

@e1     1.2.4.2. Чтение строки@e0

     LODSB                              Флаги: не изменяются

     Действие: AL <- [DS:SI]
               if DF = 0
                then SI <- SI+1
                else SI <- SI-1
     LODSW                              Флаги: не изменяются

     Действие: AX <- [DS:SI]
               if DF = 0
                then SI <- SI+2
                else SI <- SI-2

     Читает  байт (LODSB)  или слово  (LODSW) из  адреса DS:SI в
аккумулятор. После  этого модифицирует SI,  как описано выше.  С
префиксом REP не используется, т. к. это не имеет смысла.

@e1     1.2.4.3. Запись строки@e0

     STOSB                              Флаги: не изменяются

     Действие: [ES:DI] <- AL
               if DF = 0
                then DI <- DI+2
                else DI <- DI-2
     STOSW                              Флаги: не изменяются

     Действие: [ES:DI] <- AX
               if DF = 0
                then DI <- DI+2
                else DI <- DI-2

     Записывает байт  (STOSB) или слово  (STOSW) из аккумулятора
по адресу ES:DI. После этого  модифицирует DI, как описано выше.
В сочетании с  префиксом REP позволяет  заполнить область памяти
значением аккумулятора.

@e1     1.2.4.4. Сравнение строк@e0

     CMPSB                              Флаги: O D I T S Z A P C
                                               * - - - * * * * *
     Действие: flg <- [DS:SI]-[ES:DI] (байты)
               if DF = 0
                then SI <- SI+1, DI <- DI+1
                else SI <- SI-1, DI <- DI-1

     CMPSW                              Флаги: O D I T S Z A P C
                                               * - - - * * * * *
     Действие: flg <- [DS:SI]-[ES:DI] (слова)
               if DF = 0
                then SI <- SI+2, DI <- DI+2
                else SI <- SI-2, DI <- DI-2

     Вычитает байты (CMPSB) или слова (CMPSW): содержимое адреса
DS:SI  минус содержимое  адреса  ES:DI,  и модифицирует  флаги в
соответствии с результатом (операнды не изменяются). После этого
модифицирует  SI  и  DI,  как  описано  выше.  Эта команда часто
используется  с  префиксом  REPE  для  сравнения  двух строк. По
завершении команды  REPE CMPSx флаг ZF  установлен, если найдено
различие, и сброшен в противном случае. Если  ZF = 1, то SI и DI
указывают на следующие байты/слова после давших несовпадение.
@pb
@e1     1.2.4.5. Сканирование строки@e0

     SCASB                              Флаги: O D I T S Z A P C
                                               * - - - * * * * *
     Действие: flg <- AL-[ES:DI]
               if DF = 0
                then DI <- DI+1
                else DI <- DI-1

     SCASW                              Флаги: O D I T S Z A P C
                                               * - - - * * * * *
     Действие: flg <- AX-[ES:DI]
               if DF = 0
                then DI <- DI+2
                else DI <- DI-2

     Вычитает  байты  (SCASB)   или  слова  (SCASW):  содержимое
аккумулятора минус содержимое адреса ES:DI, и модифицирует флаги
в соответствии  с  результатом  (операнды  не изменяются). После
этого  модифицирует  DI,  как  описано  выше.  Эта команда часто
используется с префиксом REPNE  для поиска байта/слова в строке.
По  завершении  команды  REPNE  SCASx  флаг  ZF установлен, если
образец найден, и сброшен в противном случае. Если ZF = 1, то DI
указывает на следующий байт/слово после совпавшего.

@e1     1.2.4.6. Префиксы повторений@e0

     Строковые команды  часто используются в  сочетании с т.  н.
префиксами повторений REP, REPE и REPNE.

     Префикс  REP  (синонимы  REPE,  REPZ)  выполняет  следующие
действия:

     - с командами MOVSx, LODSx и STOSx:
     while CX <> 0
          выполнить строковую операцию
          CX <- CX-1

     - с командами CMPSx и SCASx:
     while CX <> 0
          выполнить строковую операцию
          CX <- CX-1
          if ZF = 0 break

     Иными  словами,  префикс  REP  задает  выполнение строковой
команды  CX раз,  либо до  тех пока  не будет  сброшен флаг  ZF.
Проверка CX на равенство  нулю выполняется до строковой команды,
поэтому команда  REP MOVSB с нулевым  CX будет просто пропущена.
Проверка флага ZF производится после строковой операции.
@pb
     Префикс REPNE (синоним REPNZ) выполняет следующие действия:

     - с командами MOVSx, LODSx и STOSx:
     while CX <> 0
          выполнить строковую операцию
          CX <- CX-1

     - с командами CMPSx и SCASx:
     while CX <> 0
          выполнить строковую операцию
          CX <- CX-1
          if ZF = 1 break

     Он полностью  эквивалентен префиксу REP  с тем единственным
отличием, что  условием прерывания цикла  служит установка флага
ZF.

     Следующий пример копирует 100 байтов из buffer1 в buffer2:

     CLD                 ; направление "вперед"
     LEA  SI,buffer1     ; адреса строк
     LEA  DI,buffer2
     PUSH DS
     POP  ES             ; ES <- DS
     MOV  CX,100         ; счетчик цикла
     REP  MOVSB          ; копирование строк
@pb
@e1     1.2.5. Команды передачи управления@e0

@e1     1.2.5.1. Вызов подпрограммы@e0

     CALL opr                           Флаги: не изменяются

     Действие: if FAR CALL
                  PUSH CS
                  CS <- opr_seg
               PUSH IP
               IP <- opr_offs

     Эта команда обеспечивает сохранение адреса следующей за ней
команды в  стеке и передачу  управления по заданному  адресу. На
самом  деле мнемонику  CALL  имеют  две разные  команды: команда
ближнего вызова пoдпрограммы  (NEAR CALL), передающая управление
в пределах  текущего сегмента  кодов, и  команда дальнего вызова
(FAR CALL), передающая управление в другой сегмент.

     Ближний вызов подпрограммы вталкивает  значение IP в стек и
заменяет  его на  смещение до  вызываемой подпрограммы.  Дальний
вызов  сохраняет в  стеке CS  и IP  и заменяет  их на  сегмент и
смещение   вызываемой  подпрограммы.   Адрес  подпрограмммы  opr
задается либо  непосредственно в команде, либо  в регистре, либо
ссылкой к памяти, например:

     CALL near_proc
     CALL far_proc
     CALL AX
     CALL proc_table[SI]

     Возврат  из подпрограммы  осуществляется командой  RET, тип
которой (ближний или дальний) должен соответствовать типу CALL.

@e1     1.2.5.2. Возврат из подпрограммы@e0

     RET  opr                           Флаги: не изменяются

     Действие: POP  IP
               if FAR RET
                  POP CS
               SP <- SP + opr

     Эта  команда  обеспечивает  выталкивание  из  стека адреса,
сохраненного командой  CALL, и передачу на  него управления. Она
выталкивает из  стека счетчик команд IP  и, если возврат дальний
(межсегментный), то значение CS. Тем самым управление передается
на команду,  следующую за командой CALL,  вызвавшей эту подпрог-
рамму.

     В команде может быть задан необязательный операнд opr. Если
он есть, то его величина  прибавляется к регистру SP (что равно-
сильно выталкиванию из стека opr байтов). Примеры:

     RET
     RET  4

@e1     1.2.5.3. Безусловный переход@e0

     JMP  opr                           Флаги: не изменяются

     Действие: if FAR JMP
                  CS <- opr_seg
               IP <- opr_offs

     Эта команда  обеспечивает передачу управления  по заданному
адресу. На  самом деле мнемонику  JMP имеют две  разные команды:
команда ближнего  перехода (NEAR JMP ),  передающая управление в
пределах  текущего сегмента  кодов, и  команда дальнего перехода
(FAR JMP ), передающая управление в другой сегмент.

     Ближняя передача управления заменяет  IP на новое значение.
Дальняя передача управления заменяет CS  и IP на новые сегмент и
смещение.  Адрес перехода  opr задается  либо непосредственно  в
команде, либо в регистре, либо ссылкой к памяти, например:

     JMP  near_label
     JMP  far_label
     JMP  BX
     JMP  label_table[SI]

@e1     1.2.5.4. Команды условного перехода@e0

     Все  конанды условного  перехода  имеют  вид Jxx  disp, где
disp  -  8-разрядное  смещение  в  дополнительном  коде. Команда
проверяет  определенное  условие  и,  если  оно  верно, изменяет
значение  IP  на  заданное  смещение.  Длина  смещения позволяет
передать  управление  в  диапазоне  от  -128  до  +127 байтов от
текущей команды.  Условием перехода служит  определенная комбин-
ация  флагов условий,  задаваемая мнемоникой  команды Jxx.  Сама
команда перехода  флаги условий не изменяет.  МП 8086/8088 имеют
следующие команды условного перехода:
@pb
────────────────────────────────────────────────────────────────
Мнемоника Синонимы Условие             Назначение
команды            перехода
────────────────────────────────────────────────────────────────
JZ  dest  JE       ZF=1          Перейти, если нуль (равно)
JNZ dest  JNE      ZF=0          Перейти, если не нуль (не равно)
JS  dest           SF=1          Перейти, если знак минус
JNS dest           SF=0          Перейти, если знак плюс
JO  dest           OF=1          Перейти, если переполнение
JNO dest           OF=0          Перейти, если нет переполнения
JP  dest  JPE      PF=1          Перейти, если четный паритет
JNP dest  JPO      PF=0          Перейти, если нечетный паритет
JB  dest  JNAE,JC  CF=1          Перейти, если ниже
JNB dest  JAE,JNC  CF=0          Перейти, если выше или равно
JA  dest  JNBE     CF=0 & ZF=0   Перейти, если выше
JNA dest  JBE      CF=1 | ZF=1   Перейти, если ниже или равно
JL  dest  JNGE     SF<>OF        Перейти, если меньше
JNL dest  JGE      SF=OF         Перейти, если больше или равно
JG  dest  JNLE     ZF=0 & SF=OF  Перейти, если больше
JNG dest  JLE      ZF=1 | SF<>OF Перейти, если меньше или равно
JCXZ dest          CX=0          Перейти, если CX равно нулю
────────────────────────────────────────────────────────────────

     Команды JB, JNB, JA, JNA обеспечивают переход после сравне-
ния двух целых чисел без знака. Команды JL, JNL, JG, JNG обеспе-
чивают переход  после сравнения целых  чисел со знаком.  Команда
JCXZ передает управление, если CX  = 0, и используется совместно
с командами циклов (см. 1.2.5.5).

@e1     1.2.5.5. Команды циклов@e0

     Все  конанды  циклов  имеют  вид  LOOPxx  disp,  где disp -
8-разрядное  смещение  в   дополнительном  коде.  Команда  цикла
уменьшает  регистр CX  на 1,  и если  выполнено связанное  с ней
условие,  заменяет  значение  IP  на  заданное  смещение:

     CX <- CX-1
     if (условие) JMP dest

     Длина смещения позволяет передать управление в диапазоне от
-128 до +127 байтов от текущей команды. Условием перехода служит
определенная  комбинация флагов  условий, задаваемая  мнемоникой
команды LOOPxx. Сама команда цикла флаги условий не изменяет. МП
8086/8088 имеют следующие команды циклов:

────────────────────────────────────────────────────────────────
Мнемоника   Синонимы Условие             Назначение
команды              цикла
────────────────────────────────────────────────────────────────
LOOP   dest          CX<>0        Зациклить
LOOPZ  dest  LOOPE   ZF=1 & CX<>0 Цикл, пока нуль (равно)
LOOPNZ dest  LOOPNE  ZF=0 & CX=0  Цикл, пока не нуль (не равно)
────────────────────────────────────────────────────────────────

     Из  таблицы   видно,  что  эти   команды  позволяют  удобно
реализовывать циклы с постусловием вида

     MOV  CX,cnt    ; счетчик цикла
Start:
     .  .  .
     LOOP Start

     Следующий пример  ищет в ASCII-строке str  длины len символ
пробела;  если  символ  не  найден,  производит  переход к метке
Not_Found.

     MOV  CX,L
     JCXZ Not_Found
     LEA  SI,str-1
     MOV  AL,20h
Next_Chr:
     INC  SI
     CMP  AL,[SI]
     LOOPNE Next_Chr
     JNZ  Not_Found

@e1     1.2.5.6. Программное прерывание@e0

     INT opr                            Флаги: O D I T S Z A P C
                                               0 0 - - - - - - -
     Действие: PUSHF
               TF <- 0, IF <- 0
               CALL FAR [0:4*num]

     Эта команда сохраняет в стеке регистр флагов и текущие CS и
IP,  сбрасывает флаги  TF и  IF и  передает управление программе
обработки соответствующего прерывания (номер прерывания задается
непосредственным операндом opr и лежит в диапазоне от 0 до 255).
Если программа  обработки прерываний завершается  командой IRET,
то  флаги  условий  восстанавливаются  и  управление  передается
команде, следуюшей  командой INT. Команда  INT opr занимает  два
байта, за исключением  случая opr=3: INT 3 занимает  один байт и
используется   в  качестве   точки  останова   отладчиками  (см.
1.1.7.4).

@e1     1.2.5.6. Прерывание по переполнению@e0

     INTО                               Флаги: O D I T S Z A P C
                                               0 0 - - - - - - -
     Действие: if (OF=1)
                  PUSHF
                  TF <- 0, IF <- 0
                  CALL FAR [0:10h]

     Эта команда проверяет флаг OF;  если он сброшен, то команда
игнорируется, если установлен, то  вызывается прерывание номер 4
(т. е. в  этом случае INTO эквивалентна INT  4). Подробнее см. в
п. 1.1.7.5.
@pb
@e1     1.2.5.7. Возврат из прерывания@e0

     IRET                               Флаги: O D I T S Z A P C
                                               * * * * * * * * *
     Действие: POP  IP
               POP  CS
               POPF

     Завершает программу обработки прерывания, восстанавливая из
стека адрес прерванной программы и флаги условий.
@pb
@e1     1.2.6. Команды управления процессором@e0

@e1     1.2.6.1. Управление флагами условий@e0

     МП 8086/8088 имеют 7 команд, позволяющих сбросить или уста-
новить определенный флаг условий (остальные флаги остаются неиз-
менными):

────────────────────────────────────────────────────────────────
Мнемоника  Действие           Назначение
────────────────────────────────────────────────────────────────
CLC        CF <- 0    Сбрасывает флаг CF
STC        CF <- 1    Устанавливает флаг CF
CMC        CF <- ~CF  Засылает в CF обратное текущему значение
CLD        DF <- 0    Сбрасывает флаг DF
STD        DF <- 1    Устанавливает флаг DF
CLI        IF <- 0    Сбрасывает флаг IF
STI        IF <- 1    Устанавливает флаг IF
────────────────────────────────────────────────────────────────

     Следует  отметить, что  если к  моменту подачи  команды STI
имелось задержанное  прерывание, то оно  призойдет по завершении
следующей за STI команды.

@e1     1.2.6.2. Останов процессора@e0

     HLT                                Флаги: не изменяются

     Эта  команда  переводит  МП  в  состояние останова, которое
продолжается до наступления одного из событий:

     - возникновения немаскируемого внешнего прерывания;
     - возникновения маскируемого внешнего прерывания, если флаг
IF установлен;
     - активизации линии RESET (внешнего сброса МП).

@e1     1.2.6.3. Холостая команда@e0

     NOP                                Флаги: не изменяются

     Эта  команда  не  выполняет  никаких  действий.  Обычно она
применяется  для временных  задержек, для  выравнивания кода  на
какую-либо границу или в качестве "заполнителя места".

@e1     1.2.6.4. Ожидание@e0

     WAIT                               Флаги: не изменяются

     Переводит МП в состояние  ожидания, которое продолжается до
тех пор, пока не активизируется  линия TEST. Прерывания в состо-
янии ожидания разрешены. Обычно используется для синхронизации с
внешними устройствами (в частности, с сопроцессором).
@pb
@e1     1.2.6.5. Захват шины@e0

     LOCK                               Флаги: не изменяются

     Этот   однобайтовый  префикс   может  предшествовать  любой
команде.  Он  захватывает  системную  шину  на  время выполнения
следующей  за  ним  команды,  исключая  тем  самым доступ к шине
других устройств,  включая прерывания и прямой  доступ к памяти.
Эта команда предназначена для  реализации семафоров и управления
совместно используемыми ресурсами в многопроцессорных конфигура-
циях.  Для  совместимости  с  МП  80286  и  80386  рекомендуется
использовать ее только с командами XCHG, ADD, OR, ADC, SBB, AND,
SUB, XOR, NOT, NEG, INC и DEC, например:

     LOCK XCHG flag,AL

@e1     1.2.6.6. Команда сопроцессору@e0

     ESC  opr,src                       Флаги: не изменяются

     Эта команда передает код операции opr сопроцессору, который
перехватывает  этот код  и выбирает  с адресной  шины 20-битовый
физический адрес операнда src.  В зависимости от операции сопро-
цессор  либо  считывает  содержимое  src,  либо  выводит  в него
результат  операции по  ее  завершению.  Для гарантии  того, что
сопроцессор завершил операцию, МП должен выдать команду WAIT:

     8086/8088                          Сопроцессор
         ║                                   ╔═════════════╗
        \ /                                 \ /            ║
      ┌─────┐   Активизировать      ┌─────────────────┐    ║
      │ ESC │ - - - - - - - - - - > │ Следить за 8086 │    ║
      └─────┘    сопроцессор        └─────────────────┘    ║
         ║                                   ║             ║
        \ /                                 \ /            ║
  ┌──────────────┐               ┌───────────────────────┐ ║
  │  Выполнять   │               │ Сбросить вход МП TEST │ ║
  │ команды 8086 │               │  и выполнить команду  │ ║
  └──────────────┘               └───────────────────────┘ ║
         ║                                   ║             ║
        \ /                                 \ /            ║
      ┌──────┐      Активизировать    ┌────────────┐       ║
      │ WAIT │ < - - - - - - - - - - -│ Установить │       ║
      └──────┘  центральный процессор │ вход TEST  │       ║
         ║                            └──────╥─────┘       ║
        \ /                                  ╚═════════════╝

     Примеры  использования  команды  ESC  приведены  в описании
арифметических сопроцессоров (см. гл. 4 - 6).

@e1     1.2.6.7. Префиксы сегментов@e0

     Как  указывалось  в  1.1.5,  команде  может быть предпослан
однобайтовый  префикс, переопределяющий  сегмент операнда.  Хотя
префикс  сегмента предшествует  команде, его  принято записывать
перед операндом. Например, пару команд

     ES:            ; префикс сегмента ES
     MOV  AL,[BX]

мы записываем в виде MOV AL,ES:[BX].
@pb
          @e12. 16-разрядный микропроцессор 80286@e0
                @e12.1. Техническое описание@e0

@e1     2.1.1. Общая характеристика@e0

     16-разрядный  МП Intel  80286 -  это высокопроизводительный
процессор,  ориентированный на  многопользовательские и многоза-
дачные системы. Он имеет  встроенную защиту памяти и возможности
по   управлению   памятью,   позволяющие   отображать   1  Гбайт
виртуальной памяти каждой задачи в 16 Мбайт физической памяти.

     МП 80286 имеет два режима  работы: реальный и защищенный. В
реальном режиме  он обеспечивает совместимость снизу  вверх с МП
8086/8088. В  защищенном режиме он обеспечивает  работу с вирту-
альной памятью и защиту памяти.

     МП   80286  производится   по  высококачественной  МОП-тех-
нологии.  Он   имеет  одну  из  следующих   тактовых  частот:  6
(80286-6),  8 (80286-8),  10 (80286-10)  или 12  (80286-12) Мгц.
Разводка его  68-штырькового корпуса (вид  со стоpоны контактных
площадок) приведена на рис. 2.1.
@pb
          V D D D D D D D D D D D D D D D D
          s 0 8 1 9 2 1 3 1 4 1 5 1 6 1 7 1
          s           0   1   2   3   4   5
        ┌───────────────────────────────────┐
      ┌─┘35                                 └─┐
   A0 │ ]                                   52│ CAP
      │                                       │ _____
   A1 │ ]                                   [ │ ERROR
      │                                       │ ____
   A2 │ ]                                   [ │ BUSI
      │                                       │
  CLK │ ]                                   [ │ н/к
      │                                       │
  Vcc │ ]                                   [ │ н/к
      │                                       │
RESET │ ]                                   [ │ INTR
      │                                       │
   A3 │ ]                                   [ │ н/к
      │                                       │
   A4 │ ]                                   [ │ NMI
      │                                       │
   A5 │ ]                                   [ │ Vss
      │                                       │
   A6 │ ]                                   [ │ PEREQ
      │                                       │
   A7 │ ]                                   [ │ Vcc
      │                                       │ _____
   A8 │ ]                                   [ │ READY
      │                                       │
   A9 │ ]                                   [ │ HOLD
      │                                       │
  A10 │ ]                                   [ │ HLDA
      │                                       │     ____
  A11 │ ]                                   [ │ COD/INTA
      │                                       │   __
  A12 │ ]                                   [ │ M/IO
      │                                       │ ____
  A13 │18                                   [ │ LOCK
      └─┐                                 1 ┌─┘
        └───────────────────────────────────┘
          A A A A A A A A V A A P S S н н B
          1 1 1 1 1 1 2 2 s 2 2 E 0 1 / / H
          4 5 6 7 8 9 0 1 s 2 3 A     к к E
                                C
                                K

     Рис. 2.1. Разводка контактов коpпуса МП 80286 (площадки,
помеченные н/к, подключать нельзя).
@pb
     Контакты МП имеют следующее назначение.

────────────────────────────────────────────────────────────────
Обозначение Вход/выход            Описание
────────────────────────────────────────────────────────────────
    CLK        ВХОД      СИНХРОНИЗАЦИЯ с частотой, зависящей от
                         типа МП
  D15-D0     ВХ/ВЫХ      ШИНА ДАННЫХ: Эти линии вводят и выводят
                         данные.
  A23-A0      ВЫХОД      ШИНА АДРЕСА: Выводит адреса памяти и
    ___                  портов ввода-вывода.
    BHE       ВЫХОД      СОСТОЯНИЕ ПЕРЕДАЧИ: Вместе с A0 задает
                         вид передачи:
                           ___
                           BHE  A0      Функция
                            0   0   Передача слова
                            0   1   Передача байта по D15-D8
                            1   0   Передача байта по D7-D0
                            1   1   Запрещенная комбинация
    __ __
    S1,S0     ВЫХОД      СОСТОЯНИЕ ЦИКЛА ШИНЫ: Вместе с M/IO
                         и COD/INTA определяет тип цикла шины
      __                 (см. ниже).
    M/IO      ВЫХОД      ВЫБОР: Различает доступ к памяти и
      ____               доступ к портам ввода-вывода (см. ниже)
  COD/INTA    ВЫХОД      ПОДТВЕРЖДЕНИЕ: Различает загрузку ко-
                         манд и данных, а также квитирование
    ____                 прерываний и циклы ввода-вывода.
    LOCK      ВЫХОД      ЗАХВАТ ШИНЫ: Инициируется префиксом
                         LOCK.
    HDLA     ВЫХОД       Разрешение шины запрашивающему ведущему.
    HOLD      ВХОД       Запросы шины от других ведущих. ЦП не
                         получает управления шиной до снятия
                         этого сигнала.
    INTR      ВХОД       ЗАПРОС МАСКИРУЕМОГО ПРЕРЫВАНИЯ: вызов
                         прерывания, задаваемого уровнем.
     NMI      ВХОД       НЕМАСКИРУЕМОЕ ПРЕРЫВАНИЕ:вход, вызы-
                         вающий прерывание 2 и не маскируемый
                         программно.
   PEREQ      ВХОД       ЗАПРОС И ПОДТВЕРЖДЕНИЕ ДЛЯ СОПРОЦЕССО-
   _____                 РА: Вход PEREQ запрашивает МП передать
   PEACK     ВЫХОД       данные сопроцессору, выход PEACK подт-
    ____                 верждает передачу данных.
    BUZY      ВХОД       СВЯЗЬ С СОПРОЦЕССОРОМ: Вход BUZY при-
                         останавливает работу МП на командах
   _____                 вход ERROR вызывает прерывание МП 10h
   ERROR      ВХОД       при выполнении этих команд.
   RESET      ВХОД       СБРОС: прекращает работу МП, обнуляет
                         PSW, IP, DS, SS, ES и очередь команд,
                         засылает в CS 0FFFFF0h.
   READY      ВХОД       ГОТОВНОСТЬ: подтверждение от памяти
                         или интерфейса ввода-вывода о том, что
                         ЦП может закончить текущий цикл шины.
    Vss        ---       земля
    Vcc        ---       напряжение питания +5 В

     Состояние щины МП 80286 определяется следующим образом:

───────────────────────────────────────────────────────────────
    ____    __ __  __
COD/INTA  M/IO S1  S0 Инициируемый цикл шины
───────────────────────────────────────────────────────────────
   0       0   0   0  Подтверждение прерывания
   0       0   0   1  Запрещенная комбинация
   0       0   1   0  Запрещенная комбинация
   0       0   1   1  Отсутствует
   0       1   0   0  Если A1=1, то останов; иначе выключение
   0       1   0   1  Чтение данных из памяти
   0       1   1   0  Запись данных в память
   0       1   1   1  Отсутствует
   1       0   0   0  Запрещенная комбинация
   1       0   0   1  Чтение ввода-вывода
   1       0   1   0  Запись ввода-вывода
   1       0   1   1  Отсутствует
   1       1   0   0  Запрещенная комбинация
   1       1   0   1  Чтение команды из памяти
   1       1   1   0  Запрещенная комбинация
   1       1   1   1  Отсутствует
───────────────────────────────────────────────────────────────
@pb
@e1     2.1.2. Функциональное описание@e0

     МП 80286 содержит все регистры, команды и режимы адресации,
которыми  располагают   МП  8086/8088.  Поэтому   в  последующих
разделах будут описаны только его дополнительные возможности.

@e1     2.1.3. Регистры и флаги@e0

     Регистр  флагов условий МП 80286 имеет следующий вид:

 1 1  1 1   1  1
┌5┬4─┬3┬2─┬─1┬─0┬─9┬─8┬─7┬─6┬5┬─4┬3┬─2┬1┬─0┐
│*│NT│IOPL│OF│DF│IF│TF│SF│ZF│*│AF│*│PF│*│CF│ Бит:        Маска:
└─┴┬─┴─┼──┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴─┴┬─┴─┴┬─┴─┴┬─┘
   │   │   │  │  │  │  │  │    │    │    └──> 0: CF          1h
   │   │   │  │  │  │  │  │    │    └───────> 2: PF          4h
   │   │   │  │  │  │  │  │    └────────────> 4: AF         10h
   │   │   │  │  │  │  │  └─────────────────> 6: ZF         40h
   │   │   │  │  │  │  └────────────────────> 7: SF         80h
   │   │   │  │  │  └───────────────────────> 8: TF        100h
   │   │   │  │  └──────────────────────────> 9: IF        200h
   │   │   │  └─────────────────────────────>10: DF        400h
   │   │   └────────────────────────────────>11: OF        800h
   │   └────────────────────────────────────>12-13: IOPL  3000h
   └────────────────────────────────────────>14: NT       4000h

     Новыми  здесь являются  флаги IOPL  и NT.  Они используются
только в защишенном режиме. Поле IOPL, уровень привилегий ввода-
вывода,  используется для  того, чтобы  не допустить  выполнения
команд ввода-вывода  задачей, не имеющей на  это права. Значение
IOPL изменяется командой POPF, выполняющейся  на уровне 0, и при
переключении задач.

     Флаг  NT  указывает  вложенность  текущей  задачи  в другую
задачу. Если  он установлен, то текущая  задача имеет правильную
обратную связь с предыдущей  задачей. Значение этого флага изме-
няется  при  передаче  управления   через  шлюзы,  прерывания  и
ловушки (см. 2.1.5.6).

     Слово состояния  машины (MSW) хранит  информацию о переклю-
чении задач и управляет режимом работы МП. Оно имеет вид:

 1 1 1 1 1 1
┌5┬4┬3┬2┬1┬0┬9┬8┬7┬6┬5┬4┬─3┬─2┬─1┬─0┐
│*│*│*│*│*│*│*│*│*│*│*│*│TS│EM│MP│PE│ Бит:                Маска:
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴┬─┴┬─┴┬─┴┬─┘
                         │  │  │  └──> 0:Защищенный режим      1
                         │  │  └─────> 1:Наличие сопроцессора  2
                         │  └────────> 2:Эмуляция сопроцессора 4
                         └───────────> 3:Переключение задач    8

     Установка бита PE переводит  МП в защищенный режим. Возврат
в реальный  режим возможен  только внешним  сбросом МП  по входу
RESET.

     Если  бит  MP  установлен,  то  при отсутствии сопроцессора
команда WAIT будет генерировать Int 07h.

     Установка бита  EM разрешает эмуляцию  сопроцессора. В этом
случае  по инструкции  ESC  будет  генерироваться Int  07h, если
сопроцессор отсутствует.

     Если бит  TS установлен, то первая  команда, обращающаяся к
сопроцессору, вызовет Int 07h, позволяя программному обеспечению
проверить, принадлежит ли  текущий контекст сопроцессора текущей
задаче. Автоматически устанавливается при переключении задач.

     Рекомендуется следующее использование битов MSW.

TS MP EM  Рекомендуемое применение                   Источники
                                                      Int 07h
────────────────────────────────────────────────────────────────
0  0  0   Начальная установка после RESET; 80286         Нет
          работает так же, как 8086/8088.
0  0  1   Сопроцессора нет. Его функции эмулируются      ESC
          программно.
1  0  1   Сопроцессора нет. Его функции эмулируются      ESC
          программно. Текущий контекст сопроцессора
          может принадлежать другой задаче.
0  1  0   Сопроцессор есть.                              Нет
1  1  0   Сопроцессор есть. Текущий контект сопро-       ESC
          цессора может принадлежать другой задаче.      или
          Int 07h при выполнении WAIT позволяет          WAIT
          программно проверить наличие задержанных
          ошибок от предыдущей операции сопроцессора.
────────────────────────────────────────────────────────────────

     Помимо  регистров  8086/8088,  МП  80286  имеет  ряд  новых
регистров,  которые  также   используются  только  в  защищенном
режиме и  подробно описаны в п.  2.1.5. Сюда относятся следующие
регистры:

     TR  -  селектор  сегмента  состояния  текущей  задачи  (см.
2.1.5.6);

     LDTR  -   селектор  локальной  таблицы   дескрипторов  (см.
2.1.5.3);

     GDTR  -  селектор   глобальной  таблицы  дескрипторов  (см.
2.1.5.3);

     IDTR  -  селектор   таблицы  дескрипторов  прерываний  (см.
2.1.5.3).
@pb
@e1     2.1.4. Прерывания@e0

     Система прерываний МП  80286 устроена так же, как  у 8086 и
8088. Ее отличие состоит  в большем количестве прерываний, гене-
рируемых процессором. Помимо векторов Int 00h - Int 04h, исполь-
зуемых  8086/8088, этот  процессор резервирует  прерывания 05h -
10h.

@e1     2.1.4.1. Int 05h - Выход за границы массива@e0

     Это  прерывание  (адрес  ВП  00014h)  генерируется командой
BOUND, если  она обнаруживает выход индекса  за границы массива.
При этом в стек помещаются CS и IP команды BOUND, а не следующей
за ней. Пример:

     MOV   AX,10     ; индекс массива = 10
     BOUND AX,limits ; вне границ => Int 05h
     .  .  .
limits    DW   0,9   ; границы массива X[0:9]

@e1     2.1.4.2. Int 06h - Неверный код операции@e0

     Int 06h (ВП 00018h)  происходит всякий раз, когда процессор
пытается выполнить несуществующую команду (т. е. если встретился
код  несуществующей команды,  недопустимый режим  адресации опе-
ранда команды или привилегированная команда в рельном режиме). В
стек заносятся CS и IP команды, вызвавшей прерывание.

@e1     2.1.4.3. Int 07h - Отсутствие сопроцессора@e0

     Это  прерывание  (ВП   0001Ch)  генерируется  в  нескольких
ситуациях,  которые определяются  содержимым MSW  (см. 2.1.3). В
общем случае Int 07h может  генерироваться командами ESC и WAIT,
если они  обнаруживают, что сопроцессор  отсутствует. Это позво-
ляет писать программы,  эмулирующие работу сопроцессора, подклю-
чая их к  обработчику данного прерывания. В стек  заносятся CS и
IP команды, вызвавшей прерывание.

@e1     2.1.4.4. Int 08h - Двойное исключение@e0

     Это  прерывание  (ВП  00020h)  имеет  разное  назначение  в
реальном и защищенном режимах. В  реальном режиме оно может воз-
никнуть после выполнения команды  LIDT, задающей границы таблицы
прерываний   (исходно  она   имеет  границы   00000h  -  003FFh,
совместимые с  8086), если последующая  команда INT nn  содержит
номер прерывания, лежащий вне  границ таблицы прерываний. В стек
заносятся CS и IP команды, вызвавшей прерывание.

     В  защищенном  режиме  Int  08h  возникает  при обнаружении
двойного  исключения, т.  е. если  при выполнении  одной команды
возникают два  прерывания по ошибке.  Это прерывание приводит  к
отключению процессора, т. к. свидетельствует о нарушении защиты.
@pb
@e1     2.1.4.5. Int 09h - Переход сопроцессора через границу@e0
                        сегмента

     Int 09h  (ВП 00024h) возникает при  выполнении команды ESC,
если  ее  операнд  пересекает  границу  сегмента  (например, при
ссылке  на слово  по адресу  0FFFFh). В  стек не заносится адрес
команды,  вызвавшей прерывание;  ее положение  можно извлечь  из
регистров сопроцессора. В защищенном  режиме это прерывание сви-
детельствует о нарушении защиты и приводит к отключению МП.

@e1     2.1.4.6. Int 0Ah - Неверный TSS@e0

     Это прерывание (номер ВП  00028h) генерируется в защищенном
режиме  при  попытке  переключения  задач  с  неверным сегментом
состояния задачи.  В стек заносятся  CS и IP  команды, вызвавшей
прерывание. Int 0Ah допускает рестарт работы.

@e1     2.1.4.7. Int 0Bh - Отсутствие сегмента@e0

     Int 0Bh  (ВП 0002Ch) генерируется  в защищенном режиме  при
обращению  к сегменту  данных или  кодов, который  отсутствует в
памяти. В стек заносятся CS  и IP команды, вызвавшей прерывание.
Int 0Bh допускает рестарт работы.


@e1     2.1.4.8. Int 0Ch - Отсутствие стека@e0

     Int 0Ch  (ВП 00030h) генерируется  в защищенном режиме  при
обращению к сегменту стека, который  отсутствует в памяти, и при
пересечении  границы сегмента  стека. В  стек заносятся  CS и IP
команды, вызвавшей прерывание. Int  0Ch допускает рестарт работы
за  одним исключением:  если переполнение  стека происходит  при
выполнении команд PUSHA или POPA,  то рестарт невозможен. На эту
ситуацию указывает  значение сохраненного в стеке  SP, равное 0,
1, 0FFFEh или 0FFFFh.

@e1     2.1.4.9. Int 0Dh - Нарушение защиты@e0

     В  реальном  режиме  Int  0Dh  (ВП  00034h)  возникает  при
пересечении границы сегмента. Это происходит в двух ситуациях:

     - при обрашении к слову памяти, имеющему смещение 0FFFFh;

     -  при  попытке  выполнить  команду,  пересекающую  границу
сегмента кодов.

     В защищенном  режиме это прерывание  генерируется при любом
нарушении   защиты  (см.   2.1.5.5)  и   приводит  к  отключению
процессора.

     В стек заносятся CS и IP команды, вызвавшей прерывание.
@pb
@e1     2.1.4.10. Int 10h - Ошибка сопроцессора@e0

     Int 10h  (номер ВП 00040h)  генерируется активизацией входа
ERROR, по  которому сопроцессор сообщает МП  о возникшей ошибке.
Это прерывание может возникнуть в процессе выполнения команд ESC
или WAIT.
@pb
@e1     2.1.5. Защищенный режим@e0

     При  включении питания  МП 80286  автоматически переходит в
реальный  режим, в  котором он  полностью совместим  с 8086/8088
(отличия  только в  нескольких дополнительных  командах и  более
высоком производительности).  В этом пункте  описан второй режим
работы МП - защищенный, в  котором 80286 располагает рядом прин-
ципиально новых возможностей. Для перевода МП в защищенный режим
необходимо подготовить в  памяти таблицу дескрипторов прерываний
и загрузить  ее параметры  командой LIDT.  Кроме того необходимо
сформировать  глбальную таблицу  дескрипторов и  задать ее адрес
командой  LGDT.  После  этих  команд  установка  бита  PE  в MSW
(командой  SMSW) переводит  МП в  защищенный режим.  Сразу после
установки  бита PE  необходимо выполнить  команду межсегментного
перехода (JMP FAR), чтобы МП  очистил очередь команд, выбраных в
реальном  режиме. Для  того, чтобы  регистры МП  получили нужные
значения, команда JMP дплжна ссылаться на начальный TSS, исполь-
зуемый  системой.  При  этом  будут  загружены  регистр  задачи,
регистр  LDT, сегментные  и  общие  регистры. Регистр  TR должен
указывать на правильно заполненный TSS.

 Возврат в реальный режим  возможен только сбросом процессора по
входу RESET.

@e1     2.1.5.1. Адресация памяти@e0

     В  защищенном режиме  МП обеспечивает  1 Гбайт виртуального
адресного  пространства  на  каждую  задачу;  виртуальная память
отображается в  физическое адресное пространство  емкостью до 16
Мбайт. Виртуальное адресное пространство может быть больше физи-
ческого,  т. к.  любое обращение  к адресу,  не отображенному  в
физическую   память,  вызывает   прерывание,  которое  допускает
рестарт.

     Защищенный  режим, как  и реальный,  использует для задания
адресов памяти двусловные  указатели вида селектор:смещение. Од-
нако здесь  селектор задает не  старшие 16 бит  адреса памяти, а
индекс  в  определенной  таблице;  из  этой  таблицы извлекается
24-разрядный базовый  адрес сегмента. Физический  адрес формиру-
ется сложением этого базового  адреса со смещением. Все команды,
обращающиеся  к  сегментным  регистрам,  фактически извлекают их
базовые адреса  из соответствующих таблиц, называемых дескрипто-
рами.

     С  каждым сегментным  регистром МП  связан невидимый  прог-
раммно  кэш-регистр, который  автоматически загружается  из дес-
криптора сегмента  всякий раз, когда  в соответствующий сегмент-
ный регистр  загружается селектор. После этого  при обращениях к
сегментным регистрам  информация о сегментах берется  не из дес-
криптора сегмента, а из кэш-регистра.

@e1     2.1.5.2. Дескрипторы@e0

     Дескрипторы - это таблицы,  хранящиеся в памяти и определя-
ющие  использование памяти.  Кроме того,  существуют специальные
типы дескрипторов для передачи  управления и переключения задач.
Доступ к  дескрипторам выполняется специальными  командами, бло-
кируюшими  шину,  что  гарантирует  целостность  дексрипторов  в
многопроцессорных системах. 80286 поддеpживает тpи типа дескpип-
тоpов: дескpиптоpы пpогpаммных сегментов, дескpиптоpы системных
сегментов и дескpиптоpы шлюзов.

     Дескриптор занимает 8  байтов памяти. Дескpиптоpы сегментов
имеют следуюшую структуру:

Смещение Длина         Содержимое            Комментарий
────────────────────────────────────────────────────────────────
               ┌────────┬────────┐
   +0      2   │      Длина      │           Размеp сегмента
               ├────────┼────────┼────────┐
   +2      3   │           База           │  Его базовый адpес
               ├────────┼────────┴────────┘
   +5      1   │ Пpава  │                    Пpава доступа
               ├────────┼────────┐
   +6      2   │     Резеpв      │           Заpезеpвиpовано
               └────────┴────────┘
    8      Размеp дескpиптоpа
────────────────────────────────────────────────────────────────

     Поле  "Длина" содеpжит  pазмеp сегмента  (от 1  байта до 64
Кбайт).   Поле  "База"   содеpжит  24-pазpядный   базовый  адpес
сегмента. Заpезеpвиpованное слово должно  быть нулем для совмес-
тимости с МП 80386.

     Байт  пpав  доступа  в  дескpиптоpе  пpогpаммного  сегмента
состоит из следующих полей:

┌7┬6┬5┬4┬3┬2┬1┬0┐
│P│DPL│S│TYPE │A│ Бит:                                   Маска:
└┬┴─┼─┴┬┴─┴┬┴─┴┬┘
 │  │  │   │   └──> 0:0=доступа к сегменту не было       01h
 │  │  │   │          1=селектор сегмента загружен
 │  │  │   └──────> 1-3: Тип сегмента (см. ниже)         0Eh
 │  │  └──────────> 4: Тип дескриптора: 1=прог. сегмент  10h
 │  │                  0=системный сегмент или шлюз
 │  └─────────────> 5-6: Уровень привилегии дескриптора  60h
 └────────────────> 7: 1=сегмент отображен в физическую  80h
                       память, 0=нет

     Тип сегмента имеет следующие значения:

     0 - сегмент  данных, только  для чтения, расширяется  вверх
         (смещение должно быть меньше длины)
     1 - сегмент данных, для чтения и записи, расширяется  вверх
         (смещение должно быть меньше длины)
     2 - сегмент  данных, только  для чтения,  расширяется  вниз
         (смещение должно быть больше или равно длины)
     3 - сегмент данных, для чтения и записи,  расширяется  вниз
         (смещение должно быть больше или равно длины)
     4 - сегмент кодов, только для выполнения
     5 - сегмент кодов, для выполнения и чтения
     6 - разделяемый сегмент кодов, только для выполнения
     7 - разделяемый сегмент кодов, для  выполнения и  чтения

     Разделяемый  сегмент  кодов  предназначен  для  совместного
использования несколькими  задачами и может  быть выполнен, если
CPL >= DPL и CPL остается неизменным (см. 2.1.5.5).

     Дескрипторы  системных  сегментов  определяют   специальные
сегменты  данных:  локальную   таблицу  дескрипторов (LDT)   или
сегмент  состояния   задачи  (TSS).    Байт  пpав   доступа    в
дескpиптоpе системного сегмента состоит из следующих полей:

┌7┬6┬5┬4┬3┬2┬1┬0┐
│P│DPL│0│  TYPE │ Бит:                                   Маска:
└┬┴─┼─┴─┴─┴─┼─┴─┘
 │  │       └─────> 0-3: Тип дескриптора:                0Fh
 │  │                    1=свободный TSS
 │  │                    2=LDT
 │  │                    3=занятый TSS
 │  └─────────────> 5-6: Уровень привилегии дескриптора  60h
 └────────────────> 7: 1=сегмент отображен в физическую  80h
                       память и значения дескриптора
                       действительны, 0=нет

     Шлюзы используются для управления доступом к точкам входа в
сегмент  кодов.  Дескрипторы   шлюзов  подразделяются  на  шлюзы
вызовов, шлюзы  задач, шлюзы прерываний  и шлюзы ловушек.  Шлюзы
вызовов  используются  для  изменения  уровней привилегий, шлюзы
задач - для переключения задач, шлюзы прерываний и ловушек - для
задания   программ   обработки   прерываний   (шлюзы  прерываний
запрещают прерывания, сбрасывая флаг IF, а шлюзы ловушек - нет).

     Дескpиптоpы шлюзов имеют следуюшую структуру:

Смещение Длина         Содержимое    Комментарий
────────────────────────────────────────────────────────────────
               ┌────────┬────────┐
   +0      2   │    Смещение     │   Смещение до точки входа
               ├────────┼────────┤   в сегменте-цели
   +2      2   │    Селектор     │   Селектор сегмента-цели
               ├────────┼────────┘
   +4      1   │ Счетчик│            Счетчик слов (0 - 31)
               ├────────┤
   +5      1   │ Пpава  │            Пpава доступа к сегменту
               ├────────┼────────┐
   +6      2   │     Резеpв      │   Заpезеpвиpовано
               └────────┴────────┘
    8      Размеp дескpиптоpа
────────────────────────────────────────────────────────────────

     Поле "Селектор" задает  селектор целевого сегмента, который
должен быть  сегментом состояния задачи для  шлюза задачи и сег-
ментом  кодов  для  остальных  шлюзов.  Поле  "Смещение"  задает
смещение  до точки  входа шлюза  относительно целевого сегмента.
"Счетчик" указывает  количество слов, которые  нужно скопировать
из стека  вызывающей процедуры в  стек вызываемой. Это  поле ис-
пользуется  только  в  шлюзах  вызовов.  Заpезеpвиpованное слово
должно быть нулем для совместимости с МП 80386.

  Байт  пpав доступа  в дескpиптоpе  шлюза состоит  из следующих
полей:

┌7┬6┬5┬4┬3┬2┬1┬0┐
│P│DPL│0│  TYPE │ Бит:                                   Маска:
└┬┴─┼─┴─┴─┴─┼─┴─┘
 │  │       └─────> 0-3: Тип дескриптора:                0Fh
 │  │                    4=шлюз вызова
 │  │                    5=шлюз задачи
 │  │                    6=шлюз прерывания
 │  │                    7=шлюз ловушки
 │  └─────────────> 5-6: Уровень привилегии дескриптора  60h
 └────────────────> 7: 1=сегмент отображен в физическую  80h
                       память и значения дескриптора
                       действительны, 0=нет

     Каждый селектор имеет следующую структуру:

 1 1 1 1 1 1
┌5┬4┬3┬2┬1┬0┬9┬8┬7┬6┬5┬4┬3┬─2┬1┬0┐
│        индекс           │TI│RPL│ Бит:                  Маска:
└─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─┴─┴─┴┬─┴─┼─┘
            │              │   └───>0-1: Требуемый уровень   3
            │              │             привилегии селектора
            │              └───────>2: Индикатор таблицы:    4
            │                          0=GDT, 1=LDT
            └──────────────────────>3-15: Индекс элемента FFF8h
                                          в таблице

     Поля  селектора позволяют  задать, в  какой из  двух таблиц
храниться  селектор,  его  порядковый  номер  в  этой  таблице и
уровень привилегии, который требуется селектору.

@e1     2.1.5.3. Таблицы дескрипторов@e0

     В  памяти одновременно  хранятся две  таблицы дескрипторов,
доступных  задаче  в  любой   момент  времени.  Одна  таблица  -
глобальная  таблица дескрипторов  (GDT) -  содержит дескрипторы,
доступные всем  задачам. Вторая, локальная  таблица дескрипторов
(LDT),  содержит  дескрипторы  задачи,  выполняющейся  в  данный
момент. Каждая задача имеет  свою LDT. Селекторы таблиц дескрип-
торов хранятся в регистрах МП LDTR и GDTR.

     GDT может  содержать дескрипторы любых  типов, кроме шлюзов
прерываний и ловушек. LDT может содержать дескрипторы сегментов,
шлюзов задач и шлюзов вызовов.  Сегмент доступен задаче только в
том  случае, если  его дескриптор  имеется в  одной из этих двух
таблиц.

     Каждая  таблица  представляет  собой  вектор, содержащий до
8192  дескрипторов.  Для  задания   адресов  и  размеров  таблиц
используются команды LGDT и LLDT; это привилегированные команды,
которые могут выполняться только на нулевом уровне.

     В защищенном  режиме МП имеет  третью таблицу дескрипторов,
называемую  таблицей дескрипторов  прерываний (IDT), позволяющую
определить до  256 прерываний. Она может  содержать шлюзы задач,
прерываний и ловушек и загружается привилегированной инструкцией
LIDT. Обращения к LIDT происходят при прерываниях работы процес-
сора. Селектор этой таблицы хранится в регистре IDTR.

@e1     2.1.5.4. Уровни привилегий@e0

     МП  80386 имеет  четыре уровня  привилегий; высшим является
уровень  0,  низшим  -  уровень  3.  Типичное назначение уровней
таково:

     уровень 0 - ядро операционной системы;
     уровень 1 - системный сервис и интерфейс;
     уровень 2 - системные утилиты;
     уровень 3 - прикладные программы.

     Проверка привилегий  производится МП при  любом обращении к
сегментам, а именно: при передаче управления (изменение регистра
CS) и доступе к данным (через регистры DS, ES или SS).

     Привилегии задач
     ----------------

     Каждая  задача  всегда  выполняется  на определенном уровне
привилегий. Этот уровень в  каждый момент времени называется те-
кущим  уровнем привилегий  (CPL) и  определяется двумя  младшими
битами  регистра CS.  Уровень задачи  может быть  изменен только
передачей управления через шлюз в другой кодовый сегмент. Задача
начинает выполнение  с CPL, заданном в  селекторе сегмента кодов
TSS, через который она была запущена переключением задач.

     Задача,  выполняющаяся на  уровне 0,  имеет доступ  ко всем
сегментам, определенным в GDT и ее LDT; задача, выполняющаяся на
уровне 3, имеет наиболее ограниченный доступ к данным.

     Привилегии дескрипторов
     -----------------------

     Привилегии дескриптора задаются полем  DPL в его байте прав
доступа. Задача  имеет доступ к дескриптору  только тогда, когда
ее уровень  привилегий меньше или равен  уровню привилегии деск-
риптора.

     Привилегии селектора
     --------------------

     Привилегии селектора задаются в его поле RPL. Они определя-
ют т.  н. эффективный уровень  привилегий задачи (EPL),  который
вычисляется как максимальное из чисел RPL и CPL. Селектор с RPL,
равным  0, не  имеет  дополнительных  ограничений по  своему ис-
пользованию, тогда как RPL, равный 3, разрешает селектору доступ
к сегменту  только на  уровне  привилегий  3, независимо  от CPL
задачи.


     Доступ к данным
     ---------------

     Команды, которые  загружают селекторы в  регистры DS и  ES,
должны ссылаться  на дескрипторы сегментов  данных или сегментов
кодов, доступных  для чтения. CPL задачи  и RPL селектора должны
быть меньше  или равны DPL  дескриптора. В общем  случае, задача
может  иметь  доступ  только  к  тем  сегментам  данных, уровень
привилегий которых  больше, чем CPL и  RPL. Исключением из этого
правила  являются  разделяемые  сегменты  кодов,  доступные  для
чтения: они могут читаться на любом уровне привилегий.

     Если обнаруживается нарушение привилегий или тип дескрипто-
ра неверен (например, дескриптор шлюза или сегмента кодов, недо-
ступного  для чтения),  то генерируется  Int 0Dh.  Если сегмента
нет, то генерируется Int 0Bh.

     Команды, которые  загружают селекторы в  регистр SS, должны
ссылаться на дескрипторы сегментов данных, доступных для записи.
CPL задачи и RPL селектора  должны быть равны DPL дескриптора. В
остальных  случаях  возникает  прерывание  Int  0Dh.  Отсутствие
сегмента генерирует Int 0Ch.

     Передача управления
     -------------------

     Существует  4 типа  межсегментной передачи  управления, при
которой селектор загружается в CS.

     1.  Передача  управления  на   том  же  уровне  привилегий.
Производится командами JMP, CALL, RET и IRET (если флаг NT = 0).
Использует дескриптор сегмента кодов  и таблицу дескрипторов GDT
или LDT.

     2.  Передача  управления  на  тот  же  или  высший  уровень
привилегий. Происходит в двух ситуациях:

     -  по команде  CALL через  шлюз вызова,  использует таблицу
дескрипторов GDT или LDT;

     - в результате прерывания  через шлюз прерывания или ловуш-
ки, использует таблицу IDT, может изменить CPL задачи.

     3.  Передача  управления   на  низший  уровень  привилегий.
Изменяет CPL задачи, происходит в двух ситуациях:

     - по  командам  RET и IRET  (если флаг NT =  0), использует
дескриптор сегмента кодов и таблицу дескрипторов GDT или LDT;

     - по командам CALL и JMP через TSS, использует таблицу GDT.

     4.  Переключение задач. Происходит в трех ситуациях:

     -  по командам  CALL и  JMP через  шлюз задачи,  использует
таблицу дескрипторов GDT или LDT;

     -  по команде  IRET (если   флаг NT  = 1),  использует шлюз
задачи и таблицу IDT;

     -  в результате  прерывания через  шлюз прерывания  задачи,
использует таблицу IDT.

     Передача управления  происходит только в  том случае, когда
команда, загружающая  селектор, на дескриптор  допустимого типа.
Любое нарушение  этого правила (например, JMP  через шлюз вызова
или RET, использующий TSS) генерирует Int 0Dh.

     Правила соблюдения привилегий следующие. Команды JMP и CALL
могут  адресоваться только  к сегменту  кодов с  DPL, равным CPL
задачи, или к разделяемому кодовому  сегменту с DPL, большим или
равным CPL.  RPL селектора, ссылающегося  на дескриптор кодового
сегмента, должен иметь не меньший уровень привилегии, чем CPL.

     Команды RET  и IRET могут  адресоваться только к  сегментам
кодов,  чей  DPL  равен  или  менее  привилегирован,  нежели CPL
задачи. Селектор, загружаемый в CS - это адрес возврата, который
извлекается  из стека.  После возврата  RPL селектора становится
новым CPL задачи. Если CPL  изменился, то старый указатель стека
выталкивается после адреса возврата.

     Если  JMP или  CALL адресуются  к TSS,  то DPL  дескриптора
должен быть  равен или менее привилегирован,  нежели CPL задачи.
Обращение  к правильному  TSS вызывает  переключение задач  (см.
2.1.5.6).  Обращение  к  TSS,  имеющему  более привелигированный
уровень, чем CPL, вызывает Int 0Dh.

     Если команда или прерывание адресуются  к шлюзу, то его DPL
должен быть  равен или менее  привилегирован, чем CPL  задачи; в
противном  случае генерируется  Int 0Dh.  Если селектор целевого
сегмента  в дескрипторе  шлюза  ссылается  на сегмент  кодов, то
дескриптор последнего должен иметь  DPL, равный или более приви-
легированный, чем  CPL задачи, иначе  происходит Int 0Dh.  После
передачи  управления  DPL  сегмента  кодов  становится новым CPL
задачи. Если  селектор шлюза ссылается на  TSS, происходит пере-
ключение задач.

     Если передача управления изменяет CPL задачи, то происходит
автоматическая смена стека задачи. Значения  SS и SP для каждого
уровня привилегий хранятся в сегменте состояния задачи. Для под-
программ с параметрами из старого  стека в новый копируется фик-
сированное количество слов, заданное в дескрипторе шлюза задачи.
При возврате по командам RET или IRET восстанавливается исходный
стек задачи.

@e1     2.1.5.5. Механизмы защиты@e0

     МП 80826  обладает рядом возможностей по  защите от несанк-
ционированного доступа, а именно:

     -  ограниченное использование  сегментов (например,  запрет
записи в  сегменты только для чтения);  при этом задаче доступны
только  те сегменты,  дескрипторы которых  хранятся в  GDT и LDT
задачи;

     - ограниченный  доступ к сегментам  на основе использования
дескрипторов и соглашений о привилегиях;

     -  привилегированными  инструкциями,   которые  могут  быть
исполнены только  при определенных значениях  CPL и поля  IOPL в
регистре флагов.

     При нарушении защиты МП генерирует соответствующее прерыва-
ние. Приведем полный список возможных нарушений защиты.

     Описание ошибки                    Номер прерывания
───────────────────────────────────────────────────────────────
Нет места в таблице дескрипторов                           0Dh
───────────────────────────────────────────────────────────────
Сегмента данных или кодов нет в памяти                     0Bh
───────────────────────────────────────────────────────────────
Сегмента стека нет в памяти                                0Ch
───────────────────────────────────────────────────────────────
Нарушение привилегий                                       0Dh
───────────────────────────────────────────────────────────────
Неверный дескриптор или тип сегмента:                      0Dh
     - загрузка в SS сегмента данных только для чтения;
     - загрузка в DS, ES или SS не программного
сегмента;
     - загрузка в DS, ES или SS сегмента только
для исполнения;
     - загрузка в CS сегмента данных;
     - загрузка в SS сегмента кодов;
───────────────────────────────────────────────────────────────
Запись в сегмент кодов                                     0Dh
───────────────────────────────────────────────────────────────
Запись в сегмент данных только для чтения                  0Dh
───────────────────────────────────────────────────────────────
Чтение сегмента кодов только для исполнения                0Dh
───────────────────────────────────────────────────────────────
Пересечение границы сегмента кодов или данных              0Dh
───────────────────────────────────────────────────────────────
Пересечение границы сегмента стека                         0Ch
───────────────────────────────────────────────────────────────
CPL > 0 при выполнении команд LIDT, LLDT, LTR, LMSW,       0Dh
CLTS, HLT
───────────────────────────────────────────────────────────────
CPL > IOPL при выполнении команд IN, INS, OUT, OUTS,       0Dh
STI, CLI, LOCK
───────────────────────────────────────────────────────────────

     Команды IRET  и POPF не  выполняют некоторые свои  функции,
если CPL слишком велик; точнее:

     - если CPL > IOPL, то бит IF не изменяется;

     - если CPL > 0, то значение IOPL не изменяется;

     При этом никаких прерываний по ошибке не происходит.

@e1     2.1.5.6. Переключение задач@e0

     МП  80286  имеет  встроенный  механизм  переключения задач,
позволяющий сохранить текущее состояние задачи (регистры, адрес-
ное пространство и связь  с предыдущей задачей), загрузить новое
состояние и перейти к выполнению новой задачи. Операция переклю-
чения задач происходит при межсегментных передачах управления по
командам  JMP и  CALL,  которые  ссылаются на  сегмент состояния
задачи (TSS) или на дескриптор шлюза  задачи в GDT или LDT. Пре-
рывание   также  может   вызвать  переключение   задач,  если  в
соответствующем элементе IDT указан дескриптор шлюза задачи.

     Дескриптор TSS указывает на следующую структуру, называемую
сегментом состояния задачи (TSS):

Смещение Длина         Содержимое    Комментарий
────────────────────────────────────────────────────────────────
               ┌────────┬────────┐
   +0      2   │    Указатель    │   Указатель на предыдущий TSS
               ├────────┼────────┤
   +2      2   │  SP для CPL 0   │   Значение SP для CPL = 0
               ├────────┼────────┤
   +4      2   │  SS для CPL 0   │   Значение SS для CPL = 0
               ├────────┼────────┤
   +6      2   │  SP для CPL 1   │   Значение SP для CPL = 1
               ├────────┼────────┤
   +8      2   │  SS для CPL 1   │   Значение SS для CPL = 1
               ├────────┼────────┤
  +0Ah     2   │  SP для CPL 2   │   Значение SP для CPL = 2
               ├────────┼────────┤
  +0Ch     2   │  SS для CPL 2   │   Значение SS для CPL = 2
               ├────────┼────────┤
  +0Eh     2   │       IP        │   Текущее значение IP
               ├────────┼────────┤
  +10h     2   │      Флаги      │   Текущий регистр флагов
               ├────────┼────────┤
  +12h     2   │       AX        │   Текущее значение AX
               ├────────┼────────┤
  +14h     2   │       CX        │   Текущее значение CX
               ├────────┼────────┤
  +16h     2   │       DX        │   Текущее значение DX
               ├────────┼────────┤
  +18h     2   │       BX        │   Текущее значение BX
               ├────────┼────────┤
  +1Ah     2   │       SP        │   Текущее значение SP
               └────────┴────────┘
               ┌────────┬────────┐
  +1Ch     2   │       BP        │   Текущее значение BP
               ├────────┼────────┤
  +1Eh     2   │       SI        │   Текущее значение SI
               ├────────┼────────┤
  +20h     2   │       DI        │   Текущее значение DI
               ├────────┼────────┤
  +22h     2   │   Селектор ES   │   Текущий селектор ES
               ├────────┼────────┤
  +24h     2   │   Селектор CS   │   Текущий селектор CS
               ├────────┼────────┤
  +26h     2   │   Селектор SS   │   Текущий селектор SS
               ├────────┼────────┤
  +28h     2   │   Селектор DS   │   Текущий селектор DS
               ├────────┼────────┤
  +2Ah     2   │   Селектор LDT  │   Селектор LDT задачи
               └────────┴────────┘
   2Ch     Размеp TSS
────────────────────────────────────────────────────────────────

     Размер TSS должен быть не менее 2Ch байтов.

     Каждая  задача  имеет  свой  TSS.  В  80286 имеется регистр
задачи (TR), который в  каждый момент времени содержит селектор,
указывающий на дескриптор TSS текущей задачи.

     Для возврата  из вызванной задачи  в вызвавшую используется
команда IRET. Ее выполнение определяется флагом NT. Если NT = 0,
то  IRET  выталкивает  значения  из  стека, возвращая управление
текущей задаче; если  же NT = 1, то  IRET выполняет переключение
назад к вызвавшей задаче.

     Когда  происходит  переключение   задач,  старый  (если  не
команда JMP)  и новый TSS помечаются  как занятые и в  новый TSS
засылается селектор  старого TSS. Команды CALL  и INT, вызвавшие
переключение задач,  устанавливают, кроме того, флаг  NT в новой
задаче.  Прерывание, не  вызывающее переключения  задач, очищает
этот флаг;  он может быть очищен  или установлен также командами
POPF и IRET.

     Использование  селектора,  указывающего   на  занятый  TSS,
вызывает Int 0Dh.

     Следует  отметить,  что   переключение  задач  не  изменяет
контекст сопроцессора.  Вместо этого МП  устанавливает бит TS  в
MSW, указывая, что текущий  контекст сопроцессора не принадлежит
текущей  задаче. Если  бит TS  установлен и  имеется сопроцессор
(бит MP в MSW равен 1),  то выполнение команд ESC или WAIT гене-
рирует Int 07h.
@pb
                   @e12.2. Система команд@e0

@e1     2.2.1. Команды реального режима@e0

     В реальном  режиме МП 80286  имеет несколько новых  команд,
которые описаны в данном разделе.

@e1     2.2.1.1. Сохранение регистров в стеке@e0

     PUSHA                               Флаги: не изменяются

     Действие: Temp <- SP
               PUSH AX
               PUSH CX
               PUSH DX
               PUSH BX
               PUSH Temp
               PUSH BP
               PUSH SI
               PUSH DI

     Вталкивает  в   стек  все  регистры   общего  назначения  в
указанном  порядке. Следует  отметить, что  в стек  вталкивается
значение SP, которое было до начала выполнения команды. Если со-
держимое  SP перед  выполнением команды  равно 1,  3 или 5, про-
исходит выключение процессора; если  начальное значение SP равно
7, 9, 13 или 15, возникает прерывание Int 0Dh.

@e1     2.2.1.2. Восстановление регистров из стека@e0

     POPA                                Флаги: не изменяются

     Действие: POP  DI
               POP  SI
               POP  BP
               POP  ...       ; SP не выталкивается!
               POP  BX
               POP  DX
               POP  CX
               POP  AX

     Выталкивает из стека регистры общего назначения в указанном
порядке. Следует отметить, что значение SP, сохраненное в стеке,
игнорируется. Эта команда является обратной к PUSHA.

@e1     2.2.1.3. Засылка в стек непосредственных данных@e0

     PUSH  data                          Флаги: не изменяются

     Действие: SP <- SP-2, [SS:SP] <- data

     Вталкивает data в стек, т. е.  уменьшает SP на 2 и засылает
data  по  адресу  SS:SP.  Data  может  быть байтовой или словной
непосредственой  константой. Даже  если data  является байтом, в
стек вталкивается слово. Примеры:

     PUSH 0
     PUSH 1234h

@e1     2.2.1.4. Умножение со знаком на непосредственное данное@e0

     IMUL  reg,src,data                 Флаги: O D I T S Z A P C
     IMUL  reg,data                            * - - - ? ? ? ? *

     Действие: reg <- src * data
           или reg <- reg * data

     Выполняет  умножение целых  чисел со  знаком. Если  команда
имеет три операнда, то в 16-разрядный регистр reg заносится про-
изведение содержимого слова src  (регистра или памяти) на непос-
редственную  константу  data,  которая  может  быть  байтом  или
словом. Если команда имеет два операнда, то в reg заносится про-
изведение reg и  data. Если data - байт,  то перед умножением он
преобразуется в слово расширением знакового разряда.

     Флаги CF и OF устанавливаются, если результата умножения не
помещается  в регистр  reg (в  этом случае  reg содержит младшие
значащие цифры результата). Примеры:

     IMUL  BX,opr,2
     IMUL  DX,AX,5
     IMUL  CX,10h

@e1     2.2.1.5. Проверка границ массива@e0

     BOUND reg,src                      Флаги: Не изменяются

     Действие: if reg < DS:[src] | reg > DS:[src+2]
                 Int 05h

     Эта  команда проверяет,  что индекс  массива, хранящийся  в
16-разрядном регистре  reg, не выходит  за границы массива.  Src
должно указывать на два слова  памяти, содержащие нижнюю и верх-
нюю границы массива. Если индекс  лежит за пределами массива, то
генерируется Int 05h; в противном случае не происходит ничего.

     Сравнение  индекса с  границами производится  как сравнение
целых чисел  зо знаками. Два слова,  содержащие границу массива,
обычно размещаются непосредственно перед массивом, чтобы обеспе-
чить адресацию границ массива через  смещение от его начала, на-
пример:

          DW   0,9                  ; границы массива
array     DB   0,1,2,3,4,5,6,7,8,9  ; сам массив
          .  .  .
          LEA   BX,array            ; BX = адрес массива
          BOUND SI,DS:[BX-4]        ; SI в границах?
          MOV   AX,DS:[BX+SI]       ; если не было Int 5,
                                    ; AX <- array[SI]
@pb
@e1     2.2.1.6. Создание кадра для процедуры@e0

     ENTER data,level                   Флаги: Не изменяются

     Действие: level <- level % 32
               PUSH BP
               frame_ptr <- SP
               if level > 0
                 for i <- 0 to level-1
                    BP <- BP-2; PUSH BP
                 PUSH frame_ptr
               BP <- frame_ptr
               SP <- SP-data

     Создает  кадр стека  для процедуры  блочного языка высокого
уровня. Непосредственное слово данных data задает размер кадра в
байтах. Непосредственный  байт level задает  уровень лексической
вложенности процедуры  (0 - 31)  в исходном тексте  программы на
языке  высокого  уровня.  Он  определяет  количество  указателей
кадра, которые  нужно скопировать в  новый кадр из  предыдущего.
Текущим указателем кадра должен быть регистр BP.

     В наиболее распространенном случае level = 0. Тогда команда
ENTER эквивалентна такой последовательности команд:

     PUSH BP
     MOV  BP,SP
     SUB  SP,data

     Эта команда используется в начале процедур и сопровождается
командой LEAVE перед RET, например:

example:
     ENTER     12,0 ; выделить стек под 12 байтов
                    ; локальных переменных
     .  .  .
     LEAVE          ; освободить стек
     RET            ; и окончить процедуру

@e1     2.2.1.7. Освобождение кадра процедуры@e0

     LEAVE                              Флаги: Не изменяются

     Действие: MOV  SP,BP
               POP  BP

     Эта команда является обратной по отношению к команде ENTER;
она освобождает кадр стека  перед возвратом из процедуры. Пример
см. в 2.2.1.6.
@pb
@e1     2.2.1.8. Сдвиг на непосредственную константу@e0

     ROL/ROR/RCL/RCR dst,data           Флаги: O D I T S Z A P C
                                               ? - - - - - - - *
     SAL/SAR/SHL/SHR dst,data                  ? - - - * * ? * *

     Действие: см. 1.2.3

     Эти  команды, описанные  в п.  1.2.3, получили  в МП  80286
дополнительную возможность:  вы можете указать  в качестве счет-
чика сдвигов  непосредственный байт данных.  При этом количество
выполняемых сдвигов равно data % 32,  т. е. лежит в диапазоне от
0 до 31.

@e1     2.2.1.9. Ввод в строку@e0

     INSB                               Флаги: не изменяются

     Действие: [ES:DI] <- [port DX] (байт)
               if DF = 0
                then DI <- DI+2
                else DI <- DI-2
     INSW                               Флаги: не изменяются

     Действие: [ES:DI] <- [port DX] (слово)
               if DF = 0
                then DI <- DI+2
                else DI <- DI-2

     Вводит байт (INSB) или слово (INSW) из порта DX и сохраняет
его по  адресу ES:DI. После  этого модифицирует DI,  как описано
выше. В сочетании с префиксом  REP позволяет ввести блок даных в
память.

@e1     2.2.1.10. Вывод из строки@e0

     OUTSB                              Флаги: не изменяются

     Действие: [port DX] <- [DS:SI] (байт)
               if DF = 0
                then SI <- SI+1
                else SI <- SI-1
     OUTSW                              Флаги: не изменяются

     Действие: [port DX] <- [DS:SI] (слово)
               if DF = 0
                then SI <- SI+2
                else SI <- SI-2

     Выводит байт  (OUTSB) или слово  (OUTSW) из адреса  DS:SI в
порт  DX.  После  этого  модифицирует  SI,  как  описано выше. С
префиксом REP используется для вывода блоков.
@pb
@e1     2.2.2. Команды защищенного режима@e0

@e1     2.2.2.1. Корректировка поля RPL селектора@e0

     ARPL  dst,src                      Флаги: O D I T S Z A P C
                                               - - - - - * - - -
     Действие: if dst & 03h < src & 03h
                 ZF <- 1; dst & 03h <- src & 03h
               else
                 ZF <- 0

     Эта  команда имеет  два операнда.  Dst должен  быть 16-раз-
рядным регистром  или словом памяти, src  - 16-разрядным регист-
ром. Если  поле RPL (младшие  2 бита) dst  меньше, чем поле  RPL
src, то поле  RPL src копируется в dst  и флаг ZF устанавливает-
ся; в противном случае флаг ZF сбрасывается.

     Эта команда  используется в системных  программах для того,
чтобы  гарантировать,  что  селектор  вызываемой подпрограммы не
требует  высшего  уровня   привилегий,  чем  уровень  вызывающей
программы. Обычно src -  это регистр, содержащий значение селек-
тора CS вызывающей программы.

     Попытка  выполнить эту  команду в  реальном режиме вызывает
прерывание Int 06h. Примеры:

     ARPL CX,DX
     ARPL sel,AX

@e1     2.2.2.2. Загрузка прав доступа@e0

     LAR   dst,src                      Флаги: O D I T S Z A P C
                                               - - - - - * - - -
     Действие: dst <- ar[src] & FF00h

     Эта  команда имеет  два операнда.  Dst должен  быть 16-раз-
рядным  регистром,  src  -  16-разрядным  регистром  или  словом
памяти,  содержащим   селектор.  Если  дескриптор,   на  который
указывает    src,   видим    на   текущем    уровне   привилегий
(модифицированным RPL селектора) и  имеет допустимый тип, то его
байт прав  доступа загружается в старщий  байт dst, младший байт
dst  обнуляется и  флаг ZF  устанавливается; в  противном случае
флаг ZF сбрасывается и dst не изменяется.

     Попытка  выполнить эту  команду в  реальном режиме вызывает
прерывание Int 06h. Примеры:

     LAR  AX,sel
     LAR  BX,CX
@pb
@e1     2.2.2.3. Загрузка длины сегмента@e0

     LSL   dst,src                      Флаги: O D I T S Z A P C
                                               - - - - - * - - -
     Действие: dst <- sl[src]

     Эта  команда имеет  два операнда.  Dst должен  быть 16-раз-
рядным  регистром,  src  -  16-разрядным  регистром  или  словом
памяти,  содержащим   селектор.  Если  дескриптор,   на  который
указывает    src,   видим    на   текущем    уровне   привилегий
(модифицированным RPL селектора) и  имеет допустимый тип, то его
длина   сегмента  в   байтах  загружается   в  dst   и  флаг  ZF
устанавливается; в  противном случае флаг ZF  сбрасывается и dst
не  изменяется.  Команда  LSL  применима  только  к дескрипторам
программных сегментов.

     Попытка  выполнить эту  команду в  реальном режиме вызывает
прерывание Int 06h. Примеры:

     LSL  AX,sel
     LSL  BX,SI

@e1     2.2.2.4. Загрузка MSW@e0

     LMSW  src                          Флаги: Не изменяются

     Действие: MSW <- src

     Загружает src  в слово состояния  машины (MSW); src  должно
быть словом  памяти или 16-разрядным регистром.  Эта команда ис-
пользуется для перевода МП в защищенный режим (подробности см. в
пп.  2.1.3  и  2.1.5)  и  не  должна  применяться  в  прикладных
программах. Примеры:

     LMSW BP
     LMSW ES:mem

@e1     2.2.2.5. Чтение MSW@e0

     SMSW  dst                          Флаги: Не изменяются

     Действие: dst <- MSW

     Загружает слово  состояния машины (MSW)  в dst; dst  должно
быть словом памяти или 16-разрядным регистром. Примеры:

     SMSW AX
     SMSW ES:mem

@e1     2.2.2.6. Загрузка GDTR@e0

     LGDT  src                          Флаги: Не изменяются

     Действие: GDTR <- src

     Загружает таблицу, адресованную src,  в поля базы и размера
глобальной  таблицы   дескрипторов;  src  должно   указывать  на
следующую таблицу в памяти:

Смещение Длина         Содержимое            Комментарий
────────────────────────────────────────────────────────────────
               ┌────────┬────────┐
   +0      2   │      Длина      │           Размеp сегмента
               ├────────┼────────┼────────┐
   +2      3   │           База           │  Его базовый адpес
               ├────────┼────────┴────────┘
   +5      1   │ Резерв │                    Должен быть нулем
               └────────┘
    6      Длина таблицы

     Эта команда используется только  операционной системой и не
должна применяться в прикладных  программах. Команды LGDT и LIDT
- это единственные  команды, которые загружают  физический адрес
(а не смещение от начала  сегмента) в защищенном режиме. Попытка
выполнить  эту привилегированную  команду на  уровне привилегий,
отличном от нуля, вызывает прерывание Int 0Dh. Пример:

     LGDT table

@e1     2.2.2.7. Чтение GDTR@e0

     SGDT  dst                          Флаги: Не изменяются

     Действие: dst <- GDTR

     Загружает   поля   базы   и   размера   глобальной  таблицы
дескрипторов в dst; dst должно указывать на 6-байтовую таблицу в
памяти, которая заполняется следующим образом:

Смещение Длина         Содержимое            Комментарий
────────────────────────────────────────────────────────────────
               ┌────────┬────────┐
   +0      2   │      Длина      │           Размеp сегмента
               ├────────┼────────┼────────┐
   +2      3   │           База           │  Его базовый адpес
               ├────────┼────────┴────────┘
   +5      1   │ FFFFh  │
               └────────┘
    6      Длина таблицы

     Эта команда используется только  операционной системой и не
должна применяться в прикладных программах. Пример:

     SGDT table

     Отметин, что  МП 80386 заполняет последний  байт таблицы не
единицами, а нулями; поэтому для мобильности программ содержимое
последнего  байта следует  считать неопределенным  и не  исполь-
зовать его.

@e1     2.2.2.8. Загрузка IDTR@e0

     LIDT  src                          Флаги: Не изменяются

     Действие: IDTR <- src

     Загружает таблицу, адресованную src,  в поля базы и размера
таблицы  дескрипторов   прерываний;  src  должно   указывать  на
следующую таблицу в памяти:

Смещение Длина         Содержимое            Комментарий
────────────────────────────────────────────────────────────────
               ┌────────┬────────┐
   +0      2   │      Длина      │           Размеp сегмента
               ├────────┼────────┼────────┐
   +2      3   │           База           │  Его базовый адpес
               ├────────┼────────┴────────┘
   +5      1   │ Резерв │                    Должен быть нулем
               └────────┘
    6      Длина таблицы

     Эта команда используется только  операционной системой и не
должна применяться в прикладных  программах. Команды LGDT и LIDT
- это единственные  команды, которые загружают  физический адрес
(а не смещение от начала  сегмента) в защищенном режиме. Попытка
выполнить  эту привилегированную  команду на  уровне привилегий,
отличном от нуля, вызывает прерывание Int 0Dh. Пример:

     LIDT table

@e1     2.2.2.9. Чтение IDTR@e0

     SIDT  dst                          Флаги: Не изменяются

     Действие: dst <- IDTR

     Загружает   поля  базы   и  размера   таблицы  дескрипторов
прерываний в  dst; dst должно указывать  на 6-байтовую таблицу в
памяти, которая заполняется следующим образом:

Смещение Длина         Содержимое            Комментарий
────────────────────────────────────────────────────────────────
               ┌────────┬────────┐
   +0      2   │      Длина      │           Размеp сегмента
               ├────────┼────────┼────────┐
   +2      3   │           База           │  Его базовый адpес
               ├────────┼────────┴────────┘
   +5      1   │ FFFFh  │
               └────────┘
    6      Длина таблицы

     Эта команда используется только  операционной системой и не
должна применяться в прикладных программах. Пример:

     SIDT table

     Отметин, что  МП 80386 заполняет последний  байт таблицы не
единицами, а нулями; поэтому для мобильности программ содержимое
последнего  байта следует  считать неопределенным  и не  исполь-
зовать его.

@e1     2.2.2.10. Загрузка LDTR@e0

     LLDT  src                          Флаги: Не изменяются

     Действие: LDTR <- src

     Загружает  содержимое  src   в  регистр  локальной  таблицы
дескрипторов;  src должно  быть словом  памяти или  16-разрядным
регистром  и  содержать  селектор,   указывающий  в  GDT.  Соот-
ветствующий   элемент   GDT   должен   быть  локальной  таблицей
дескрипторов.  Сегментные  регистры  дескриптора  и  поле  LDT в
сегменте состояния задачи не изменяются.

     Эта команда используется только  операционной системой и не
должна  применяться в  прикладных программах.  Попытка выполнить
эту привилегированную команду на  уровне привилегий, отличном от
нуля, вызывает прерывание Int 0Dh. Попытка выполнить эту команду
в реальном режиме вызывает прерывание Int 06h. Примеры:

     LLDT SI
     LLDT sel

@e1     2.2.2.11. Чтение LDTR@e0

     SLDT  dst                          Флаги: Не изменяются

     Действие: dst <- LDTR

     Загружает   регистр  локальной   таблицы
дескрипторов в dst; dst должно быть словом памяти или 16-разряд-
ным регистром и после  выполнения команды содержит селектор LDT,
указывающий в GDT.

     Эта команда используется только  операционной системой и не
должна  применяться в  прикладных программах.  Попытка выполнить
эту  команду  в  реальном  режиме  вызывает  прерывание Int 06h.
Примеры:

     SLDT AX
     SLDT sel

@e1     2.2.2.12. Загрузка TR@e0

     LTR   src                          Флаги: Не изменяются

     Действие: TR <- src

     Загружает содержимое  src в регистр  задачи TR; src  должно
быть словом  памяти или 16-разрядным  регистром. TSS загруженной
задачи помечается как занятый, переключение задач не происходит.

     Эта команда используется только  операционной системой и не
должна  применяться в  прикладных программах.  Попытка выполнить
эту привилегированную команду на  уровне привилегий, отличном от
нуля, вызывает прерывание Int 0Dh. Попытка выполнить эту команду
в реальном режиме вызывает прерывание Int 06h. Примеры:

     LTR  CX
     LTR  mem

@e1     2.2.2.13. Чтение TR@e0

     STR   dst                          Флаги: Не изменяются

     Действие: dst <- TR

     Загружает регистр  задачи TR в dst;  dst должно быть словом
памяти или 16-разрядным регистром.

     Эта команда используется только  операционной системой и не
должна  применяться в  прикладных программах.  Попытка выполнить
эту  команду  в  реальном  режиме  вызывает  прерывание Int 06h.
Примеры:

     STR  CX
     STR  mem

@e1     2.2.2.14. Проверка допустимости чтения сегмента@e0

     VERR  src                          Флаги: O D I T S Z A P C
                                               - - - - - * - - -
     Действие: if сегмент src видим и доступен для чтения
                  ZF <- 1
               else
                  ZF <- 0

     Операнд  этой команды  src  должен  быть словом  памяти или
16-разрядным  регистром, содержащим  селектор сегмента.  Команда
проверяет, достижим  ли сегмент на  текущем уровне привилегий  и
разрешено ли  его чтение; если  да, то флаг  ZF устанавливается,
иначе  сбрасывается. Для  установки флага  ZF должны выполняться
следующие условия:

     - селектор должен указывать в GDT или LDT;
     - селектор  должен указывать на  дескриптор сегмента данных
или кодов;
     - чтение сегмента должно быть разрешено;
     - если это  разделяемый сегмент  кодов,  то  приемлем любой
DPL;  в противном  случае DPL  должен быть  больше или равен как
CPL, так и RPL селектора.

     Попытка  выполнить эту  команду в  реальном режиме вызывает
прерывание Int 06h. Примеры:

     VERR CX
     VERR sel

@e1     2.2.2.15. Проверка допустимости записи в сегмент@e0

     VERW  src                          Флаги: O D I T S Z A P C
                                               - - - - - * - - -
     Действие: if сегмент src видим и доступен для записи
                  ZF <- 1
               else
                  ZF <- 0

     Операнд  этой команды  src  должен  быть словом  памяти или
16-разрядным  регистром, содержащим  селектор сегмента.  Команда
проверяет, достижим  ли сегмент на  текущем уровне привилегий  и
разрешена ли запись в него; если  да, то флаг  ZF устанавливается,
иначе  сбрасывается. Для  установки флага  ZF должны выполняться
следующие условия:

     - селектор должен указывать в GDT или LDT;
     - селектор  должен указывать на  дескриптор сегмента данных
или кодов;
     - запись в сегмент должно быть разрешено;
     - DPL  должен  быть больше  или равен  как CPL,  так и  RPL
селектора.

     Попытка  выполнить эту  команду в  реальном режиме вызывает
прерывание Int 06h. Примеры:

     VERR CX
     VERR sel

@e1     2.2.2.16. Сброс флага TS@e0

     CLTS                               Флаги: Не изменяются

     Действие: TS в MSW <- 0

     Сбрасывает флаг  переключения задач в MSW.  Этот флаг уста-
навливается МП всякий раз,  когда происходит переключение задач,
и используется в следующих ситуациях:

     - если TS установлен, то команда ESC вызывает прерывание;
     - если флаги MP и  TS установлены, то команда WAIT вызывает
прерывание.

     Дело в  том, что если  после начала выполнения  команды ESC
произошло переключение задач,  возникает необходимость сохранить
контекст  сопроцессора  до  выполнения  следующей  команды  ESC.
Обработчик  прерывания Int  07h сохраняет  контекст и сбрасывает
флаг TS.

     Эта команда используется только  операционной системой и не
должна  применяться в  прикладных программах.  Попытка выполнить
эту привилегированную команду на  уровне привилегий, отличном от
нуля, вызывает прерывание Int 0Dh.
@pb
@e1     2.2.3. Выполнение команд в защищенном режиме@e0

     Ряд  команд, описанных  в п.  1.2, в  защищенном режиме  МП
80286  выполняются  иначе,  нежели  в  реальном  режиме.  В этом
разделе описаны особенности выполнения  этих команд в защищенном
режиме.

@e1     2.2.3.1. Вызов подпрограмм и переключение задач@e0

     В защищенном режиме команды  CALL и RET реализованы гораздо
более сложным образом,  чем в реальном режиме. При  этом вызов и
возврат в  пределах сегмента выполняются так  же, как в реальном
режиме; отличия имеются только для длинных (межсегментных) пере-
дач  управления.  Общая  характеристика  выполнения  этих команд
дана в  2.1.5.4 - 2.1.5.6; здесь  приводится описание реализации
команд CALL и RET на  псевдоязыке; для упрощения опущена генера-
ция прерываний  при возникновении ошибок (нарушение  защиты и т.
п. - об этом см. 2.1.5.5). Обpатите внимание, что для  обpатного
пеpеключения задач используется не RET, а IRET.

     CALL FAR:
     ---------

Выбрать новый селектор CS;
Выбрать  байт  прав  доступа  из  соответствущего  дескриптора в
таблице дескрипторов;
В зависимости от типа дескриптора перейти на одну из меток:
go to СЕГМЕНТ_КОДОВ;
go to ШЛЮЗ_ВЫЗОВА;
go to ШЛЮЗ_ЗАДАЧИ;
go to СЕГМЕНТ_СОСТОЯНИЯ_ЗАДАЧИ;

СЕГМЕНТ_КОДОВ:
     Загрузить селектор нового сегмента в CS;
     if неразделяемый сегмент кодов
          Загрузить RPL селектора CS в CPL;
     Загрузить новое смещение в IP;

ШЛЮЗ_ВЫЗОВА:
     Выбрать селектор сегмента кодов из дескриптора шлюза;
     if неразделяемый сегмент кодов и DPL < CPL
          go to БОЛЕЕ_ПРИВИЛЕГИРОВАННЫЙ;
     else
          go to БЕЗ_ИЗМЕНЕНИЯ_ПРИВИЛЕГИЙ;

БОЛЕЕ_ПРИВИЛЕГИРОВАННЫЙ:
     Выбрать новый  селектор SS для нового  уровня привилегий из
TSS;
     Загрузить новые значения SS:SP из TSS;
     Загрузить новые значения CS:IP из шлюза;
     Втолкнуть длинный указатель на старый стек в новый;
     Выбрать счетчик слов n из шлюза вызова;
     Скопировать n слов из старого стека в новый;
     Втолкнуть длинный адрес возврата в новый стек;
     Загрузить CPL в DPL сегмента стека;
     Загрузить RPL селектора CS в CPL;

БЕЗ_ИЗМЕНЕНИЯ_ПРИВИЛЕГИЙ:
     Загрузить новые значения CS:IP из шлюза;
     Втолкнуть длинный адрес возврата в стек;
     Загрузить RPL селектора CS в CPL;

ШЛЮЗ_ЗАДАЧИ:
     Выбрать селектор TSS из дескриптора шлюза;
     Произвести  переключение задач  (2.1.5.6) на  основе TSS  и
установить флаг NT;

СЕГМЕНТ_СОСТОЯНИЯ_ЗАДАЧИ:
     Произвести  переключение задач  на основе  TSS и установить
флаг NT;

     RET FAR [nnn]:
     --------------

Выбрать селектор возврата (т. е. селектор CS из стека);
if RPL селектора возврата = CPL
     go to БЕЗ_ИЗМЕНЕНИЯ_ПРИВИЛЕГИЙ;
else
     go to МЕНЕЕ_ПРИВИЛЕГИРОВАННЫЙ;

БЕЗ_ИЗМЕНЕНИЯ_ПРИВИЛЕГИЙ:
     Загрузить CS:IP из стека;
     Увеличить SP на 4 и  на непосредственное смещение nnn, если
оно есть в команде;

МЕНЕЕ_ПРИВИЛЕГИРОВАННЫЙ:
     Загрузить CPL в RPL селектора возврата;
     Загрузить CS:IP из стека;
     Загрузить RPL селектора CS в CPL;
     Увеличить SP на 4 и  на непосредственное смещение nnn, если
оно есть в команде;
     Загрузить SS:SP из стека;

@e1     2.2.3.2. Обpаботка пpеpываний@e0

     Команды INT и IRET в защищенном pежиме имеют более  сложную
логику,  чем  в  pеальном  pежиме.  Здесь  пpиведено описание их
действий на псевдоязыке (пpеpывания по ошибкам опущены).

     INT nn:
     -------

Выбpать селектоp пpеpывания nn из таблицы IDT;
if это шлюз пpеpывания или ловушки
     go to ШЛЮЗ_ПРЕРЫВАНИЯ_ИЛИ_ЛОВУШКИ;
else
     go to ШЛЮЗ_ЗАДАЧИ;

ШЛЮЗ_ПРЕРЫВАНИЯ_ИЛИ_ЛОВУШКИ:
     Выбpать селектоp CS и его дескpиптоp из дескpиптоpа шлюза;
     if это неpазделяемый сегмент кодов и DPL < CPL
          go to БОЛЕЕ_ПРИВИЛЕГИРОВАННЫЙ;
     else
          go to БЕЗ_ИЗМЕНЕНИЯ_ПРИВИЛЕГИЙ;

БОЛЕЕ_ПРИВИЛЕГИРОВАННЫЙ:
     Выбрать новый  селектор SS для нового  уровня привилегий из
TSS;
     Загрузить новые значения SS:SP из TSS;
     Загрузить новые значения CS:IP из шлюза;
     Втолкнуть длинный указатель на старый стек в новый;
     Втолкнуть pегистp флагов в новый стек;
     Втолкнуть длинный адрес возврата в новый стек;
     Загрузить CPL в DPL сегмента кода;
     Загрузить RPL селектора CS в CPL;
     if шлюз пpеpывания
          IF <- 0;
     TF <- 0; NT <- 0;

БЕЗ_ИЗМЕНЕНИЯ_ПРИВИЛЕГИЙ:
     Втолкнуть pегистp флагов в стек;
     Втолкнуть длинный адрес возврата в стек;
     Загрузить новые значения CS:IP из шлюза;
     Загрузить RPL селектора CS в CPL;
     Втолкнуть код ошибки в стек (если он есть);
     if шлюз пpеpывания
          IF <- 0;
     TF <- 0; NT <- 0;

ШЛЮЗ_ЗАДАЧИ:
     Выбрать селектор TSS из дескриптора шлюза;
     Произвести  переключение задач  (2.1.5.6) на  основе TSS  и
установить флаг NT;

     IRET:
     -----

if NT = 1
     go to ВОЗВРАТ_ИЗ_ЗАДАЧИ;
else
     go to ВОЗВРАТ_ИЗ_ПРЕРЫВАНИЯ;

ВОЗВРАТ_ИЗ_ЗАДАЧИ:
     Произвести переключение задач (2.1.5.6) на основе указателя
обратной связи в TSS и сбросить флаг NT;
     Отметить завершившуюся задачу как незанятую;

ВОЗВРАТ_ИЗ_ПРЕРЫВАНИЯ:
Выбрать селектор возврата (т. е. селектор CS из стека);
if RPL селектора возврата = CPL
     go to БЕЗ_ИЗМЕНЕНИЯ_ПРИВИЛЕГИЙ;
else
     go to МЕНЕЕ_ПРИВИЛЕГИРОВАННЫЙ;

БЕЗ_ИЗМЕНЕНИЯ_ПРИВИЛЕГИЙ:
     Загрузить CS:IP из стека;
     Загрузить регистр флагов из стека;
     Увеличить SP на 6;

МЕНЕЕ_ПРИВИЛЕГИРОВАННЫЙ:
     Загрузить CS:IP из стека;
     Загрузить регистр флагов из стека;
     Загрузить SS:SP из стека;
     Загрузить CPL в RPL селектора возврата;

     Примечание: При возврате  из прерывания выталкивание флагов
из стека изменяет IOPL только в случае, когда CPL = 0.

@e1     2.2.3.3. Управление флагами@e0

     В  защищенном  режиме  команды  CLI,  STI  и POPF имеют ряд
особенностей, обусловленных требованиями защиты, а именно:

     - команды CLI  и STI вызывают прерывание Int  0Dh, если CPL
больше, чем поле IOPL в регистре флагов;

     - команда POPF, выталкивая флаги из стека, изменяет текущее
значение  IOPL только  в том  случае, когда  она выполняется  на
уровне 0; флаг IF изменяется только если CPL <= IOPL.

@e1     2.2.3.4. Ввод-вывод@e0

     Команды  IN,  OUT,  INS  и  OUTS  могут  быть  выполнены  в
защищенном режиме, если CPL <=  IOPL. В противном случае генери-
руется Int 0Dh.

@e1     2.2.3.5. Управление процессором@e0

     Команда  HLT является  привилегированной: ее  выполнение на
уровне, отличном от нуля, генерирует Int 0Dh.

@e1     2.2.3.6. Взаимодействие с сопроцессором@e0

     Команды взаимодействия  с сопроцессором имеют  в защищенном
режиме следующие особенности:

     - команда ESC генерирует Int 07h, если установлены флаги TS
или  EM в  MSW; некоторые  команды ESC  генерируют Int 10h, если
активен вход ERROR (числовая ошибка в сопроцессоре);

     - команда WAIT генерирует Int  07h, если установлен флаг TS
в MSW, и Int 10h, если активен вход ERROR.
