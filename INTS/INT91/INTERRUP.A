Interrupt List		Release 91.1		Last change 1/5/91
This compilation is Copyright (c) 1989, 1990, 1991 Ralf Brown
---------------------------------------------
Please redistribute the following files unmodified as a group, in an archive
named INTER191 (preferably the original authenticated PKZIP archive):
	INTERRUP.1ST	the read-me file, containing credits, availability info
	INTERRUP.A	INT 00 through INT 1F \
	INTERRUP.B	INT 20 through INT 27  \ total 448 pages at 60 lines
	INTERRUP.C	INT 28 through INT 5F  / per page, 483 with INTPRINT -p
	INTERRUP.D	INT 60 through INT FF /
	INTERRUP.PRI	a brief introduction to interrupts
	INTPRINT.COM	a simple formatter that also generates the list summary
	INTPRINT.DOC	instructions for INTPRINT
	INTPRINT.C	source code for INTPRINT
	MEMORY.LST	format of the BIOS data area
	INT2QH.*	program for converting list to QuickHelp database
---------------------------------------------
If you notice any mistakes or omissions, please let me know!  It is only with
YOUR help that the list can continue to grow at the current rate.  Please send
all changes to me rather than distributing a modified version of the list.

Please read the file INTERRUP.1ST before asking me any questions.  You may find
that they have already been addressed.

	 Ralf Brown

ARPA: ralf@cs.cmu.edu
UUCP: {ucbvax,harvard}!cs.cmu.edu!ralf
BIT:  ralf%cs.cmu.edu@cmuccvma
FIDO: Ralf Brown 1:129/3.1
	or post a message to the DR_DEBUG echo
CIS:  >INTERNET:ralf@cs.cmu.edu 

I reply to all e-mail submissions and inquiries, but some of my replies bounce
because of bad return paths.  If you don't get a response from me within a
reasonable period of time, send it again with a better return path (starting at
harvard or ucbvax for UUCP, from the ARPA Internet for others).
---------------------------------------------
See INTERRUP.1ST for the key to system abbreviations and a list of the
trademarks mentioned here.
---------------------------------------------
DISCLAIMER:  I verify the information contained in this list to the best of my
ability, but I cannot be held responsible for any problems caused by use or
misuse of the information, especially for those functions not officially 
documented.  If it is marked "internal", you should check it carefully to make
sure it works the same way in your version of the software (and please let me
know whether or not it works the same way).  Information marked with "???" is
known to be incomplete or guesswork.
---------------------------------------------
The use of -> instead of = signifies that the indicated register or register
pair contains a pointer to the specified item, rather than the item itself
----------00---------------------------------
INT 00 - internal hardware - DIVIDE ERROR
   Automatically called at end of DIV or IDIV operation that results in error
   or overflow.   Normally set by DOS to display an error message and abort
   the program.
Notes:	on an 8086/8088, the return address points to the following instruction
	on an 80286+, the return address points to the divide instruction
SeeAlso: INT 04
----------01---------------------------------
INT 01 - internal hardware - SINGLE-STEP
   generated at end of each machine instruction if TF bit in FLAGS is set
Notes:	this is what makes the T command of DEBUG work for single-stepping
	on 8086 and 8088 CPUs, this interrupt is not generated after a MOV to
	  segment register or POP of segment register unless you have a very
	  early 8088 with a microcode bug
	on 286 and up CPUs, this interrupt is not generated after a MOV to SS
	  or POP SS
SeeAlso: INT 03
----------01---------------------------------
INT 01 - 80386+ internal hardware - DEBUGGING EXCEPTIONS
   Instruction address breakpoint fault - will return to execute instruction
   Data address breakpoint trap - will return to following instruction
   General detect fault, debug registers in use
   Task-switch breakpoint trap
----------02---------------------------------
INT 02 - external hardware - NMI (NON-MASKABLE INTERRUPT)
   Generated by NMI signal in hardware.  This signal has various uses:

   Breakout switch on hardware debuggers
   Parity error: all except Jr and CONV
   Coprocessor interrupt: all except Jr and CONV
   Keyboard interrupt: Jr, CONV
   I/O channel check: CONV, PS50+
   Disk-controller power-on request: CONV
   System suspend: CONV
   Real-time clock: CONV
   System watch-dog timer, time-out interrupt: PS50+
   DMA timer time-out interrupt: PS50+
----------03---------------------------------
INT 03 - ONE-BYTE INTERRUPT
   generated by opcode CCh
Notes:	generally used to set breakpoints for debuggers
	also used by Turbo Pascal versions 1,2,3 when {$U+} specified
SeeAlso: INT 01
----------04---------------------------------
INT 04 - internal hardware - OVERFLOW
   Generated by INTO instruction if OF flag is set.  If flag is not set, INTO
   is effectively a NOP.
Note:	used to trap any arithmetic errors before the erroneous results
	  propagate further through the computation
SeeAlso: INT 00
----------05---------------------------------
INT 05 - PRINT-SCREEN KEY
   automatically called by keyboard scanner when print-screen key is pressed
Notes:	normally executes routine to print the screen, but may call any routine
	  that can safely be executed from inside the keyboard scanner
	status and result byte for default handler is at address 0050:0000
	  00h not active
	  01h PrtSc in progress
	  FFh last PrtSc encountered error
SeeAlso: INT 10/AH=12h/BL=20h
----------05---------------------------------
INT 05 - internal hardware - BOUND CHECK FAILED (80186+)
   Generated by BOUND instruction when the value to be tested is less than the
   indicated lower bound or greater than the indicated upper bound.  Returning
   from this interrupt re-executes the failing BOUND instruction.
----------06---------------------------------
INT 06 - internal hardware - UNDEFINED OPCODE (80286+)
----------07---------------------------------
INT 07 - internal hardware - NO MATH UNIT AVAILABLE (80286+)
   automatically called if a coprocessor instruction is encountered when no
   coprocessor is installed
Note:	can be used to emulate a numeric coprocessor in software
SeeAlso: INT 09"MATH UNIT PROTECTION"
----------08---------------------------------
INT 08 - IRQ0 - TIMER INTERRUPT
   Generated 18.2 times per second, this interrupt is used to keep the
   time-of-day clock updated.  Programs which need to be invoked regularly
   should use INT 1C unless they need to reprogram the timer while still
   keeping the time-of-day clock running at the proper rate.
SeeAlso: INT 1C, INT 50
----------08---------------------------------
INT 08 - internal hardware - DOUBLE FAULT (80286+ protected mode)
   Called when multiple exceptions occur on one instruction, or an exception
   occurs in an exception handler.  If an exception occurs in the double fault
   handler, the CPU goes into SHUTDOWN mode (which circuitry in the PC/AT
   converts to a reset).
----------09---------------------------------
INT 09 - IRQ1 - KEYBOARD INTERRUPT
   Generated when data is received from the keyboard.  This is normally a scan
   code, but may also be an ACK or NAK of a command on AT-class keyboards.
   If the BIOS supports an enhanced (101/102-key) keyboard, it calls
     INT 15/AH=4Fh after reading the scan code from the keyboard and before
     further processing.
   The interrupt handler performs the following actions for certain special
     keystrokes:
	Ctrl-Break	invoke INT 1B, set flag at 0040h:0071h
	SysRq		invoke INT 15/AH=85h
	Ctrl-Numlock	place system in a tight wait loop
	Ctrl-Alt-Del	jump to BIOS startup code (either F000h:FFFFh or the
			  destination of the jump at that address)
SeeAlso: INT 15/AH=4Fh, INT 15/AH=85h, INT 16, INT 1B, INT 51
----------09---------------------------------
INT 09 - internal hardware - MATH UNIT PROTECTION FAULT (80286,80386 protected)
SeeAlso: INT 07"NO MATH UNIT"
----------09---------------------------------
INT 09 - internal hardware - RESERVED BY Intel (80486 protected mode)
Note:	this exception has been moved to INT 0D
SeeAlso: INT 09"MATH", INT 0D
----------0A---------------------------------
INT 0A - IRQ2 - EGA VERTICAL RETRACE
Notes:	the TOPS and PCnet adapters use this interrupt request line by default
	DOS 3.2 revectors IRQ2 to a stack-switching routine
	on ATs and above, the physical data line for IRQ2 is labeled IRQ9 and
	  connects to the slave 8259.  The BIOS redirects the interrupt for
	  IRQ9 back here.
	under DESQview, only the INT 15h vector and BASIC segment address (the
	  word at 0000h:0510h) may be assumed to be valid for the handler's
	  process
SeeAlso: INT 52, INT 71
----------0A---------------------------------
INT 0A - IRQ2 - Tandy 1000 HARD DISK
SeeAlso: INT 52
----------0A---------------------------------
INT 0A - IRQ2 - ROLAND MPU MIDI INTERFACE
Note:	newer Roland cards and MIDI interfaces by other manufacturers use
	  a jumper-selectable IRQ, but software and hardware generally defaults
	  to IRQ2
SeeAlso: INT 52
----------0A---------------------------------
INT 0A - internal hardware - INVALID TASK STATE SEGMENT (80286+ protected-mode)
----------0B---------------------------------
INT 0B - IRQ3 - COM2 INTERRUPT
Notes:	the TOPS and PCnet adapters use this interrupt request line as an
	  alternate
	on PS/2's, COM2 through COM8 share this interrupt on many PC's, COM4
	  shares this interrupt
SeeAlso: INT 0C, INT 53
----------0B---------------------------------
INT 0B - internal hardware - NOT PRESENT (80286+ protected-mode)
   Generated when loading a segment register if the segment descriptor
   indicates that the segment is not currently in memory.  May be used to
   implement virtual memory.
SeeAlso: INT 0E"hardware"
----------0C---------------------------------
INT 0C - IRQ4 - COM1 INTERRUPT
Note:	on many PC's, COM3 shares this interrupt
SeeAlso: INT 0B, INT 54
----------0C---------------------------------
INT 0C - internal hardware - STACK FAULT (80286+)
   Generated on stack overflow/underflow in protected mode.
   Generated on accessing a word operand at SS:FFFFh in real mode.

Note:	the 80286 will shut down in real mode if SP=1 before a push.  On the
	  PC AT and compatibles, external circuitry generates a reset on
	  shutdown.
----------0C---------------------------------
INT 0C - IBM SYSTEM 36/38 WORKSTATION EMULATION - API POINTER
   Call offset 100h in the interrupt handler's segment with
   	AH = function
	    03h update screen
	    05h select next session
	    	AL = session number (00h-03h)
		Return: AL = session type code
			    00h not active
			    01h display session
			    02h printer session
			    FEh invalid session number
			DS = requested session's data segment (0 if not active)
Return: ???

Format of emulator's data area (offset from interrupt handler's segment):
Offset	Size	Description
13Eh	BYTE	bit flags for status line indicators turned on since this byte
		last zerod
13Fh	BYTE	bit flags for status line indicators turned off since this
		byte last set to FFh
140h	WORD	offset of EBCDIC to ASCII translation
146h	WORD	offset of EBCDIC screen buffer
148h	WORD	offset of EC (engineering change) level signature
150h	BYTE	"KEYI"
151h	BYTE	5250 key scan code to be sent to remote
15Bh	BYTE	"SYSAV"
15Dh	BYTE	5250 cursor column
15Eh	BYTE	5250 cursor row
167h	BYTE	"DVCTAD"
178h	BYTE	"FLAGS"
184h	BYTE	"SESSNOAD"
193h	BYTE	"STNAD"
198h	BYTE	"NSDS"
----------0D---------------------------------
INT 0D - IRQ5 - FIXED DISK (PC), LPT2 (AT/PS)
Note:	under DESQview, only the INT 15h vector and BASIC segment address (the
	  word at 0000h:0510h) may be assumed to be valid for the handler's
	  process
SeeAlso: INT 0E, INT 55
----------0D---------------------------------
INT 0D - IRQ5 - Tandy 1000 60 Hz RAM REFRESH
SeeAlso: INT 55
----------0D---------------------------------
INT 0D - internal hardware - GENERAL PROTECTION VIOLATION (80286+)
   Called in real mode when
	an instruction accesses a word operand located at offset FFFFh
	a PUSH MEM or POP MEM instruction contains an invalid bit encoding in
	  the second byte
	an instruction exceeds the maximum length allowed (10 bytes for 80286,
	  15 bytes for 80386)
	an instruction wraps from offset FFFFh to offset 0000h
   Called on 80486 protected-mode floating-point protection fault
SeeAlso: INT 09"80486", INT 0C"STACK"
----------0E---------------------------------
INT 0E - IRQ6 - DISKETTE INTERRUPT
Note:	generated by floppy disk controller on completion of an operation
SeeAlso: INT 0D, INT 56
----------0E---------------------------------
INT 0E - internal hardware - PAGE FAULT (80386+ native mode)
   used to implement virtual memory
SeeAlso: INT 0B"hardware"
----------0F---------------------------------
INT 0F - IRQ7 - PRINTER INTERRUPT
   Generated by the LPT1 printer adapter when printer becomes ready.
Notes:	most printer adapters do not reliably generate this interrupt.
	the 8259 interrupt controller generates an interrupt corresponding to
	  IRQ7 when an error condition occurs
SeeAlso: INT 57
----------10---------------------------------
INT 10 - internal hardware - COPROCESSOR ERROR (80286+)
Notes:	generated by the CPU when the -ERROR pin is asserted by the coprocessor
	AT's and clones usually wire the coprocessor to use IRQ13, but not all
	  get it right
SeeAlso: INT 09"hardware", INT 75
----------1000-------------------------------
INT 10 - VIDEO - SET VIDEO MODE
	AH = 00h
	AL = mode (graphics mode if graphics resolution listed)
		 text  pixel graphic colors disp scrn  system
		 resol	box  resoltn	    page addr
	   00h = 40x25	8x8	       B&W     8 B800 CGA
	       = 40x25	8x14	       B&W     8 B800 ATI VIP
	   01h = 40x25	8x8		16     8 B800 CGA
	       = 40x25	8x14		16     8 B800 ATI VIP
	   02h = 80x25	8x8	       B&W     4 B800 CGA
	       = 80x25	8x8	       B&W     8 B800 EGA,MCGA,VGA
	       = 80x25	8x14	       B&W     8 B800 ATI VIP
	   03h = 80x25	8x8		16     4 B800 CGA
	       = 80x25	8x8		16     8 B800 EGA,MCGA,VGA
	   04h = 40x25	8x8   320x200	 4     1 B800 CGA
	   05h = 40x25	8x8   320x200 4 gray   1 B800 CGA
	   06h = 80x25	8x8   640x200  B&W     1 B800 CGA
	   07h = 80x25	9x14	      mono     1 B000 MDA,Hercules
	       = 80x25			       8      EGA,VGA
	       = 80x25	9x14	      mono	 B000 ATI VIP
	   08h = 20x25	8x8   160x200	16	 B800 PCjr,Tandy 1000
	       = 132x25 8x8		16	 B800 ATI EGA/VGA Wonder **
	       = 132x25 8x8	      mono	 B000 ATI EGA/VGA Wonder **
	   09h = 40x25	8x8   320x200	16	 B800 PCjr,Tandy 1000
	   0Ah = 80x25	8x8   640x200	 4	 B800 PCjr,Tandy 1000
	   0Bh = reserved (used internally by EGA BIOS)
	   0Ch = reserved (used internally by EGA BIOS)
	   0Dh = 40x25	8x8   320x200	16     8 A000 EGA,VGA
	   0Eh = 80x25	8x8   640x200	16     4 A000 EGA,VGA
	   0Fh = 80x25	8x14  640x350 mono     2 A000 EGA,VGA
	   10h = 80x25	8x14  640x350 4or16    2 A000 EGA,VGA
	   11h = 80x30	8x16  640x480 mono	 A000 VGA,MCGA,ATI EGA,ATI VIP
	   12h = 80x30	8x16  640x480  16/256k	 A000 VGA,ATI VIP
	       = 80x30	8x16  640x480  16/64	 A000 ATI EGA Wonder
	   13h = 40x25	8x8   320x200 256/256k	 A000 VGA,MCGA,ATI VIP
	   14h = 80x25	8x8   640x200		      Lava Chrome II EGA
	       =	      640x400	16	      Tecmar VGA/AD
	   15h = 80x25	8x14  640x350		      Lava Chrome II EGA
	   16h = 80x25	8x14  640x350		      Lava Chrome II EGA
	       =	      800x600	16	      Tecmar VGA/AD
	   17h = 80x34	8x14  640x480		      Lava Chrome II EGA
	       = 132x25				      Tecmar VGA/AD
	   18h = 132x44 8x8	      mono	      Tseng Labs EVA
	       = 132x44 8x8	      16/256   2 B000 Tseng ET4000 chipset
	       = 80x34	8x14  640x480		      Lava Chrome II EGA
	       =	     1024x768	16	      Tecmar VGA/AD
	   19h = 132x25 8x14	      mono	      Tseng Labs EVA
	       = 132x25 8x14	      16/256   4 B000 Tseng ET4000 chipset
	   1Ah = 132x28 8x13	      mono	      Tseng Labs EVA
	       = 132x28 8x13	      16/256   4 B000 Tseng ET4000 chipset
	       =	      640x350  256	      Tecmar VGA/AD
	   1Bh =	      640x400  256	      Tecmar VGA/AD
	   1Ch =	      640x480  256	      Tecmar VGA/AD
	   1Dh =	      800x600  256	      Tecmar VGA/AD
	   21h = 80x43	8x8   720x348 mono	      DESQview 2.x+Hercules ***
	   22h = 132x44 8x8			      Tseng Labs EVA
	       = 132x44 8x8	      16/256   2 B800 Tseng ET4000 chipset
	       = 132x44 8x8			      Ahead Systems EGA2001
	       = 132x43				      Allstar Peacock (VGA)
	       = 132x44 		16	      Orchid Prodesigner VGA
	       = 80x43	8x8   720x348 mono	      DESQview 2.x+Hercules ***
	   23h = 132x25 6x14			      Tseng Labs EVA
	       = 132x25 8x14	      16/256   4 B800 Tseng ET4000 chipset
	       = 132x25 8x14			      Ahead Systems EGA2001
	       = 132x25 8x8		16	 B800 ATI EGA Wonder,ATI VIP
	       = 132x28				      Allstar Peacock (VGA)
	       = 132x28			16	      Orchid Prodesigner VGA
	   24h = 132x28 6x13			      Tseng Labs EVA
	       = 132x28 8x13	      16/256   4 B800 Tseng ET4000 chipset
	       = 132x25				      Allstar Peacock (VGA)
	       = 132x25 		16	      Orchid Prodesigner VGA
	   25h = 80x60	8x8   640x480		      Tseng Labs EVA
	       = 80x60	8x8   640x480 16/256   1 A000 Tseng ET4000 chipset
	       =	      640x480	16	      VEGA VGA
	       = 80x60	8x8   640x480	16	 A000 Orchid Prodesigner VGA
	   26h = 80x60	8x8			      Tseng Labs EVA
	       = 80x60	8x8	      16/256   2 B800 Tseng ET4000 chipset
	       = 80x60	8x8   640x480		      Ahead Systems EGA2001
	       = 80x60				      Allstar Peacock (VGA)
	       = 80x60	 		16	      Orchid ProDesigner VGA
	   27h =	      720x512	16	      VEGA VGA
	       =	      720x512	16	      Genoa
	       = 132x25 8x8	      mono	 B000 ATI EGA Wonder,ATI VIP
	   28h = ???x???			      VEGA VGA
	   29h =	      800x600	16	      VEGA VGA
	       = 100x37 8x16  800x600	16	 A000 Orchid
	       =	      800x600	16	 A000 STB,Genoa,Sigma
	       =	      800x600	16	      Allstar Peacock (VGA)
	       = 100x37 8x16  800x600 16/256   1 A000 Tseng ET4000 chipset
	   2Ah = 100x40 			      Allstar Peacock (VGA)
	       = 100x40 8x16		16	      Orchid Prodesigner VGA
	       = 100x40 8x15	      16/256   4 B800 Tseng ET4000 chipset
	   2Dh =	      640x350  256	      VEGA VGA
	       =	      640x350 256/256k	 A000 Orchid, Genoa, STB
	       = 80x25	8x14  640x350 256/256k 1 A000 Tseng ET4000 chipset
	   2Eh =	      640x480  256	      VEGA VGA
	       = 80x30	8x16  640x480 256/256k	 A000 Orchid
	       =	      640x480 256/256k	 A000 STB,Genoa,Sigma
	       = 80x30	8x16  640x480 256/256k 1 A000 Tseng ET4000 chipset
	   2Fh =	      720x512  256	      VEGA VGA
	       =	      720x512  256	      Genoa
	       = 80x25	8x16  640x400 256/256k 1 A000 Tseng ET4000 chipset
	   30h =	      800x600  256	      VEGA VGA
	       = 100x37 8x16  800x600 256/256k	 A000 Orchid 
	       =	      800x600 256/256k	 A000 STB,Genoa,Sigma
	       =	      720x350	 2	      3270 PC
	       =	      800x600  256	      Cardinal
	       =	      ???x???		 B800 AT&T 6300
	       = 100x37 8x16  800x600 256/256k 1 A000 Tseng ET4000 chipset
	   33h = 132x44 8x8		16	 B800 ATI EGA Wonder,ATI VIP
	   36h =	      960x720	16	      VEGA VGA
	       =	      960x720	16	      STB
	   37h =	     1024x768	16	      VEGA VGA
	       = 128x48 8x16 1024x768	16	 A000 Orchid
	       =	     1024x768	16	 A000 STB,Genoa,Sigma
	       = 132x44 8x8	      mono	 B800 ATI EGA Wonder,ATI VIP
	   38h =	     1024x768  256	      STB VGA/EM-16 Plus (1MB)
	       = 128x48 8x16 1024x768 256/256k 1 A000 Tseng ET4000 chipset
	   40h = 80x25	8x16  640x400	 2     1 B800 AT&T 6300, AT&T VDC600
	       = 80x25	8x16  640x400	 2     1 B800 Compaq Portable
	       = 80x43				      VEGA VGA, Tecmar VGA/AD
	       = 80x43				      Video7 V-RAM VGA
	       = 80x43				      Tatung VGA
	   41h =	      640x200	16     1      AT&T 6300
	       = 132x25 			      VEGA VGA
	       = 132x25				      Tatung VGA
	       = 132x25				      Video7 V-RAM VGA
	   42h = 80x25	8x16  640x400	16	      AT&T 6300, AT&T VDC600
	       = 132x43 			      VEGA VGA
	       = 132x43				      Tatung VGA
	       = 132x43				      Video7 V-RAM VGA
	   43h = unsupported  640x200 of 640x400 viewport  AT&T 6300
	       = 80x60				      VEGA VGA
	       = 80x60				      Tatung VGA
	       = 80x60				      Video7 V-RAM VGA
	   44h = disable VDC and DEB output	      AT&T 6300
	       = 100x60 			      VEGA VGA
	       = 100x60 			      Tatung VGA
	       = 100x60				      Video7 V-RAM VGA
	   45h = 132x28				      Tatung VGA
	       = 132x28				      Video7 V-RAM VGA
	   46h = 100x40 8x15  800x600	 2	      AT&T VDC600
	   47h = 100x37 8x16  800x600	16	      AT&T VDC600
	   48h = 80x50	8x8   640x400	 2	 B800 AT&T 6300, AT&T VDC600
	   49h = 80x30	8x16  640x480		      Lava Chrome II EGA
	   4Dh = 120x25 			      VEGA VGA
	   4Eh = 120x43 			      VEGA VGA
	   4Fh = 132x25 			      VEGA VGA
	   50h = 80x30	8x16  640x480	16	      Paradise EGA-480
	       = 80x30	8x16	      16/256k	 B800 Trident TVGA 8800
	       = 80x34				      Lava Chrome II EGA
	       = 80x43		      mono	      VEGA VGA
	       =	      640x480 mono???	      Taxan 565 EGA
	       = 132x25 9x14	      mono	      Ahead Systems EGA2001
	       = 132x25 8x14		16     8 B800 OAK Technologies VGA-16
	   51h = 80x30	8x16			      Paradise EGA-480
	       = 80x30				      Lava Chrome II EGA
	       = 80x34	8x14  640x480	16	      ATI EGA Wonder
	       = 80x43	8x11	      16/256k	 B800 Trident TVGA 8800
	       = 132x25 	      mono	      VEGA VGA
	       = 132x43 8x8		16     5 B800 OAK Technologies VGA-16
	   52h = 80x60				      Lava Chrome II EGA
	       = 80x60	8x8	      16/256k	 B800 Trident TVGA 8800
	       = 94x29	8x14  752x410	16	      ATI EGA Wonder
	       = 100x75	8x8   800x600	16     1 A000 OAK Technologies VGA-16
	       = 132x43 	      mono	      VEGA VGA
	       = 132x44 9x8	      mono	      Ahead Systems EGA2001
	   53h = 100x40 8x14  800x560	16	      ATI EGA Wonder,ATI VIP
	       = 132x25 8x14	      16/256k	 B800 Trident TVGA 8800
	       = 132x43 			      Lava Chrome II EGA
	   54h = 100x42 8x14  800x600	16	 A000 ATI EGA Wonder, VGA Wondr
	       = 132x25 			      Lava Chrome II EGA
	       = 132x30 8x16	      16/256k	 B800 Trident TVGA 8800
	       = 132x43 8x8			      Paradise EGA-480
	       = 132x43 7x9	      16/256k	 B800 Paradise VGA
	       = 132x43 8x9	      16/256k	 B800 Paradise VGA on multisync
	       = 132x43				      Taxan 565 EGA
	       = 132x43				      AST VGA Plus
	       = 132x43				      Hewlett-Packard D1180A
	       = 132x43 7x9		16	      AT&T VDC600
	   55h = 80x66	8x8	      16/256k	 A000 ATI VIP
	       = 94x29	8x14  752x410		      Lava Chrome II EGA
	       = 128x48 8x16 1024x768 16/256k	 A000 ATI VGA Wonder v4+  *!
	       = 132x25 8x14			      Paradise EGA-480
	       = 132x25 7x16	      16/256k	 B800 Paradise VGA
	       = 132x25 8x16	      16/256k	 B800 Paradise VGA on multisync
	       = 132x25				      Taxan 565 EGA
	       = 132x25				      AST VGA Plus
	       = 132x25				      Hewlett-Packard D1180A
	       = 132x25 7x16		16	      AT&T VDC600
	       = 132x43 8x11	      16/256k	 B800 Trident TVGA 8800
	   56h = 132x43 8x8	      3???     2 B000 NSI Smart EGA+
	       = 132x43 7x9		 4	 B000 Paradise VGA
	       = 132x43 8x9		 4	 B000 Paradise VGA on multisync
	       = 132x43 	      mono	      Taxan 565 EGA
	       = 132x43 7x9		 2	      AT&T VDC600
	       = 132x60 8x8	      16/256k	 B800 Trident TVGA 8800
	   57h = 132x25 8x14	      3???     4 B000 NSI Smart EGA+
	       = 132x25 7x16		 4	 B000 Paradise VGA
	       = 132x25 8x16		 4	 B000 Paradise VGA on multisync
	       = 132x25 	      mono	      Taxan 565 EGA
	       = 132x25 7x16		 2	      AT&T VDC600
	       = 132x25 9x14	      16/256k	 B800 Trident TVGA 8800
	   58h = 100x75 8x8   800x600 16/256k	 A000 Paradise VGA
	       = 100x75 8x8   800x600	16	      AT&T VDC600
	       = 80x33	8x14		16	 B800 ATI EGA Wonder,ATI VIP
	       =	      800x600	16	      AST VGA Plus, Compaq VGA
	       =	      800x600	16	      Dell VGA
	       =	      800x600	16	      Hewlett-Packard D1180A
	       = 132x30 9x16	      16/256k	 B800 Trident TVGA 8800
	   59h = 100x75 8x8   800x600	 2	 A000 Paradise VGA
	       = 100x75 8x8   800x600	 2	      AT&T VDC600
	       = 80x66	8x8	      16/256k	 A000 ATI VIP
	       =	      800x600	 2	      AST VGA Plus, Compaq VGA
	       =	      800x600	 2	      Dell VGA
	       =	      800x600	 2	      Hewlett-Packard D1180A
	       = 132x43 9x11	      16/256k	 B800 Trident TVGA 8800
	   5Ah = 132x60 9x8	      16/256k	 B800 Trident TVGA 8800
	   5Bh =	      800x600	16	      Maxxon, SEFCO TVGA, Imtec
	       =	      640x350  256	      Genoa 6400
	       = 80x30	8x16			 B800 ATI VGA Wonder (undoc)
	       = 100x75 8x8   800x600 16/256k	 A000 Trident TVGA 8800
	   5Ch =	      640x400  256	      Logix, ATI Prism Elite
	       =	      640x400  256	      Maxxon, SEFCO TVGA, Imtec
	       =	      640x400  256	      Zymos Poach
	       = 80x25	8x16  640x400  256	 A000 Trident TVGA 8800
	       =	      640x480  256	      Genoa 6400
	   5Dh =	      640x480  256	      Logix, ATI Prism Elite
	       =	      640x480  256	      Maxxon, SEFCO TVGA, Imtec
	       =	      640x480  256	      Zymos Poach
	       = 80x30	8x16  640x480  256	 A000 Trident TVGA 8800 (512K)
	   5Eh =	      640x400  256	      Paradise VGA,VEGA VGA
	       =	      640x400  256	      AST VGA Plus
	       =	      640x400  256	      Compaq VGA, Dell VGA
	       = 80x25	8x16  640x400  256	      AT&T VDC600
	       =	      800x600	16	      Logix, ATI Prism Elite
	       =	      800x600  256	      Genoa 6400
	       =	      800x600  256	      Zymos Poach
	   5Fh =	      640x480  256	      Paradise VGA
	       =	      640x480  256	      AST VGA Plus
	       =	      640x480  256	      Compaq VGA, Dell VGA
	       =	      640x480  256	      Hewlett-Packard D1180A
	       = 80x30	8x16  640x480  256	      AT&T VDC600 (512K)
	       =	     1024x768	16	      Logix, ATI Prism Elite
	       =	     1024x768	16	      Maxxon, Genoa 6400, Imtec
	       =	     1024x768	16	      Zymos Poach
	       = 128x48 8x16 1024x768 16/256k	 A000 Trident TVGA 8800 (512K)
	   60h = 80x???       ???x400		      Corona/Cordata BIOS 4.10+
	       =	      752x410		      VEGA VGA
	       =	      752x410	16	      Tatung VGA
	       =	      752x410	16	      Video7 V-RAM VGA
	       =	      640x400  256	      Ahead B
	   61h =	      ???x400		      Corona/Cordata BIOS 4.10+
	       =	      720x540		      VEGA VGA
	       =	      720x540	16	      Tatung VGA
	       =	      720x540	16	      Video7 V-RAM VGA
	       =	      640x400  256	 A000 ATI VGA Wonder
	       =	      640x480  256	      Ahead B
	       = 96x64	8x16 768x1024 16/256k	 A000 Trident TVGA 8800 (512K)
	   62h =	      800x600		      VEGA VGA
	       =	      800x600	16	      Tatung VGA
	       =	      800x600	16	      Video7 V-RAM VGA
	       =	      640x480  256	 A000 ATI VGA Wonder
	       =	      800x600  256	      Ahead B
	   63h =	     1024x768	 2	      Video7 V-RAM VGA
	       =	      800x600  256	 A000 ATI VGA Wonder
	       =	     1024x768  256	      Ahead B (1MB)
	   64h =	     1024x768	 4	      Video7 V-RAM VGA
	   65h =	     1024x768	16	      Video7 V-RAM VGA
	       =	     1024x768	16	 A000 ATI VGA Wonder
	   66h =	      640x400  256	      Tatung VGA
	       =	      640x400  256	      Video7 V-RAM VGA
	   67h =	      640x480  256	      Video7 V-RAM VGA
	       =	     1024x768	 4	 A000 ATI VGA Wonder
	   69h =	      720x540  256	      Video7 V-RAM VGA
	   6Ah =	      800x600	16	      VESA standard interface
	       =	      800x600	16	      Ahead B, Genoa 6400
	       =	      800x600	16	      Zymos Poach
	       = 100x42 8x14  800x600		 A000 ATI VGA Wonder (undoc)
	   70h =	      800x600	16	      Cardinal
	       = extended mode set (see AX=0070h)     Everex Micro Enhancer EGA
	   71h = 100x35 8x16  800x600 16of64	 A000 NSI Smart EGA+
	       =	      960x720	16	      Cardinal
	   72h =	     1024x768	16	      Cardinal
	   74h =	      640x400	 2	 B800 Toshiba 3100 AT&T mode
	       =	     1024x768	16	      Ahead B
	   78h =	      640x400  256	      STB VGA/EM-16 Plus
	       =	      640x400  256	      Cardinal
	   79h =	      640x480  256	      Cardinal
	   7Ah =	      720x540  256	      Cardinal
	   7Ch =	      512x512	16	      Genoa
	   7Dh =	      512x512  256	      Genoa
	   7Eh = special mode set (see AX=007Eh)      Paradise VGA, AT&T VDC600
	   7Fh = special function set (see AX=007Fh)  Paradise VGA, AT&T VDC600
	   82h = 80x25		       B&W	      AT&T VDC overlay mode *
	   83h = 80x25				      AT&T VDC overlay mode *
	   86h =	      640x200  B&W	      AT&T VDC overlay mode *
	   C0h =	      640x400  2/prog pallet  AT&T VDC overlay mode *
	   C4h = disable output 		      AT&T VDC overlay mode *
	   D0h =	      640x400	 2	 B800 DEC VAXmate AT&T mode

 *  for AT&T VDC overlay modes, BL contains the DEB mode, which may be 06h,
	  40h, or 44h
 ** for ATI EGA Wonder, mode 08h is only valid if SMS.COM is loaded resident.
      SMS maps mode 08h to mode 27h if the byte at location 0040:0063 is 0B4h,
      otherwise to mode 23h, thus selecting the appropriate (monochrome or
      color) 132x25 character mode.
    for ATI VGA Wonder, mode 08h is the same, and only valid if VCONFIG loaded
      resident
 *** DESQview intercepts calls to change into these two modes (21h is page 0,
      22h is page 1) even if there is no Hercules graphics board installed
 *! ATI BIOS v4-1.00 has a text-scrolling bug in this mode

Notes:	IBM standard modes do not clear the screen if the high bit of AL is set
	the Tseng ET4000 chipset is used by the Orchid Prodesigner II, Diamond
	  SpeedSTAR VGA, Groundhog Graphics Shadow VGA
SeeAlso: AX=0070h,007Eh,6F05h
----------100070-----------------------------
INT 10 - VIDEO - Everex Micro Enhancer EGA/Viewpoint VGA - EXTENDED MODE SET
	AX = 0070h
	BL = mode (graphics mode if graphics resolution listed)
		 text  pixel  graphic colr disp scrn  monitor	adapter
		 resol	box   resoltn	   page addr
	   00h =	      640x480  16	      multsync	EGA,VGA
	   01h =	      752x410  16	      multsync	EGA,VGA
	   02h =	      800x600  16	      multsync	EGA,VGA
	   03h = 80x34				      multsync	EGA,VGA
	   04h = 80x60				      multsync	EGA,VGA
	   05h = 94x29				      multsync	EGA only
	   06h = 94x51				      multsync	EGA only
	   07h = 100x43 8x14	       16			VGA only
	   08h = 100x75 8x8	       16			VGA only
	   09h = 80x44				      EGA	EGA only
	   0Ah = 132x25 			      EGA	EGA,VGA
	   0Bh = 132x44 			      EGA	EGA,VGA
	   0Ch = 132x25 			      CGA	EGA only
	   0Dh = 80x44				      mono	EGA only
	   0Eh = 132x25 			      mono
	   0Fh = 132x44 			      mono
	   10h = reserved
	   11h =	     1280x350	4			EGA only
	   12h =	     1280x600	4			EGA only
	   13h =	      640x350 256			EGA only
	   14h =	      640x400 256
	   15h =	      512x480 256
	   16h = 80x30	8x16	      256			VGA only
	   18h = 100x27 8x16	       16			VGA only
	   20h =	     1024x768  16			Everex 678 only
	   21h = 160x64 8x16 1280x1024 16			1MB VGA only
	   30h =	      640x480 256			Everex 678 only
	   31h =	      800x600 256			Everex 678 only
	   32h = 128x48 8x16 1024x768 256			1MB VGA only
	   40h = 132x30 8x16	       16			VGA only
	   50h = 132x32 8x16	      mono			VGA only
----------10007E-----------------------------
INT 10 - VIDEO - Paradise VGA, AT&T VDC600 - SET SPECIAL MODE
	AX = 007Eh
	BX = The horizontal dimension of the mode desired
	CX = The vertical dimension of the mode desired
	     (both BX/CX in pixels for graphics modes, rows for alpha modes)
	DX = The number of colors of the mode desired
	     (use 0 for monochrome modes)
Return: BH = 7Eh if successful (Paradise VGA)
	AL = 7Eh if successful (AT&T VDC600)
SeeAlso: AH=00h,AX=0070h,007Fh,6F05h
----------10007F-----------------------------
INT 10 - VIDEO - Paradise VGA, AT&T VDC600 - EXTENDED FUNCTIONS
	AX = 007Fh
	BH = 00h  set VGA operation
	BH = 01h  set non-VGA operation
	    color modes (0,1,2,3,4,5,6) will set non-VGA CGA operation.
	    monochrome mode 7 will set non-VGA MDA/Hercules operation.
	BH = 02h  query mode status
	    Return: BL = 00h if operating in VGA mode, 01h if non-VGA mode.
		    CH = total video RAM size in 64k byte units.
		    CL = video RAM used by the current mode.
	BH = 03h  lock current mode
	    allows current mode (VGA or non-VGA) to survive re-boot.
	BH = 04h  enter CGA mode (AT&T VDC600 only)
	BH = 05h  enter MDA mode (AT&T VDC600 only)
	BH = 0Ah,0Bh,0Ch,0Dh,0Eh,0Fh  WRITE PARADISE REGISTERS 0,1,2,3,4,5
		(port 03CEh indices 0Ah,0Bh,0Ch,0Dh,0Eh,0Fh)
	    BL = value to set in the paradise register.
	BH = 1Ah,1Bh,1Ch,1Dh,1Eh,1Fh READ PARADISE REGISTERS 0,1,2,3,4,5
		(port 03CEh indices 0Ah,0Bh,0Ch,0Dh,0Eh,0Fh)
	    Return: BL = value of the paradise register.
		    BH = 7Fh if successful.
Return: AL = 7Fh if successful (AT&T VDC600)
SeeAlso: AX=007Eh
----------1001-------------------------------
INT 10 - VIDEO - SET CURSOR CHARACTERISTICS
	AH = 01h
	CH bits 0-4 = start line for cursor in character cell
	   bits 5-6 = blink attribute
		     (00=normal, 01=invisible, 10=slow, 11=fast on CGA/mono)
		     (00=normal, other=invisible on EGA/VGA)
	CL bits 0-4 = end line for cursor in character cell
Note:	buggy on EGA systems--BIOS remaps cursor shape in 43 line modes, but
	  returns unmapped cursor shape
BUG:	AMI 386 BIOS and AST Premier 386 BIOS will lock up the system if AL
	  is not equal to the current video mode
SeeAlso: AH=03h
----------1002-------------------------------
INT 10 - VIDEO - SET CURSOR POSITION
	AH = 02h
	DH,DL = row, column (0,0 = upper left)
	BH = page number
	    0 in graphics modes
	    0-3 in modes 2&3
	    0-7 in modes 0&1
SeeAlso: AH=03h
----------1003-------------------------------
INT 10 - VIDEO - READ CURSOR POSITION
	AH = 03h
	BH = page number
	    0 in graphics modes
	    0-3 in modes 2&3
	    0-7 in modes 0&1
Return: DH,DL = row,column
	CH = cursor start line
	CL = cursor end line
SeeAlso: AH=01h,02h
----------1004-------------------------------
INT 10 - VIDEO - READ LIGHT PEN POSITION (all but PS)
	AH = 04h
Return: AH = 00h light pen switch not activated
	   = 01h light pen values in registers
	    DH,DL = row,column of current position
	    CH = raster line (0-199) (EGA) old graphics modes
	    CX = (EGA) raster line (0-nnn) new graphics modes
	    BX = pixel column (0-319 or 0-639)
----------1005-------------------------------
INT 10 - VIDEO - SELECT DISPLAY PAGE
	AH = 05h
	AL = display page
	    0-7  for modes 0 & 1
	    0-3  for modes 2 & 3
SeeAlso: AH=0Fh
----------1005-------------------------------
INT 10 - PCjr VIDEO - CRT/CPU PAGE REGISTERS
	AH = 05h
	AL =
	    80h read CRT/CPU page registers
	    81h set CPU page register
		BL = new page register value
	    82h set CRT page register
		BH = new page register value
	    83h set both display registers
		BL = new CPU page register
		BH = new CRT page register
Return: BH = CRT page register
	BL = CPU page register
----------1005-------------------------------
INT 10 - VIDEO - GRAPHICS BITMAP BUFFER (Corona/Cordata BIOS v4.10+)
	AH = 05h
	AL =
	    00h set address of graphics bitmap buffer (video modes 60h,61h)
		BX = segment of buffer
	    0Fh get address of graphics bitmap buffer (video modes 60h,61h)
		Return: DX = segment of graphics bitmap buffer
----------1006-------------------------------
INT 10 - VIDEO - SCROLL PAGE UP
	AH = 06h
	AL = number of lines to scroll window (0 = blank whole window)
	BH = attributes to be used on blanked lines
	CH,CL = row,column of upper left corner of window to scroll
	DH,DL = row,column of lower right corner of window
Warning: some implementations have a bug which destroys BP
SeeAlso: AH=07h,72h,73h
----------1007-------------------------------
INT 10 - VIDEO - SCROLL PAGE DOWN
	AH = 07h
	AL = number of lines to scroll window (0 = blank whole window)
	BH = attributes to be used on blanked lines
	CH,CL = row,column of upper left corner of window to scroll
	DH,DL = row,column of lower right corner of window
Warning: some implementations have a bug which destroys BP
SeeAlso: AH=06h,72h,73h
----------1008-------------------------------
INT 10 - VIDEO - READ ATTRIBUTES/CHARACTER AT CURSOR POSITION
	AH = 08h
	BH = display page
Return: AL = character
	AH = attribute of character (alpha modes)
		bit 7: blink
		bits 6-4: background color
			000 black
			001 blue
			010 green
			011 cyan
			100 red
			101 magenta
			110 brown
			111 white
		bits 3-0: foreground color
			0000 black	 1000 dark gray
			0001 blue	 1001 light blue
			0010 green	 1010 light green
			0011 cyan	 1011 light cyan
			0100 red	 1100 light red
			0101 magenta	 1101 light magenta
			0110 brown	 1110 yellow
			0111 light gray	 1111 white
Notes:	for monochrome displays, a foreground of 1 with background 0 is
	  underlined 
	the blink bit may be reprogrammed to enable intense background colors
	  using AX=1003h or by programming the CRT controller
SeeAlso: AH=09h,AX=1003h
----------1009-------------------------------
INT 10 - VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION
	AH = 09h
	AL = character
	BH = display page
	BL = attributes of character (alpha modes) or color (graphics modes)
	     if bit 7 set in graphics mode, character is xor'ed onto screen
	CX = number of times to write character
Note:	all characters are displayed, including CR, LF, and BS
SeeAlso: AH=08h,0Ah
----------100A-------------------------------
INT 10 - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
	AH = 0Ah
	AL = character
	BH = display page - alpha mode
	BL = color of character (graphics mode, PCjr only)
	     if bit 7 set in graphics mode, character is xor'ed onto screen
	CX = number of times to write character
	     (EGA) in graphics modes, replication count in CX works correctly
	     only if all character written are contains on the same row
Note:	all characters are displayed, including CR, LF, and BS
SeeAlso: AH=08h,09h
----------100B-------------------------------
INT 10 - VIDEO - SET COLOR PALETTE
	AH = 0Bh
	BH = 00h
	    BL = border color (0-15) (text modes)
		 border color and background color (graphics modes)
	    (EGA)
	    BL = border color (0-15) and high-intensity background color
		  (16-31??? maybe should be high nybble?)
	BH = 01h
	    BL = palette (0-3)
----------100C-------------------------------
INT 10 - VIDEO - WRITE DOT ON SCREEN
	AH = 0Ch
	AL = color of dot (0/1 in mode 6, 0-3 in modes 4 and 5)
	     if bit 7 set, new color will be XORed with current pixel
	BH = display page (ignored if mode only supports one page)
	CX = column
	DX = row
Note:	only valid in graphics modes
SeeAlso: AH=0Dh
----------100D-------------------------------
INT 10 - VIDEO - READ DOT ON SCREEN
	AH = 0Dh
	BH = display page (ignored if mode only supports one page)
	CX = column
	DX = row
Return: AL = color read
Note:	only valid in graphics modes
SeeAlso: AH=0Ch
----------100E-------------------------------
INT 10 - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
	AH = 0Eh
	AL = character
	BH = display page (alpha modes)
	BL = foreground color (graphics modes)
Note:	characters 07h (BEL), 08h (BS), 0Ah (LF), and 0Dh (CR) are interpreted
	  and do the expected things
SeeAlso: AH=02h,0Ah
----------100F-------------------------------
INT 10 - VIDEO - GET CURRENT VIDEO MODE
	AH = 0Fh
Return: AH = number of columns on screen
	AL = current video mode (see INT 10/AH=00h)
	BH = current active display page
Note:	if mode was set with bit 7 set ("no blanking"), the returned mode will
	  also have bit 7 set
SeeAlso: AH=00h,05h
----------100F56-----------------------------
INT 10 - VUIMG DISPLAY DRIVER (v2.20 and below)
	AX = 0F56h
	BX = 4756h
	CX = 4944h
	DL = function
	    01h installation check
		Return: AX = 5649h
			BX = 4443h
			CX = 5647h
			DH = 01h
	    02h get first video mode's parameters
		Return: AX = BIOS mode number
			BX = widht in pixels
			CX = height in pixels
			DX = number of colors
	    03h get next video mode's parameters
		Return: as for DL=02h
	    04h display line???
		ES:DI -> record (see below)
		???
		Return: ???

Format of record for DL=04h:
Offset	Size	Description
 00h	WORD	row number
 02h	WORD	starting column???
 04h	WORD	ending column???
	???
----------101000----------------------------
INT 10 - VIDEO - SET PALETTE REGISTER (Jr, PS, TANDY 1000, EGA, VGA)
	AX = 1000h
	BL = palette register to set
	BH = color value to store
Note:	on MCGA, only BX = 0712h is supported
SeeAlso: AX=1002h,1007h
----------101001-----------------------------
INT 10 - VIDEO - SET BORDER COLOR REGISTER (Jr, PS, TANDY 1000, EGA, VGA)
	AX = 1001h
	BH = color value to store
SeeAlso: AX=1008h
----------101002-----------------------------
INT 10 - VIDEO - SET ALL PALETTE REGISTERS (Jr, PS, TANDY 1000, EGA, VGA)
	AX = 1002h
	ES:DX -> 17-byte palette register list (see below)
SeeAlso: AX=1000h,1009h

Format of palette register list:
Offset	Size	Description
 00h 16 BYTEs	values for palette registers 0-15
 10h	BYTE	value for border color register
----------101003-----------------------------
INT 10 - VIDEO - TOGGLE INTENSITY/BLINKING BIT (Jr, PS, TANDY 1000, EGA, VGA)
	AX = 1003h
	BL = 00h enable background intensity
	   = 01h enable blink
SeeAlso: AH=08h
----------101007-----------------------------
INT 10 - VIDEO - GET INDIVIDUAL PALETTE REGISTER (VGA)
	AX = 1007h
	BL = palette register number
Return: BH = palette register value
SeeAlso: AX=1000h,1009h
----------101008-----------------------------
INT 10 - VIDEO - READ OVERSCAN (BORDER COLOR) REGISTER (VGA)
	AX = 1008h
Return: BH = value
SeeAlso: AX=1001h
----------101009-----------------------------
INT 10 - VIDEO - READ ALL PALETTE REGISTERS AND OVERSCAN REGISTER (VGA)
	AX = 1009h
	ES:DX -> 17-byte buffer (see AX=1002h)
SeeAlso: AX=1002h,1007h
----------101010-----------------------------
INT 10 - VIDEO - SET INDIVIDUAL DAC REGISTER (EGA, VGA/MCGA)
	AX = 1010h
	BX = register number
	CH = new value for green (0-63)
	CL = new value for blue (0-63)
	DH = new value for red (0-63)
SeeAlso: AX=1012h,1015h
----------101012-----------------------------
INT 10 - VIDEO - SET BLOCK OF DAC REGISTERS (EGA, VGA/MCGA)
	AX = 1012h
	BX = starting color register
	CX = number of registers to set
	ES:DX -> table of 3*CX bytes where each 3 byte group represents one
		 byte each of red, green and blue (0-63)
SeeAlso: AX=1010h,1017h
----------101013-----------------------------
INT 10 - VIDEO - SELECT VIDEO DAC COLOR PAGE (VGA)
	AX = 1013h
	BL = 00h Select paging mode
		BH = 00h Select 4 blocks of 64
		BH = 01h Select 16 blocks of 16
	BL = 01h Select Page
		BH = page number (00h to 03h) or (00h to 0Fh)
Note:	not valid in mode 13h
SeeAlso: AX=101Ah
----------101015-----------------------------
INT 10 - VIDEO - READ INDIVIDUAL DAC REGISTER (EGA, VGA/MCGA)
	AX = 1015h
	BL = palette register number
Return: DH = red value
	CH = green value
	CL = blue value
SeeAlso: AX=1010h,1017h
----------101017-----------------------------
INT 10 - VIDEO - READ BLOCK OF DAC REGISTERS (EGA, VGA/MCGA)
	AX = 1017h
	BX = starting palette register
	CX = number of palette registers to read
	ES:DX -> buffer (3 * CX bytes in size) (see also AX=1012h)
Return: CX number of red, green and blue triples in buffer
SeeAlso: AX=1012h,1015h
----------101018-----------------------------
INT 10 - VIDEO - undocumented - SET PEL MASK (EGA, VGA/MCGA)
	AX = 1018h
	BL = new PEL value
SeeAlso: AX=1019h
----------101019-----------------------------
INT 10 - VIDEO - undocumented - READ PEL MASK (EGA, VGA/MCGA)
	AX = 1019h
Return:	BL = value read
SeeAlso: AX=1018h
----------10101A-----------------------------
INT 10 - VIDEO - GET VIDEO DAC COLOR-PAGE STATE (VGA)
	AX = 101Ah
Return: BL = paging mode
	    00h four pages of 64
	    01h sixteen pages of 16
	BH = current page
SeeAlso: AX=1013h
----------10101B-----------------------------
INT 10 - VIDEO - PERFORM GRAY-SCALE SUMMING (EGA, VGA/MCGA)
	AX = 101Bh
	BX = starting palette register
	CX = number of registers to convert
SeeAlso: AH=12h/BL=33h
----------1011-------------------------------
INT 10 - VIDEO - TEXT-MODE CHARACTER GENERATOR FUNCTIONS (PS, EGA, VGA)
	AH = 11h
	The following functions will cause a mode set, completely resetting
	the video environment, but without clearing the video buffer
	AL = 00h, 10h: load user-specified patterns
	    ES:BP -> user table
	    CX	  = count of patterns to store
	    DX	  = character offset into map 2 block
	    BL	  = block to load in map 2
	    BH	  = number of bytes per character pattern
	AL = 01h, 11h: load ROM monochrome patterns (8 by 14)
	    BL	  = block to load
	AL = 02h, 12h: load ROM 8 by 8 double-dot patterns
	    BL	  = block to load
	AL = 03h: set block specifier
	    BL	  = block specifier
		   (EGA/MCGA) bits 0,1 = block selected by chars with attribute
					 bit 3 = 0
			      bits 2,3 = block selected by chars with attribute
					 bit 3 = 1
		   (VGA) bits 0,1,4 = block selected by attribute bit 3 = 0
			 bits 2,3,5 = block selected by attribute bit 3 = 1
	AL = 04h, 14h: load ROM 8x16 character set (VGA)
	The routines called with AL=1xh are designed to be called only
	immediately after a mode set and are similar to the routines called
	with AL=0xh, except that:
	      Page 0 must be active.
	      Bytes/character is recalculated.
	      Max character rows is recalculated.
	      CRT buffer length is recalculated.
	      CRTC registers are reprogrammed as follows:
		     R09 = bytes/char-1 ; max scan line (mode 7 only)
		     R0A = bytes/char-2 ; cursor start
		     R0B = 0		; cursor end
		     R12 = ((rows+1)*(bytes/char))-1 ; vertical display end
		     R14 = bytes/char	; underline loc
			   (*** BUG: should be 1 less ***)
----------1011-------------------------------
INT 10 - VIDEO - GRAPHICS-MODE CHARACTER GENERATOR FUNCTIONS (PS, EGA, VGA)
	AH = 11h
	AL = 20h: set user 8 by 8 graphics characters (INT 1Fh)
	    ES:BP -> user table
	AL = 21h: set user graphics characters
	    ES:BP -> user table
	    CX	  = bytes per character
	    BL	  = row specifier
		   00h user set
		      DL = number of rows
		   01h 14 rows
		   02h 25 rows
		   03h 43 rows
	AL = 22h: ROM 8 by 14 set
	    BL = row specifier
	AL = 23h: ROM 8 by 8 double dot
	    BL = row specifier
	AL = 24h: load 8x16 graphics characters (VGA/MCGA)
	    BL = row specifier
	AL = 29h: load 8x16 graphics characters (Compaq Systempro)
	    BL = row specifier
Note:	these functions are meant to be called only after a mode set
----------101130-----------------------------
INT 10 - VIDEO - GET FONT INFORMATION (EGA, MCGA, VGA)
	AX = 1130h
	BH = pointer specifier
	    00h INT 1Fh pointer
	    01h INT 44h pointer
	    02h ROM 8 by 14 character font pointer
	    03h ROM 8 by 8 double dot font pointer
	    04h ROM 8 by 8 DD font (top half)
	    05h ROM alpha alternate (9 by 14) pointer
Return: ES:BP = specified pointer
	CX    = bytes/character
	DL    = character rows on screen
----------1012--BL10-------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (PS, EGA, VGA, MCGA) - GET EGA INFO
	AH = 12h
	BL = 10h
Return: BH = 00h color mode in effect (I/O port 3Dxh)
  	     01h mono mode in effect (I/O port 3Bxh)
	BL = 00h  64k bytes memory installed
	     01h 128k bytes memory installed
	     02h 192k bytes memory installed
	     03h 256k bytes memory installed
	CH = feature bits
	CL = switch settings
----------1012--BL20-------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (PS,EGA,VGA,MCGA) - ALTERNATE PRTSC
	AH = 12h
	BL = 20h  select alternate print screen routine
SeeAlso: INT 05
----------1012--BL30-------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (VGA) - SELECT VERTICAL RESOLUTION
	AH = 12h
	BL = 30h
	AL = vertical resolution
	     00h 200 scan lines
	     01h 350 scan lines
	     02h 400 scan lines
Return: AL = 12h if function supported
----------1012--BL31-------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (VGA, MCGA) - PALETTE LOADING
	AH = 12h
	BL = 31h
	AL = 00h enable default palette loading
	     01h disable default palette loading
Return: AL = 12h if function supported
----------1012--BL32-------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (VGA, MCGA) - VIDEO ADDRESSING
	AH = 12h
	BL = 32h
	AL = 00h enable video addressing
	     01h disable video addressing
Return: AL = 12h if function supported
----------1012--BL33-------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (VGA, MCGA) - GRAY-SCALE SUMMING
	AH = 12h
	BL = 33h
	AL = 00h enable gray scale summing
	     01h disable gray scale summing
Return: AL = 12h if function supported
SeeAlso: AX=101Bh
----------1012--BL34-------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (VGA) - CURSOR EMULATION
	AH = 12h
	BL = 34h
	AL = 00h enable alphanumeric cursor emulation
	     01h disable alphanumeric cursor emulation
Return: AL = 12h if function supported
----------1012--BL35-------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (PS) - DISPLAY-SWITCH INTERFACE
	AH = 12h
	BL = 35h
	AL = 00h initial adapter video off
	     01h initial planar video on
	     02h switch active video off
	     03h switch inactive video on
	     80h *UNDOCUMENTED* set system board video active flag
	ES:DX -> buffer (128 byte save area if AL = 0, 2 or 3)
Return: AL = 12h if function supported
----------1012--BL36-------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (PS, VGA) - VIDEO REFRESH CONTROL
	AH = 12h
	BL = 36h
	AL = 00h enable refresh
	     01h disable refresh
Return: AL = 12h if function supported
----------1012--BH55-------------------------
INT 10 - VIDEO - ALTERNATE FUNC SELECT (ATI,Tatung,Taxan) - ENHANCED FEATURES
	AH = 12h
	BH = 55h
	BL = subfunction
	    00h disabled enhanced features
	    01h enable enhanced features
	    02h get status
		Return: AL = status flags
			    bit 3: set if enhanced features enabled
			    bits 7-5 monitor type
				000 PS/2 mono
				001 PS/2 color
				010 multi-sync
				011 Taxan 650 25kHz
				100 RGB
				101 mono
				110 EGA
				111 Compaq internal
	    03h disable register trapping (CGA emulation)
	    04h enable register trapping
	    05h program mode described by table at ES:BP
	    06h get mode table
		AL = video mode
		Return: ES:BP -> table suitable for mode AL (and subfnc BL=05h)
			BP = FFFFh on error

Format of ATI VGA Wonder video mode table:
Offset	Size	Description
 00h	BYTE	number of columns
 01h	BYTE	maximum row (number of rows - 1)
 02h	BYTE	scan lines per row
 03h	WORD	video buffer size in bytes
 05h  4 BYTEs	values for Sequencer registers 1-4
 09h	BYTE	value for Miscellaneous Output register
 0Ah 25 BYTEs	values for CRTC registers 00h-18h
		00h horizontal total size (chars)
		01h horizontal displayed (chars)
		02h horizontal sync position (chars)
		03h horizontal sync width (chars)
		04h vertical total size (char rows)
		05h vertical total adjust (scan lines)
		06h vertical displayed (char rows)
		07h vertical sync position (char rows)
		08h interlace mode
		09h max scan line in row
		0Ah cursor start scan line
		0Bh cursor end scan line
		0Ch screen memory start (high)
		0Dh screen memory start (low)
		0Eh cursor address (high)
		0Fh cursor address (low)
		10h light pen (high)
		11h light pen (low)
 23h 20 BYTEs	default palette (values for Attribute Controller regs 00h-13h)
 37h  9 BYTEs	values for Graphics Controller registers 00h-08h
----------1013-------------------------------
INT 10 - VIDEO - WRITE STRING (AT,XT286,PS,EGA,VGA)
	AH = 13h
	AL = mode
	    bit 1: set if string contains alternating characters and attributes
	    bit 0: set in order to move cursor after write
	BL = attribute if AL bit 1 clear
	BH = display page number
	DH,DL = row,column of starting cursor position
	CX = length of string
	ES:BP -> start of string
Note:	recognizes CR, LF, BS, and bell
SeeAlso: AH=09h,0Ah
----------101400-----------------------------
INT 10 - VIDEO - LOAD USER-SPECIFIED LCD CHARACTER FONT (CONV,Compaq Port 386)
	AX = 1400h
	ES:DI -> character font
	BH = number of bytes per character
	    08h or 10h (Compaq)
	BL = 00h load main font (block 0)
	     01h load alternate font (block 1)
	CX = number of characters to store
	DX = character offset into RAM font area
SeeAlso: AH=11h,AX=1401h
----------101401-----------------------------
INT 10 - VIDEO - LOAD SYSTEM ROM DEFAULT LCD CHARACTER FONT (CONV,CP386)
	AX = 1401h
	BL = 00h load main font (block 0)
	     01h load alternate font (block 1)
SeeAlso: AH=11h,AX=1400h
----------101402-----------------------------
INT 10 - VIDEO - SET MAPPING OF LCD HIGH INTENSITY ATTRIBUTES (CONV,CP386)
	AX = 1402h
	BL = 00h ignore high intensity attribute
	     01h map high intensity to underscore
	     02h map high intensity to reverse video
	     03h map high intensity to selected alternate font
	     B0h half intensity (Compaq)
	     B1h toggle active intensity bit interpretation (CP386)
----------1015-------------------------------
INT 10 - VIDEO - GET PHYSICAL DISPLAY PARAMETERS (CONVERTIBLE)
	AH = 15h
Return: AX = alternate display adapter type
	    0000h none
	    5140h LCD
	    5153h CGA
	    5151h mono
	ES:DI -> parameter table (see below)
SeeAlso: AH=1Bh

Format of display parameter table:
Offset	Size	Description
 00h	WORD	monitor model number
 02h	WORD	vertical pixels per meter
 04h	WORD	horizontal pixels per meter
 06h	WORD	total vertical pixels
 08h	WORD	total horizontal pixels
 0Ah	WORD	horizontal pixel separation in micrometers
 0Ch	WORD	vertical pixel separation in micrometers
----------1015-------------------------------
INT 10 - VIDEO - SET SUPERIMPOSE MODE (Sperry PC)
	AH = 15h
	AL = superimpose mode
	    00h show graphics screen
	    01h show text screen
	    02h show text screen superimposed on graphics screen
----------101A-------------------------------
INT 10 - VIDEO - DISPLAY COMBINATION (PS,VGA/MCGA)
	AH = 1Ah
	AL = 00h read display combination code
		Return: BL = active display code (see below)
			BH = alternate display code
	     01h set display combination code
		BL = active display code (see below)
		BH = alternate display code
Return: AL = 1Ah if function was supported

Values for display combination code:
	00h no display
	01h monochrome adapter w/ monochrome display
	02h CGA w/ color display
	03h reserved
	04h EGA w/ color display
	05h EGA w/ monochrome display
	06h PGA w/ color display
	07h VGA w/ monochrome analog display
	08h VGA w/ color analog display
	09h reserved
	0Ah MCGA w/ digital color display
	0Bh MCGA w/ monochrome analog display
	0Ch MCGA w/ color analog display
	FFh unknown display type
----------101B-------------------------------
INT 10 - VIDEO - FUNCTIONALITY/STATE INFORMATION (PS,VGA/MCGA)
	AH = 1Bh
	BX = implementation type
	   = 0000h return funtionality/state information
	ES:DI -> 64 byte buffer for state information (see below)
Return: AL = 1Bh if function supported
	    ES:DI buffer filled with state information
SeeAlso: AH=15h

Format of state information:
Offset	Size	Description
 00h	DWORD	address of static funtionality table (see below)
 04h	BYTE	video mode in effect
 05h	WORD	number of columns
 07h	WORD	length of regen buffer in bytes
 09h	WORD	starting address of regen buffer
 0Bh	WORD	cursor position for page 0
 0Dh	WORD	cursor position for page 1
 0Fh	WORD	cursor position for page 2
 11h	WORD	cursor position for page 3
 13h	WORD	cursor position for page 4
 15h	WORD	cursor position for page 5
 17h	WORD	cursor position for page 6
 19h	WORD	cursor position for page 7
 1Bh	WORD	cursor type
 1Dh	BYTE	active display page
 1Eh	WORD	CRTC port address
 20h	BYTE	current setting of register (3?8)
 21h	BYTE	current setting of register (3?9)
 22h	BYTE	number of rows
 23h	WORD	bytes/character
 25h	BYTE	DCC of active display
 26h	BYTE	DCC of alternate display
 27h	WORD	number of colors supported in current mode
 29h	WORD	number of pages supported in current mode
 2Ah	BYTE	number of scan lines active
		(0,1,2,3) = (200,350,400,480)
 2Bh	BYTE	primary character block
 2Ch	BYTE	secondary character block
 2Dh	BYTE	miscellaneous flags
		bit 0 all modes on all displays on
		    1 gray summing on
		    2 monochrome display attached
		    3 default palette loading disabled
		    4 cursor emulation enabled
		    5 0 = intensity; 1 = blinking
		    6 reserved
		    7 reserved
 2Eh  3 BYTEs	reserved
 31h	BYTE	video memory available
		00h = 64K, 01h = 128K, 02h = 192K, 03h = 256K
 32h	BYTE	save pointer state flags
		bit 0 512 character set active
		    1 dynamic save area present
		    2 alpha font override active
		    3 graphics font override active
		    4 palette override active
		    5 DCC override active
		    6 reserved
		    7 reserved
 33h 13 BYTEs	reserved

Format of Static Functionality Table:
Offset	Size	Description
 00h	BYTE	modes supported #1
		bit 0 to bit 7 = 1 modes 0,1,2,3,4,5,6 supported
 01h	BYTE	modes supported #2
		bit 0 to bit 7 = 1 modes 8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh supported
 02h	BYTE	modes supported #3
		bit 0 to bit 3 = 1 modes 10h,11h,12h,13h supported
		bit 4 to bit 7 reserved
 03h  4 BYTEs	reserved
 07h	BYTE	scan lines supported
		bit 0 to bit 2 = 1 if scan lines 200,350,400 supported
 08h	BYTE	total number of character blocks available in text modes
 09h	BYTE	maximum number of active character blocks in text modes
 0Ah	BYTE	miscellaneous function flags #1
		bit 0 all modes on all displays function supported
		    1 gray summing function supported
		    2 character font loading function supported
		    3 default palette loading enable/disable supported
		    4 cursor emulation function supported
		    5 EGA palette present
		    6 color palette present
		    7 color paging function supported
 0Bh	BYTE	miscellaneous function flags #2
		bit 0 light pen supported
		    1 save/restore state function 1Ch supported
		    2 intensity blinking function supported
		    3 Display Combination Code supported
		  4-7 reserved
 0Ch	WORD	reserved
 0Eh	BYTE	save pointer function flags
		bit 0 512 character set supported
		    1 dynamic save area supported
		    2 alpha font override supported
		    3 graphics font override supported
		    4 palette override supported
		    5 DCC extension supported
		    6 reserved
		    7 reserved
 0Fh	BYTE	reserved
----------101C-------------------------------
INT 10 - VIDEO - SAVE/RESTORE VIDEO STATE (PS50+,VGA)
	AH = 1Ch
	AL = 00h return state buffer size
		Return: BX = number of 64 byte blocks needed
	     01h save video state
		ES:BX -> buffer
	     02h restore video state
		ES:BX -> buffer containing previously saved state
	CX = requested states
	     bit 0 video hardware
		 1 BIOS data areas
		 2 color registers and DAC state
	      3-15 reserved
Return: AL = 1Ch if function supported
----------103000-----------------------------
INT 10 - VIDEO - LOCATE 3270PC CONFIGURATION TABLE
	AX = 3000h
	CX = 0000h
	DX = 0000h
Return: CX:DX -> 3270PC configuration table (see below for format)
	CX:DX = 0000h:0000h if 3270PC Control Program not active

Format of 3270 PC configuration table:
Offset	Size	Description
 00h	BYTE	aspect ratio X
 01h	BYTE	aspect ratio Y
 02h	BYTE	monitor type
		00h = 5151 (mono) or 5272 (color)
		01h = 3295
		02h = 5151 or 5272 with XGA (???) graphics adapter
		03h = 5279 with 3270PC G adapter
		04h = 5379 model C01 with 3270PC GX adapter
		05h = 5379 model M01 with 3270PC GX adapter
		07h = non-3270PC with 3270 Workstation Program
		FFh = 3270PC Control Program not loaded
 03h	BYTE	reserved
 04h	BYTE	adapter ID
		00h = 5151/5272 adapter
		04h = 5151/5272 with XGA adapter
		30h = 3295 or 3270PC G/GX adapter
 05h	BYTE	reserved
 06h	BYTE	function flags 1
		bit 7: mono text, 1 page
		    6: color text, 1 page
		    5: color text, 4 pages
		    4: CGA color graphics
		    3: 720x350 two-color graphics
		    2: 360x350 four-color graphics
		    1: 720x350 eight-color graphics
 07h	BYTE	function flags 2
		bit 6: GPI graphics supported
 08h	WORD	segment address of Control Program Level table (see below)
 0Ah 10 BYTEs	reserved

Format of Control Program Level table:
Offset	Size	Description
 00h	WORD	02xxh = 3270PC Control Program v2.xx
		03xxh = 3270PC Control Program v3.xx
		04xxh = 3270 Workstation Program v1.xx
 02h	BYTE	Control Program ID (00h)
 03h 27 BYTEs	Control Program Descriptor ("IBM 3270 PC CONTROL PROGRAM")
----------1040-------------------------------
INT 10 - VIDEO - SET GRAPHICS MODE (Hercules GRAFIX)
	AH = 40h
SeeAlso: AH=41h
----------1041-------------------------------
INT 10 - VIDEO - SET TEXT MODE (Hercules GRAFIX)
	AH = 41h
SeeAlso: AH=40h
----------1042-------------------------------
INT 10 - VIDEO - CLEAR CURRENT PAGE (Hercules GRAFIX)
	AH = 42h
----------1043-------------------------------
INT 10 - VIDEO - SELECT DRAWING PAGE (Hercules GRAFIX)
	AH = 43h
	AL = page number (0,1)
SeeAlso: AH=44h,AH=45h
----------1044-------------------------------
INT 10 - VIDEO - SELECT DRAWING FUNCTION (Hercules GRAFIX)
	AH = 44h
	AL = drawing function
	    00h clear pixels
	    01h set pixels
	    02h invert pixels
SeeAlso: AH=44h,AH=46h,AH=4Ch,AH=4Dh
----------1045-------------------------------
INT 10 - VIDEO - SELECT PAGE TO DISPLAY (Hercules GRAFIX)
	AH = 45h
	AL = page number (0,1)
SeeAlso: AH=43h
----------1046-------------------------------
INT 10 - VIDEO - DRAW ONE PIXEL (Hercules GRAFIX)
	AH = 46h
	DI = x (0-720)
	BP = y (0-347)
Note:	function 44h determines operation and function 43h which page to use
SeeAlso: AH=47h,AH=4Ch,AH=4Dh
----------1047-------------------------------
INT 10 - VIDEO - FIND PIXEL VALUE (Hercules GRAFIX)
	AH = 47h
	DI = x (0-720)
	BP = y (0-347)
Return: AL = 00h pixel clear
	AL = 01h pixel set
Note:	function 43h specifies which page is used
SeeAlso: AH=46h
----------1048-------------------------------
INT 10 - VIDEO - MOVE TO POINT (Hercules GRAFIX)
	AH = 48h
	DI = x (0-720)
	BP = y (0-347)
SeeAlso: AH=49h
----------1049-------------------------------
INT 10 - VIDEO - DRAW TO POINT (Hercules GRAFIX)
	AH = 49h
	DI = x (0-720)
	BP = y (0-347)
Note:	function 48h or 49h specify first point, 44h operation and 43h page to
	  use
SeeAlso: AH=43h,AH=44h,AH=48h
----------104A-------------------------------
INT 10 - VIDEO - BLOCK FILL (Hercules GRAFIX)
	AH = 4Ah
	DI = x coordinate of lower left corner
	BP = y coordinate of lower left corner
	BX = height in pixels
	CX = width in pixels
Note:	draws a solid rectangle
SeeAlso: AH=4Eh
----------104B-------------------------------
INT 10 - VIDEO - DISPLAY CHARACTER (Hercules GRAFIX)
	AH = 4Bh
	AL = character to display
	DI = x (0-720)
	BP = y (0-347)
Note:	unlike the other BIOS character functions character position is
	  specified in pixels rather than rows and columns
----------104B-------------------------------
INT 10 - FRIEZE v7+ - API
	AH = 4Bh
	CL = function
	    00h reserved
	    01h load window
		ES:BX -> ASCIZ filename from which to read
	    02h save window
		ES:BX -> ASCIZ filename to which to write
	    07h set window size
		ES:BX -> four-WORD structure with Xmin, Ymin, Xmax, Ymax
	    09h set patterns
		ES:BX -> 16-BYTE vector of screen->printer color correspondnces
	    0Ah get patterns
		ES:BX -> 16-BYTE buffer for color correspondences
	    0Bh set mode
		AL = mode
	    0Fh get window
		ES:BX -> four-WORD buffer for Xmin, Ymin, Xmax, Ymax
	    10h set print options
		ES:BX -> printer options in same format as FRIEZE cmdline
	    14h get version
		Return: AH = major version (00h if FRIEZE version before 7)
			AL = minor version
	    15h set parameters
		ES:BX -> parameter table (see below)
	    16h get parameters
		ES:BX -> buffer for parameter table (see below)
	    17h get printer resolution
		ES:BX -> 12-WORD table for six horizontal/vertical resol pairs
	    18h reserved (v8.0 only)
Return: AX = status
	    00h successful
	    01h user aborted printout with ESC
	    02h reserved
	    03h file read error
	    04h file write error
	    05h file not found
	    06h invalid header (not an image or wrong screen mode)
	    07h file close error
	    08h disk error
	    09h printer error
	    0Ah invalid function
	    0Bh can't create file
	    0Ch wrong video mode

Format of parameter table:
Offset	Size	Description
 00h	WORD	top margin (1/100 inch)
 02h	WORD	left margin (1/100 inch)
 04h	WORD	horizontal size (1/100 inch)
 06h	WORD	vertical size (1/100 inch)
 08h	WORD	quality/draft mode
		00h draft mode
		01h quality mode
		02h use horizontal/vertical resolution for output resolution
 0Ah	WORD	printer horizontal resolution (dots per inch)
 0Ch	WORD	printer vertical resolution (dots per inch)
 0Eh	WORD	reserved (FFFFh)
Note:	any field which should remain unchanged may be filled with FFFFh
----------104C-------------------------------
INT 10 - VIDEO - DRAW ARC (Hercules GRAFIX)
	AH = 4Ch
	AL = quadrant (1 = upper right, 2 = upper left, etc)
	DI = x coordinate of center
	BP = y coordinate of center
	BX = radius
SeeAlso: AH=4Dh
----------104D-------------------------------
INT 10 - VIDEO - DRAW CIRCLE (Hercules GRAFIX)
	AH = 4Dh
	DI = x of center
	BP = y of center
	BX = radius
SeeAlso: AH=4Ch
----------104E-------------------------------
INT 10 - VIDEO - FILL AREA (Hercules GRAFIX)
	AH = 4Eh
	DI = x coordinate of an interior point
	BP = y coordinate of an interior point
Notes:	fills convex polygonal areas
	the first fill makes the figure solid, the second erases it
SeeAlso: AH=4Ah
----------104F00-----------------------------
INT 10 - VESA SuperVGA BIOS - GET SuperVGA INFORMATION
	AX = 4F00h
	ES:DI -> 256-byte buffer for SuperVGA information (see below)
Return: AL = 4Fh function supported
	AH = status
	    00h successful
	    01h failed

Format of SuperVGA information:
Offset	Size	Description
 00h  4 BYTEs	signature ('VESA')
 04h	WORD	VESA version number
 06h	DWORD	pointer to OEM name
 0Ah  4 BYTEs	capabilities
 0Eh	DWORD	pointer to list of supported VESA and OEM video modes
 12h 238 BYTEs	reserved
----------104F01-----------------------------
INT 10 - VESA SuperVGA BIOS - GET SuperVGA MODE INFORMATION
	AX = 4F01h
	CX = SuperVGA video mode
	ES:DI -> 256-byte buffer mode information (see below)
Return: AL = 4Fh function supported
	AH = status
	    00h successful
	    01h failed

Format of mode information:
Offset	Size	Description
 00h	WORD	mode attributes
		bit 0: mode supported
		bit 1: optional information available
		bit 2: BIOS output supported
		bit 3: set if color, clear if monochrome
		bit 4: set if graphics mode, clear if text mode
 02h	BYTE	window A attributes
		bit 0: exists
		bit ???: readable
		bit ???: writable
 03h	BYTE	window B attributes (as for window A)
 04h	WORD	window granularity
 06h	WORD	window size
 08h	WORD	start segment of window A
 0Ah	WORD	start segment of window B
 0Ch	DWORD	-> FAR window positioning function (equivalent to AX=4F05h)
 10h	WORD	bytes per scan line
---remainder is optional for VESA modes, needed for OEM modes---
 12h	WORD	width in pixels
 14h	WORD	height in pixels
 16h	BYTE	width of character cell in pixels
 17h	BYTE	height if character cell in pixels
 18h	BYTE	number of memory planes
 19h	BYTE	number of bits per pixel
 1Ah	BYTE	number of banks
 1Bh	BYTE	memory model type
 1Ch	BYTE	size of bank in K
----------104F02-----------------------------
INT 10 - VESA SuperVGA BIOS - SET SuperVGA VIDEO MODE
	AX = 4F02h
	BX = mode
		bit 15 set means don't clear video memory
Return: AL = 4Fh function supported
	AH = status
	    00h successful
	    01h failed
SeeAlso: AX=4F03h

Values for VESA video mode
 100h	640x400x256
 101h	640x480x256
 102h	800x600x16
 103h	800x600x256
 104h	1024x768x16
 105h	1024x768x256
 106h	1280x1024x16
 107h	1280x1024x256
----------104F03-----------------------------
INT 10 - VESA SuperVGA BIOS - GET CURRENT VIDEO MODE
	AX = 4F03h
Return: AL = 4Fh function supported
	AH = status
	    00h successful
	    01h failed
	BX = video mode
SeeAlso: AX=4F02h
----------104F04-----------------------------
INT 10 - VESA SuperVGA BIOS - SAVE/RESTORE SuperVGA VIDEO STATE
	AX = 4F04h
	DL = subfunction
	    00h get state buffer size
		Return: BX = number of 64-byte blocks needed
	    01h save video states
		ES:BX -> buffer
	    02h restore video states
		ES:BX -> buffer
	CX = flags for states to save/restore
	    bit 0: video hardware state
	    bit 1: video BIOS data state
	    bit 2: video DAC state
	    bit 3: SuperVGA state
Return: AL = 4Fh function supported
	AH = status
	    00h successful
	    01h failed
----------104F05-----------------------------
INT 10 - VESA SuperVGA BIOS - CPU VIDEO MEMORY CONTROL
	AX = 4F05h
	BH = subfunction
	    00h select video memory window
		DX = window address in video memory (in granularity units)
	    01h get video memory window
		Return: DX = window address in video memory (in gran. units)
	BL = window number
	    00h window A
	    01h window B
Return: AL = 4Fh function supported
	AH = status
	    00h successful
	    01h failed
SeeAlso: AX=4F06h
----------104F06-----------------------------
INT 10 - VESA SuperVGA BIOS 1.1 - GET/SET LOGICAL SCAN LINE LENGTH
	AX = 4F06h
	BL = 00h set scan line length
		CX = desired width in pixels
	   = 01h get scan line length
Return: AL = 4Fh if function supported
	AH = status
	    00h successful
	    01h failed
	BX = bytes per scan line
	CX = number of pixels per scan line
	DX = maximum number of scan lines
Notes:	if the desired width is not achievable, the next larger width will be
	  set
	the scan line may be wider than the visible area of the screen
	this function is valid in text modes, provided that values are
	  multiplied by the character cell width/height
SeeAlso: AX=4F01h,AX=4F05h,AX=4F07h
----------104F07-----------------------------
INT 10 - VESA SuperVGA BIOS 1.1 - GET/SET DISPLAY START
	AX = 4F07h
	BH = 00h (reserved)
	BL = 00h set display start
		CX = leftmost displayed pixel in scan line
		DX = first displayed scan line
	   = 01h get display start
		Return: BH = 00h
			CX = leftmost displayed pixel in scan line
			DX = first displayed scan line
Return: AL = 4Fh if function supported
	AH = status
	    00h successful
	    01h failed
Note:	this function is valid in text modes, provided that values are
	  multiplied by the character cell width/height
SeeAlso: AX=4F01h,AX=4F05h,AX=4F06h
----------1050-------------------------------
INT 10 - SCROLOCK.COM - INSTALLATION CHECK
	AH = 50h
Return: BX = 1954h if installed
	    AL = 00 if inactive, nonzero if active
Note:	SCROLOCK is a utility supplied with System Enhancement Associates' ARC
SeeAlso: AH=51h
----------1051-------------------------------
INT 10 - SCROLOCK.COM - ENABLE/DISABLE
	AH = 51h
	AL = state
	    00h disable
	    nonzero enable
Note:	SCROLOCK is a utility supplied with System Enhancement Associates' ARC
SeeAlso: AH=50h
----------105555-----------------------------
INT 10 - VIDEO - ATI EGA/VGA Wonder Super Switch - INSTALLATION CHECK
	AX = 5555h
Return: AX = AAAAh    if installed
	BX:CX -> ??? routine in SMS.COM resident portion
	      -> data area in VCONFIG
Note:	Super Switch (SMS.COM) is a video mode switch program supplied with
	  ATI EGA Wonder. It also maps video mode 08h to 27h or 23h.
SeeAlso: INT 10/AH=00h

Format of data area:
Offset	Size	Description
 00h	DWORD	original INT 09 vector
 04h	DWORD	original INT 10 vector
 08h	DWORD	original INT 1C vector
 0Ch	WORD	screen saver state, 0=off, 1=on
 0Eh	WORD	blanking interval in clock ticks
----------106A00-----------------------------
INT 10 - Direct Graphics Interface Standard (DGIS) - INQUIRE AVAILABLE DEVICES
	AX = 6A00h
	BX = 0000h
	CX = 0000h
	DX = buffer length (may be 0)
	ES:DI -> buffer
Return: BX = number of bytes stored in buffer
	CX = bytes required for all descriptions (0 if no DGIS)
Note:	buffer contains descriptions and addresses of DGIS-compatible
	  display(s) and printer(s)
----------106A01-----------------------------
INT 10 - DGIS - REDIRECT CHARACTER OUTPUT
	AX = 6A01h
	CX = 0000h
	ES:DI = address of device to send INT 10 output to
Return: CX = 0000h  output could not be redirected
	     else INT 10h output now routed to requested display
SeeAlso: AX=6A02h
----------106A02-----------------------------
INT 10 - DGIS - INQUIRE INT 10 OUTPUT DEVICE
	AX = 6A02h
	ES:DI = 0000h:0000h
Return: ES:DI = 0000h:0000h  if current display is non-DGIS
		else address of the current DGIS INT 10 display
SeeAlso: AX=6A01h
----------106F00-----------------------------
INT 10 - VIDEO - INSTALLATION CHECK (Video7 VGA,VEGA VGA)
	AX = 6F00h
Return: BX = 5637h ('V7') indicates Video7 VGA/VEGA VGA extensions are present
----------106F01-----------------------------
INT 10 - VIDEO - GETINFO (Video7 VGA,VEGA VGA)
	AX = 6F01h
Return: AL = monitor type code (VEGA VGA only)
	AH = status register information
	     bit  0 = display enable
			0 = display enabled
			1 = vertical or horizontal retrace in progress
	     bit  1 = light pen flip flop set
	     bit  2 = light pen switch activated
	     bit  3 = vertical sync
	     bit  4 = monitor resolution
			0 = high resolution (>200 lines)
			1 = low resolution (<=200 lines)
	     bit  5 = display type
			0 = color
			1 = monochrome
	     bits6,7= diagnostic bits
Note:	bits 0-3 are the same as the EGA/VGA status register bits 0-3
----------106F04-----------------------------
INT 10 - VIDEO - GET MODE AND SCREEN RESOLUTION (Video7 VGA, VEGA VGA)
	AX = 6F04h
Return: AL = current video mode (see AX=6F05h)
	BX = horizontal columns (text) or pixels (graphics)
	CX = vertical columns (text) or pixels (graphics)
SeeAlso: AX=6F05h
----------106F05-----------------------------
INT 10 - VIDEO - SET VIDEO MODE (Video7 VGA, VEGA EXTENDED EGA/VGA)
	AX = 6F05h
	BL = mode (graphics mode if graphics resolution listed)
		 text  pixel graphic color disp scrn  system
		 resol	box  resoltn	   page addr
	   00h-13h = standard IBM modes
	   40h = 80x43	8x8			     Video7/VEGA VGA
	   41h = 132x25 8x14			     Video7/VEGA VGA
	   42h = 132x43 8x8			     Video7/VEGA VGA
	   43h = 80x60	8x8			     Video7/VEGA VGA
	   44h = 100x60 8x8			     Video7/VEGA VGA
	   45h = 132x28 8x8			     Video7/VEGA VGA
	   60h =	     752x410  16	     Video7 VGA, VEGA VGA
	   61h =	     720x540  16	     Video7 VGA, VEGA VGA
	       =	     720x540  16	     Northgate
	   62h =	     800x600  16	     Video7 VGA, VEGA Ext EGA
	   63h =	    1024x768   2	     Video7 VGA
	   64h =	    1024x768   4	     Video7 VGA
	   65h =	    1024x768  16	     Video7 VGA, VEGA Ext EGA
	   66h =	     640x400 256	     Video7 VGA, VEGA Ext VGA
	       =	     640x400 256	     Northgate
	   67h =	     640x480 256	     Video7 VGA, VEGA Ext VGA
	   68h =	     720x540 256	     Video7 VGA, VEGA Ext VGA
	   69h =	     800x600 256	     Video7 VGA, VEGA Ext VGA
	   70h =	     752x410  16gray	     Video7 VGA, VEGA VGA
	   71h =	     720x540  16gray	     Video7 VGA, VEGA VGA
	   72h =	     800x600  16gray	     Video7 VGA
	   73h =	    1024x768   2gray	     Video7 VGA
	   74h =	    1024x768   4gray	     Video7 VGA
	   75h =	    1024x768  16gray	     Video7 VGA
	   76h =	     640x400 256gray	     Video7 VGA
	   77h =	     640x480 256gray	     Video7 VGA
	   78h =	     720x540 256gray	     Video7 VGA
	   79h =	     800x600 256gray	     (future)
SeeAlso: AH=00h,AX=0070h,AX=007Eh,AX=6F04h
----------106F06-----------------------------
INT 10 - VIDEO - SELECT AUTOSWITCH MODE (V7VGA,VEGA VGA)
	AX = 6F06h
	BL = Autoswitch mode select
	     00h select EGA/VGA-only modes
	     01h select Autoswitched VGA/EGA/CGA/MGA modes
	     02h select 'bootup' CGA/MGA modes
	BH = enable/disable (00h enable, 01h = disable selection)
----------106F07-----------------------------
INT 10 - VIDEO - GET VIDEO MEMORY CONFIGURATION (V7VGA,VEGA VGA)
	AX = 6F07h
Return: AL = 6Fh
	AH = bits 0-6 = number of 256K blocks of video memory
	     bit 7    = DRAM/VRAM (0: DRAM, 1: VRAM)
	BH = chip revision (SR8F) (S/C Chip in VEGA VGA)
	BL = chip revision (SR8E) (G/A Chip in VEGA VGA)
	CX = 0000h
SeeAlso: AH=12h/BL=10h
----------1070-------------------------------
INT 10 - VIDEO - GET VIDEO RAM ADDRESS (TANDY 1000)
	AH = 70h
Return: AX  = segment address of the following
	[BX] = offset address of green plane
	[CX] = segment address of green plane
	[DX] = segment address of red/blue plane
	       (red offset = 0, blue offset = 4000)
SeeAlso: AH=71h
----------107000BX0000-----------------------
INT 10 - Everex Extended Video BIOS - RETURN EMULATION STATUS
	AX = 7000h
	BX = 0000h
Return: CL = monitor type
	    00h mono
	    01h CGA
	    02h EGA
	    03h digital multifrequency
	    04h IBM PS/2
	    05h IBM 8514
	    06h SuperVGA
	    07h analog multifrequency
	    08h super multifrequency
	CH = feature bits
	    bits 7,6: 00 = 256K memory
		      01 = 512K memory
		      10 = 1024K
		      11 = 2048K memory
	    bit 5:    special oscillator present
	    bit 4:    VGA protect enabled
	    bit 0:    6845 emulation
	DX = video board info
	    bits 4-15: board ID model
	    bits 0-3:  board ID revision
	DI = BCD BIOS version number
----------107000BX0004-----------------------
INT 10 - Everex Extended Video BIOS - GET PAGING FUNCTION POINTER FOR CURR MODE
	AX = 7000h
	BX = 0004h
Return: ES:DI -> FAR paging function (call with DL = page to set)
Note:	the word preceding ES:DI is the length of the function in bytes, and
	  the last byte of the function is a FAR return instruction.
SeeAlso: AX=7000h/BX=0000h,AX=7000h/BX=0005h
----------107000BX0005-----------------------
INT 10 - Everex Extended Video BIOS - GET SUPPORTED MODE INFO
	AX = 7000h
	BX = 0005h
	CL = maximum number of modes to get info for
	CH = mode type to get info for (see below)
	DL = monitor type to get info for
	ES:DI -> buffer for mode info (see below)
Return: CL = total number of modes fitting criteria
	CH = size of each info record
SeeAlso: AX=7000h/BX=0000h,AX=7000h/BX=0004h

Values for mode type:
 00h all modes
 01h monochrome text modes
 02h color text modes
 03h four-color CGA graphics modes
 04h two-color CGA graphics modes
 05h 16-color graphics modes
 06h 256-color graphics modes

Format of mode information record:
Offset	Size	Description
 00h	BYTE	mode number (bit 7 set if extended mode)
 01h	BYTE	mode type (see above)
 02h	BYTE	info bits
		bits 7,6 reserved
		     5	 monochrome mode
		     4	 interlaced display
		     3	 requires special oscillator
		     2,1 memory required
			 00 = 256K
			 01 = 512K
			 10 = 1024K
			 11 = 2048K
		     0	 reserved
 03h	BYTE	font height
 04h	BYTE	text columns on screen
 05h	BYTE	text rows on screen
 06h	WORD	number of scan lines
 08h	BYTE	color information
		bits 7-4 reserved
		     3-0 bits per pixel
----------1071-------------------------------
INT 10 - VIDEO - GET INCRAM ADDRESSES (TANDY 1000)
	AH = 71h
Return: AX  = segment address of the following
	[BX] = segment address of INCRAM
	[CX] = offset address of INCRAM
SeeAlso: AH=70h
----------1072-------------------------------
INT 10 - VIDEO - SCROLL SCREEN RIGHT (TANDY 1000)
	AH = 72h
	AL = number of columns blanked at left of window
	     00h = blank entire window
	BH = attributes to be used on blank columns
	CH,CL = row, column of upper left corner of window
	DH,DL = row, column of lower right corner
SeeAlso: AH=06h,07h,73h
----------1073------------------------------
INT 10 - VIDEO - SCROLL SCREEN LEFT (TANDY 1000)
	AH = 73h
	AL = number of columns blanked at right of window
	     00h = blank entire window
	BH = attributes to be used on blank columns
	CH,CL = row, column of upper left corner of window
	DH,DL = row, column of lower right corner
SeeAlso: AH=06h,07h,72h
----------1080--DX4456-----------------------
INT 10 - VIDEO (DESQview 2.0x only) - internal - SET ??? HANDLER
	AH = 80h
	DX = 4456h ('DV')
	ES:DI -> FAR subroutine to be called on ???
Return: DS = segment of DESQview data structure for video buffer
Note:	this function is probably meant for internal use only, due to the magic
	  value required in DX
	the subroutine seems to be called when the DESQview menu is accessed;
	  on entry, AL = 3 or 4
----------1081--DX4456-----------------------
INT 10 - VIDEO (DESQview 2.0x only) - internal - GET ???
	AH = 81h
	DX = 4456h ('DV')
Return: ES = segment of DESQview data structure for video buffer
	    BYTE ES:[0] = current window number in DV 2.0x
Note:	this function is probably meant for internal use only, due to the magic
	  value required in DX
----------1082--DX4456-----------------------
INT 10 - VIDEO (DESQview 2.0x only) - internal - GET CURRENT WINDOW INFO
	AH = 82h
	DX = 4456h ('DV')
Return: DS = segment in DESQview for data structure
	     in DV 2.00,
		  BYTE DS:[0] = window number
		  WORD DS:[1] = segment of other data structure
		  WORD DS:[3] = segment of window's object handle
	ES = segment of DESQview data structure for video buffer
	AL = current window number
	AH = ???
	BL = direct screen writes
	    00h program does not do direct writes
	    01h program does direct writes, so shadow buffer not usable
	BH = ???
	CL = current video mode
	CH = ???
Note:	this function is probably meant for internal use only, due to the magic
	  value required in DX
----------10BF00-----------------------------
INT 10 - VIDEO - Compaq Portable Extensions - SELECT EXTERNAL MONITOR
	AX = BF00h
Note:	all registers preserved and the internal monitor is blanked
	the external monitor becomes the active monitor
SeeAlso: AX=BF01h
----------10BF01-----------------------------
INT 10 - VIDEO - Compaq Portable Extensions - SELECT INTERNAL MONITOR
	AX = BF01h
Note:	all registers preserved and the external monitor is blanked
	the internal monitor becomes the active monitor
SeeAlso: AX=BF00h
----------10BF02-----------------------------
INT 10 - VIDEO - Compaq Portable Extensions - SET MASTER MODE OF CURRENT CTRLR
	AX = BF02h
	BH = master mode
	    04h CGA
	    05h EGA
	    07h MDA
SeeAlso: AX=BF03h
----------10BF03-----------------------------
INT 10 - VIDEO - Compaq Portable/Systempro Extensions - GET ENVIRONMENT
	AX = BF03h
	BX = 0000h
Return: BH = active monitor
	    00h = external
	    01h = internal
	BL = master mode
	    00h = switchable VDU not present
	    04h = CGA
	    05h = EGA
	    07h = MDA
	    08h = switchable LCD controller present
	CH = 00h (reserved)
	CL = switchable VDU mode supported
	    bit  0   = CGA supported
	    bits 1,2 = reserved (1)
	    bit  3   = MDA supported
	    bits 4-7 = reserved (1)
	DH = internal monitor type
	    00h = none
	    01h = Dual-mode monitor
	    02h = 5153 RGB monitor
	    03h = Compaq Color monitor
	    04h = 640x400 flat panel
	    07h = LCD VGA
	DL = external monitor type
	    00h = none
	    01h = dual-mode monitor
	    02h = 5153 RGB monitor
	    03h = Compaq Color monitor
	    04h = 640x400 flat panel
	    05h = VGC monochrome
	    06h = VGC color
SeeAlso: AH=1Ah,AX=BF00h,AX=BF01h,AX=BF02h
----------10BF04-----------------------------
INT 10 - VIDEO - Compaq Portable Extensions - SET MODE SWITCH DELAY
	AX = BF04h
	BH = 00h enable delay
	     01h disable delay
----------10BF05-----------------------------
INT 10 - VIDEO - Compaq Systempro Extensions - ENABLE/DISABLE DISPLAY
	AX = BF05h
	BH = 00h video off
	     01h video on
----------10BF06-----------------------------
INT 10 - VIDEO - Compaq SLT/286 - READ GRAY SCALE TABLE
	AX = BF06h
	CL = address to be read from gray scale table
Return: AL = bit 3-0 - Value read from gray scale table
	CL = address to be read from gray scale table
----------10BF07-----------------------------
INT 10 - VIDEO - Compaq SLT/286 - WRITE GREY SCALE TABLE
	AX = BF07h
	CH = value to write to gray scale table
	CL = address to be written to gray scale table
----------10BF08-----------------------------
INT 10 - VIDEO - Compaq SLT/286 - WRITE COLOR MIX REGISTERS
	AX = BF08h
	CH = bits 7-4 - Green weight
	     bits 3-0 - Blue weight
	CL = bits 7-4 - unused
	     bits 3-0 - Red weight
----------10CC00-----------------------------
INT 10 - VIDEO - UltraVision - INSTALLATION CHECK
	AX = CC00h
Return: CX = ABCDh
	AL = 00h if extensions enabled
SeeAlso: AX=CC01h,AX=CC02h
----------10CC01-----------------------------
INT 10 - VIDEO - UltraVision - ENABLE EXTENSIONS
	AX = CC01h
Return: ???
SeeAlso: AX=CC02h
----------10CC02-----------------------------
INT 10 - VIDEO - UltraVision - DISABLE EXTENSIONS
	AX = CC02h
Return: ???
SeeAlso: AX=CC01h
----------10CD-------------------------------
INT 10 - VIDEO - UltraVision - SET VIDEO MODE
	AH = CDh
	AL = mode number (<> 04h)
Return: ???
SeeAlso: AX=CD04h
----------10CD04-----------------------------
INT 10 - VIDEO - UltraVision - GET VIDEO MODE
	AX = CD04h
Return: AL = mode number
SeeAlso: AH=CCh,AH=CDh
----------10EF-------------------------------
INT 10 - VIDEO - MSHERC.COM - INSTALLATION CHECK???
	AH = EFh
Return: DL = video adapter type
	    00h original Hercules
	    01h ???  \ one is probably Hercules Plus, the other
	    02h ???  / Hercules InColor
	    FFh non-Hercules 
	DH = ???
Note:	MSHERC.COM is a support program for the Microsoft Quick languages which
	  makes their graphics libraries compatible with a Hercules card by
	  adding video modes 08h and 88h, and supporting text in the new
	  graphics modes.  While in mode 08h or 88h, INT 10 supports the
	  Hercules card much like a CGA.
----------10F0-------------------------------
INT 10 - Microsoft Mouse driver EGA support - READ ONE REGISTER
	AH = F0h
	BL = register number
	BH = 00h
	DX = group index
	    Pointer/data chips
	       00h CRT Controller (25 reg) 3B4h mono modes, 3D4h color modes
	       08h Sequencer (5 registers) 3C4h
	       10h Graphics Controller (9 registers) 3CEh
	       18h Attribute Controller (20 registers) 3C0h
	    Single registers
	       20h Miscellaneous Output register 3C2h
	       28h Feature Control register (3BAh mono modes, 3DAh color modes)
	       30h Graphics 1 Position register 3CCh
	       38h Graphics 2 Position register 3CAh
Return: BL = data
Note:	also present in OS/2 compatibility box
SeeAlso: AH=F1h,F2h
----------10F1-------------------------------
INT 10 - Microsoft Mouse driver EGA support - WRITE ONE REGISTER
	AH = F1h
	DX = group index (see AH=F0h)
	    if single register:
		BL = value to write
	    otherwise
		BL = register number
		BH = value to write
Return: BL = data
Note:	also present in OS/2 compatibility box
SeeAlso: AH=F0h,F3h
----------10F2-------------------------------
INT 10 - Microsoft Mouse driver EGA support - READ REGISTER RANGE
	AH = F2h
	CH = starting register number
	CL = Number of registers (>1)
	DX = group index
	     00h CRTC (3B4h mono modes, 3D4h color modes)
	     08h Sequencer 3C4h
	     10h Graphics Controller 3CEh
	     18h Attribute Controller 3C0h
	ES:BX -> buffer, CL bytes
Note:	also present in OS/2 compatibility box
SeeAlso: AH=F0h,F3h
----------10F3-------------------------------
INT 10 - Microsoft Mouse driver EGA support - WRITE REGISTER RANGE
	AH = F3h
	CH = starting register
	CL = number of registers (>1)
	DX = group index (see AH=F2h)
	ES:BX -> buffer, CL bytes
Note:	also present in OS/2 compatibility box
SeeAlso: AH=F1h,F2h
----------10F4-------------------------------
INT 10 - Microsoft Mouse driver EGA support - READ REGISTER SET
	AH = F4h
	CX = number of registers to read (>1)
	ES:BX -> table of records (see below)
Return: register values in table filled in
Note:	also present in OS/2 compatibility box
SeeAlso: AH=F0h,F2h,F5h

Format of entries in table of register records:
Offset	Size	Description
 00h	WORD	group index
		Pointer/data chips
		   00h CRTC (3B4h mono modes, 3D4h color modes)
		   08h Sequencer 3C4h
		   10h Graphics Controller 3CEh
		   18h Attribute Controller 3C0h
		Single registers
		   20h Miscellaneous Output register 3C2h
		   28h Feature Control register (3BAh mono modes, 3DAh color)
		   30h Graphics 1 Position register 3CCh
		   38h Graphics 2 Position register 3CAh
 02h	BYTE	register number (0 for single registers)
 03h	BYTE	register value
----------10F5-------------------------------
INT 10 - Microsoft Mouse driver EGA support - WRITE REGISTER SET
	AH = F5h
	CX = number of registers to write (>1)
	ES:BX -> table of records (see AH=F4h)
Note:	also present in OS/2 compatibility box
SeeAlso: AH=F1h,F3h,F4h
----------10F6------------------------------
INT 10 - Microsoft Mouse driver EGA support - REVERT TO DEFAULT REGISTERS
	AH = F6h
Note:	also present in OS/2 compatibility box
SeeAlso: AH=F7h
----------10F7------------------------------
INT 10 - Microsoft Mouse driver EGA support - DEFINE DEFAULT REGISTER TABLE
	AH = F7h
	DX = port number
	   Pointer/data chips
	      00h CRTC (3B4h mono modes, 3D4h color modes)
	      08h Sequencer 3C4h
	      10h Graphics Controller 3CEh
	      18h Attribute Controller 3C0h
	   Single registers
	      20h Miscellaneous Output register 3C2h
	      28h Feature Control register (3BAh mono modes, 3DAh color modes)
	      30h Graphics 1 Position register 3CCh
	      38h Graphics 2 Position register 3CAh
	ES:BX -> table of one-byte entries, one byte to be written to each
		 register
Note:	also present in OS/2 compatibility box
SeeAlso: AH=F6h
----------10FA------------------------------
INT 10 - Microsoft Mouse driver EGA support - INTERROGATE DRIVER
	AH = FAh
	BX = 0000h
Return: BX = 0000h if mouse driver not present
	ES:BX -> EGA Register Interface version number, if present:
	    byte 0 = major release number
	    byte 1 = minor release number
Note:	also present in OS/2 compatibility box
----------10FA------------------------------
INT 10 - FASTBUFF.COM - INSTALLATION CHECK
	AH = FAh
Return: AX = 00FAh if installed
	    ES = segment of resident code
Note:	FASTBUFF.COM is a keyboard speedup/screen blanking utility by David
	  Steiner
----------10FE------------------------------
INT 10 - VIDEO (TopView) - GET VIDEO BUFFER
	AH = FEh
	ES:DI = segment:offset of assumed video buffer
Return: ES:DI = segment:offset of actual video buffer
Notes:	if no multitasker is installed, ES:DI is returned unchanged
	TopView requires a call to AH=FFh to notify if that the screen has
	  changed; DESQview will check for changes itself until the first call
	  to AH=FFh
SeeAlso: INT 15/AX=1024h, INT 21/AH=2Bh"DESQview"
----------10FF-------------------------------
INT 10 - VIDEO (TopView) - UPDATE REAL SCREEN FROM VIDEO BUFFER
	AH = FFh
	CX = number of sequential characters that have been modified
	DI = offset of first character that has been modified
	ES = segment of video buffer
Notes:	avoid CX=0000h
	DESQview will discontinue the automatic screen updating initiated by
	  AH=FEh after this call
----------10FF00-----------------------------
INT 10 - CARBON COPY PLUS 5.0 - CHECK IF CC CONNECTED TO CCHELP
	AX = FF00h
Return: BL = 00h not connected
	   = 01h connected
----------10FF01-----------------------------
INT 10 - CARBON COPY PLUS 5.0 - DISCONNECT AND RESET LINE
	AX = FF01h
----------10FF02-----------------------------
INT 10 - CARBON COPY PLUS 5.0 - GET LAST PHONE NUMBER DIALED
	AX = FF02h
Return: ES:DI -> ASCIZ phone number
----------11---------------------------------
INT 11 - 80486 internal hardware - ALIGNMENT CHECK
   Bit AC in the EFLAGS register enables this interrupt on a memory reference
     on a mis-aligned address when in privilege mode 3.
----------11---------------------------------
INT 11 - EQUIPMENT DETERMINATION
Return: AX = equipment flag bits
	    0	  diskette installed
	    1	  8087 present
	    2	  mouse installed (PS2 only)
	    2,3   number of 16K banks of RAM on motherboard (PC only)
		  number of 64K banks of RAM on motherboard (XT only)
		  always = 11 on AT and above
	    4,5   initial video mode
		  01 = 40x25 color
		  10 = 80x25 color
		  11 = 80X25 IBM monochrome
	    6,7   number of diskette drives (only if bit 0 = 1)
		  00 = 1, 01 = 2, 10 = 3, 11 = 4
	    8	  0 = DMA present
		  1 = no DMA on system (PCjr, some Tandy 1000s, 1400LT)
	    9-11  number of RS232 cards
	    12	  game I/O attached
	    13	  serial printer installed (PCjr)
		  internal modem installed (PC/Convertible)
	    14,15 number of printers
---Compaq and many other 386/486 machines--
	EAX bit 23: page tables set so that Weitek coprocessor addressable in
			real mode
	    bit 24: Weitek math coprocessor present
---Compaq Systempro
	EAX bit 25: internal DMA parallel port available
		26: IRQ for internal DMA parallel port (if bit 25 set)
		    0 = IRQ5
		    1 = IRQ7
	     27,28: parallel port DMA channel
	     	    00 DMA channel 0
		    01 DMA channel 0 ???
		    10 reserved
		    11 DMA channel 3
SeeAlso: INT 12
----------11FFFECXFFFE-----------------------
INT 11 - BACK&FORTH API
	AX = FFFEh
	CX = FFFEh
	BX = function
	    00h installation check
		Return: AX = 0001h BNFHIGH and BNFLOW both loaded
			   = 0003h only BNFHIGH loaded
			   else neither loaded
	    01h ???
		Return: DX:AX -> ???
	    02h ???
	    03h ???
	    04h ???
	    05h ??? switches current PSP segment and stack if BNFLOW has not
		    yet announced itself installed
	    06h ???
		Return: AX = ???
----------12---------------------------------
INT 12 - MEMORY SIZE
Return: AX = number of contiguous 1K blocks of memory
SeeAlso: INT 11
----------1300-------------------------------
INT 13 - DISK - RESET DISK SYSTEM
	AH = 00h
	DL = drive (if bit 7 is set both hard disks and floppy disks reset)
Note:	forces controller to recalibrate drive heads (seek to track 0)
SeeAlso: AH=0Dh, INT 21/AH=0Dh
----------1301-------------------------------
INT 13 - DISK - STATUS OF DISK SYSTEM
	AH = 01h
Return: AH = status of last disk operation
	    00h = successful completion
	    01h = bad command
	    02h = address mark not found
	    03h = write attempted on write-protected disk
	    04h = sector not found
	    05h = reset failed (hard disk)
	    06h = diskette changed
	    07h = parameter act. failed (hard disk)
	    08h = DMA overrun (floppy disk)
	    09h = DMA across 64K boundary
	    0Ah = bad sector detected (hard disk)
	    0Bh = bad track detected (hard disk)
	    0Ch = unsupported track
	    0Dh = invalid number of sectors on format (hard disk)
	    0Eh = control data address mark detected (hard disk)
	    0Fh = DMA arbitration error (hard disk)
	    10h = bad CRC/ECC
	    11h = data ECC corrected (hard disk)
	    20h = controller failure
	    40h = seek failed
	    80h = time out
	    AAh = drive not ready (hard disk)
	    BBh = undefined error (hard disk)
	    CCh = write fault (hard disk)
	    E0h = status register error (hard disk)
	    FFh = sense operation failed (hard disk)
----------1302-------------------------------
INT 13 - DISK - READ SECTORS INTO MEMORY
	AH = 02h
	AL = number of sectors to read
	CH = track (for hard disk, bits 8,9 in high bits of CL)
	CL = sector (01h to number of sectors/track for drive)
	DH = head
	DL = drive
	ES:BX -> buffer to fill
Return: CF set on error
	AH = status (see AH=01h)
	AL = number of sectors read
Notes:	results undefined if attempting to read zero sectors
	AWARD AT BIOS extended to handle more than 1024 cylinders by placing
	  bits 10 and 11 of the cylinder number into bits 6 and 7 of DH
	apparently, the AMI BIOS also follows this convention
SeeAlso: AH=03h,AH=0Ah
----------1303-------------------------------
INT 13 - DISK - WRITE SECTORS FROM MEMORY
	AH = 03h
	AL = number of sectors to write
	CH = track (if hard disk, bits 8,9 in high bits of CL)
	CL = sector (if hard disk, high two bits are high bits of track #)
	DH = head
	DL = drive
	ES:BX -> buffer
Return: CF set on error
	AH = status (see AH=01h)
	AL = number of sectors written
Notes:	results undefined if attempting to write zero sectors
	AWARD AT BIOS extended to handle more than 1024 cylinders by placing
	  bits 10 and 11 of the cylinder number into bits 6 and 7 of DH
	apparently, the AMI BIOS also follows this convention
SeeAlso: AH=02h,AH=0Bh
----------1304-------------------------------
INT 13 - DISK - VERIFY SECTORS
	AH = 04h
	AL = number of sectors to verify
	CH = track (for hard disk, bits 8,9 in high bits of CL)
	CL = sector (01h to number of sectors per track for drive)
	DH = head
	DL = drive
Return: CF set on error
	AH = status (see AH=01h)
	AL = number of sectors verified
Notes:	AWARD AT BIOS extended to handle more than 1024 cylinders by placing
	  bits 10 and 11 of the cylinder number into bits 6 and 7 of DH
	apparently, the AMI BIOS also follows this convention
SeeAlso: AH=02h
----------1305-------------------------------
INT 13 - FLOPPY - FORMAT TRACK
	AH = 05h
	AL = number of sectors to create on this track
	CH = track
	CL = sector (01h to number of sectors per track for drive)
	DH = head
	DL = drive
	ES:BX -> array of 4-byte address fields
		BYTE	track
		BYTE	head
		BYTE	sector
		BYTE	bytes/sector  0=128, 1=256, 2=512, 3=1024
Return: CF set if error occurred
	AH = status code (see AH=01h)
----------1305-------------------------------
INT 13 - FIXED DISK - FORMAT TRACK
	AH = 05h
	AL = interleave value (XT only)
	ES:BX = 512-byte format buffer
		the first 2*(sectors/track) bytes contain F,N for each sector
		   F = 00 for good sector, 80h for bad sector
		   N = sector number
	CH = cylinder number (bits 8,9 in high bits of CL)
	CL = sector number (01h to number of sectors per track for drive)
	DH = head
	DL = drive
Return: AH = status code (see AH=01h)
Notes:	AWARD AT BIOS extended to handle more than 1024 cylinders by placing
	  bits 10 and 11 of the cylinder number into bits 6 and 7 of DH
	apparently, the AMI BIOS also follows this convention
SeeAlso: AH=06h,07h,1Ah
----------1306-------------------------------
INT 13 - FIXED DISK - FORMAT TRACK AND SET BAD SECTOR FLAGS (XT,PORT)
	AH = 06h
	AL = interleave value
	CH = cylinder number (bits 8,9 in high bits of CL)
	CL = sector number
	DH = head
	DL = drive
Return: AH = status code (see AH=01h)
Notes:	AWARD AT BIOS extended to handle more than 1024 cylinders by placing
	  bits 10 and 11 of the cylinder number into bits 6 and 7 of DH
	apparently, the AMI BIOS also follows this convention
----------1307-------------------------------
INT 13 - FIXED DISK - FORMAT DRIVE STARTING AT GIVEN TRACK (XT,PORT)
	AH = 07h
	AL = interleave value (XT only)
	ES:BX = 512-byte format buffer (see AH=05h)
	CH = cylinder number (bits 8,9 in high bits of CL)
	CL = sector number
	DH = head
	DL = drive
Return: AH = status code (see AH=01h)
Note:	AWARD AT BIOS extended to handle more than 1024 cylinders by placing
	  bits 10 and 11 of the cylinder number into bits 6 and 7 of DH
	apparently, the AMI BIOS also follows this convention
SeeAlso: AH=1Ah
----------1308-------------------------------
INT 13 - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
	AH = 08h
	DL = drive number
Return: CF set on error
	AH = status code (see AH=01h)
	BL = drive type (see AH=17h) (AT/PS2 floppies only)
	DL = number of consecutive acknowledging drives
	DH = maximum value for head number
	CL = maximum value for sector number (bits 0-5)
	CH = maximum value for cylinder number (highest bits in bits 6,7 of CL)
	ES:DI -> drive parameter table
SeeAlso: INT 1E,INT 41
----------1309-------------------------------
INT 13 - FIXED DISK - INITIALIZE TWO FIXED DISK BASE TABLES (XT,AT,XT286,PS)
	AH = 09h
Return: CF set on error
	AH = status code (see AH=01h)
	INT 41h points to table for drive 0
	INT 46h points to table for drive 1
----------130A-------------------------------
INT 13 - FIXED DISK - READ LONG (XT,AT,XT286,PS)
	AH = 0Ah
	DL = drive ID
	DH = head
	CH = cylinder (bits 8,9 in high bits of CL)
	CL = sector (01h to number of sectors per track for drive)
	ES:BX -> buffer to fill
Return: CF set on error
	AH = status code (see AH=01h)
	AL = number of sectors read
Note:	used for diagnostics only on PS/2 systems
SeeAlso: AH=02h,AH=0Bh
----------130B-------------------------------
INT 13 - FIXED DISK - WRITE LONG (XT,AT,XT286,PS)
	AH = 0Bh
	DL = drive ID
	DH = head
	CH = cylinder (bits 8,9 in high bits of CL)
	CL = sector (01h to number of sectors per track for drive)
	ES:BX -> buffer containing data
Return: CF set on error
	AH = status code (see AH=01h)
	AL = number of sectors written
Note:	used for diagnostics only on PS/2 systems
SeeAlso: AH=03h,AH=0Ah
----------130C-------------------------------
INT 13 - FIXED DISK - SEEK TO CYLINDER (XT,AT,XT286,PS)
	AH = 0Ch
	DL = drive ID
	DH = head
	CH = cylinder (bits 8,9 in high bits of CL)
Return: CF set on error
	AH = status code (see AH=01h)
----------130D-------------------------------
INT 13 - FIXED DISK - ALTERNATE DISK RESET (XT,AT,XT286,PS)
	AH = 0Dh
	DL = drive ID
Return: CF set on error
	AH = status code (see AH=01h)
Note:	not for PS/2 ESDI drives
SeeAlso: AH=00h,INT 21/AH=0Dh
----------130E-------------------------------
INT 13 - FIXED DISK - READ SECTOR BUFFER (XT,PS)
	AH = 0Eh
	ES:BX -> buffer
Return: CF set on error
	AH = status code (see AH=01h)
Notes:	transfers controller's sector buffer.  No data is read from the drive
	used for diagnostics only on PS/2 systems
SeeAlso: AH=0Ah
----------130F-------------------------------
INT 13 - FIXED DISK - WRITE SECTOR BUFFER (XT,PS)
	AH = 0Fh
	ES:BX -> buffer
Return: CF set on error
	AH = status code (see AH=01h)
Notes:	should be called before formatting to initialize the controller's
	  sector buffer.
	used for diagnostics only on PS/2 systems
SeeAlso: AH=0Bh
----------1310-------------------------------
INT 13 - FIXED DISK - TEST FOR DRIVE READY (XT,AT,XT286,PS)
	AH = 10h
	DL = drive ID
Return: CF set on error
	AH = status code (see AH=01h)
----------1311-------------------------------
INT 13 - FIXED DISK - RECALIBRATE DRIVE (XT,AT,XT286,PS)
	AH = 11h
	DL = drive ID
Return: CF set on error
	AH = status code (see AH=01h)
SeeAlso: AH=19h"FIXED DISK"
----------1312-------------------------------
INT 13 - FIXED DISK - CONTROLLER RAM DIAGNOSTIC (XT,PS)
	AH = 12h
Return: CF set on error
	AH = status code (see AH=01h)
Note:	used for diagnostics only on PS/2 systems
SeeAlso: AH=13h,AH=14h
----------1312-------------------------------
INT 13 - Future Domain SCSI CONTROLLER - STOP SCSI DISK
	AH = 12h
	DL = hard drive ID
Return: CF set on error
	AH = status code (see AH=01h)
Notes:	available at least on the TMC-870 8-bit SCSI controller BIOS v6.0A
	if the given drive is a SCSI device, the SCSI Stop Unit command is sent
	  and either "Disk prepared for shipping" or "Disk Stop command failed"
	  is displayed
----------1313-------------------------------
INT 13 - FIXED DISK - DRIVE DIAGNOSTIC (XT,PS)
	AH = 13h
Return: CF set on error
	AH = status code (see AH=01h)
Note:	used for diagnostics only on PS/2 systems
SeeAlso: AH=12h,AH=14h
----------1314-------------------------------
INT 13 - FIXED DISK - CONTROLLER DIAGNOSTICS (XT,AT,XT286,PS)
	AH = 14h
Return: CF set on error
	AH = status code (see AH=01h)
Note:	used for diagnostics only on PS/2 systems
SeeAlso: AH=12h,AH=13h
----------1315-------------------------------
INT 13 - DISK - GET TYPE (AT,XT2,XT286,CONV,PS)
	AH = 15h
	DL = drive ID
Return: CF set on error
	AH = disk type
	    00h = disk not there
	    01h = floppy, no change detection present
	    02h = floppy with change detection
	    03h = fixed disk
	       CX:DX = number of 512-byte sectors
SeeAlso: AH=17h,AH=19h"SCSI"
----------1316-------------------------------
INT 13 - FLOPPY DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)
	AH = 16h
	DL = drive to check
Return: AH = disk change status
	    00h = no disk change
	    06h = disk changed
----------1317-------------------------------
INT 13 - DISK - SET TYPE (AT,XT2,XT286,CONV,PS)
	AH = 17h
	AL = disk type
	    00h = no disk
	    01h = regular disk in regular drive
	    02h = regular disk in high-capacity drive
	    03h = high-capacity disk in high-capacity drive
	    04h = 720K disk in 720K drive
	DL = drive ID
Note:	I assume that 05h and 06h are 720K in 1.44M and 1.44M in 1.44M
SeeAlso: AH=15h
----------1318-------------------------------
INT 13 - DISK - SET MEDIA TYPE FOR FORMAT (AT model 3x9,XT2,XT286,PS)
	AH = 18h
	DL = drive number
	CH = lower 8 bits of number of tracks
	CL = sectors per track (bits 0-5)
	     top 2 bits of number of tracks (bits 6,7)
Return: AH = 00h  requested combination supported
	     01h  function not available
	     0Ch  not supported or drive type unknown
	     80h  there is no disk in the drive
	ES:DI -> 11-byte parameter table
SeeAlso: AH=05h,AH=07h,AH=17h
----------1318-------------------------------
INT 13 - Future Domain SCSI BIOS - GET SCSI CONTROLLER INFORMATION
	AH = 18h
	DL = hard drive ID
Return: CF set on error
	    AH = status code (see AH=01h)
	CF clear if successful
	    AX = 4321h (magic number???)
	    BH = number of SCSI drives connected
	    BL = SCSI device number for specified drive
	    CX = 040Ah (magic number???)
Note:	also sets an internal flag (non-resettable) which prevents some
	  controller messages from being displayed and allows writes to
	  removable devices
SeeAlso: AH=1Bh"SCSI"
----------1319-------------------------------
INT 13 - FIXED DISK - PARK HEADS (XT286,PS)
	AH = 19h
	DL = drive
Return: CF set on error
	AH = status (see AH=01h)
SeeAlso: AH=11h
----------1319-------------------------------
INT 13 - Future Domain SCSI CONTROLLER - REINITIALIZE DRIVE
	AH = 19h
	DL = hard drive ID
Return: CF set on error
	    AH = status code (see AH=01h)
	CF clear if successful
	    AH = disk type (03h = fixed disk)
	    CX:DX = number of 512-byte sectors
Notes:	sends SCSI Read Capacity command to get number of logical blocks and
	  adjusts the result for 512-byte sectors
	displays either "Error in Read Capacity Command" or "nnn Bytes per
	  sector" (nnn=256 or 512, the only sizes supported in the translation
	  code)
	should probably be called when a removable device has its media changed
	returns the same values as AH=15h
SeeAlso: AH=15h,AH=1Ah
----------131A-------------------------------
INT 13 - ESDI FIXED DISK - FORMAT UNIT (PS)
	AH = 1Ah
	AL = defect table count
	CL = format modifiers
	    bit 4: generate periodic interrupt
	    bit 3: perform surface analysis
	    bit 2: update secondary defect map
	    bit 1: ignore secondary defect map
	    bit 0: ignore primary defect map
	DL = drive
	ES:BX -> defect table
Return: CF set on error
	AH = status (see AH=01h)
Note:	if periodic interrupt selected, INT 15h/AH=0Fh is called after each
	  cylinder is formatted
SeeAlso: AH=07h, INT 15/AH=0Fh
----------131A-------------------------------
INT 13 - Future Domain SCSI CONTROLLER - GET SCSI PARTIAL MEDIUM CAPACITY
	AH = 1Ah
	CH = track (bits 8,9 in high bits of CL)
	CL = sector (01h to number of sectors/track for drive)
	DH = head
	DL = hard drive ID
Return: CF set on error
	AH = status code (see AH=01h)
	CX:DX = logical block number of last quickly-accessible block after
		given block
Note:	sends SCSI Read Capacity command with the PMI bit set to obtain the
	  logical block address of the last block after which a substantial
	  delay in data transfer will be encountered (usually the last block
	  on the current cylinder).  No translation to 512 byte sectors is
	  performed on the result if data is stored on the disk in other than
	  512 byte sectors.
SeeAlso: AH=15h,AH=19h"SCSI"
----------131B-------------------------------
INT 13 - ESDI FIXED DISK - GET MANUFACTURING HEADER
	AH = 1Bh
	AL = number of record
	DL = drive
	ES:BX -> buffer for manufacturing header (defect list)
Return: CF set on error
	    AH = status
Note:	manufacturing header format (Defect Map Record format) can be found
	  in IBM 70MB, 115MB Fixed Disk Drives Technical Reference
----------131B-------------------------------
INT 13 - Future Domain SCSI CONTROLLER - GET POINTER TO SCSI DISK INFO BLOCK
	AH = 1Bh
	DL = hard drive ID
Return: CF set on error
	    AH = status code (see AH=01h)
	CF clear if successful
	    ES:BX -> SCSI disk information block
Note:	also sets a non-resettable flag which prevents some controller messages
	  from being displayed
SeeAlso: AH=18h"SCSI",AH=1Ch"SCSI"

Format of SCSI disk information block:
Offset	Size	Description
 00h	BYTE	drive physical information
		bit 0: ???
		bit 1: device uses parity
		bit 2: 256 bytes per sector instead of 512
		bit 3: don't have capacity yet???
		bit 4: disk is removable
		bit 5: logical unit number is not present
 01h	WORD	translated number of cylinders
 03h	BYTE	translated number of heads
 04h	BYTE	translated number of sectors per track (17, 34, or 63)
 05h	BYTE	drive address
		bits 0-2: logical unit number
		bits 3-5: device number
 06h	BYTE	01h at initialization
 07h	BYTE	sense code byte 00h, or extended sense code byte 0Ch
 08h	BYTE	00h
 09h	BYTE	00h or extended sense code byte 02h (sense key)
 0Ah	BYTE	00h
 0Bh 10 BYTEs	copy of Command Descriptor Block (CDB)
 15h	DWORD	translated number of sectors on device
----------131C-------------------------------
INT 13 - Future Domain SCSI CONTROLLER - GET POINTER TO FREE CONTROLLER RAM
	AH = 1Ch
	DL = hard drive ID (any valid SCSI hard disk)
Return: CF set on error
	    AH = status code (see AH=01h)
	CF clear if successful
	    ES:BX -> first byte of free RAM on controller
Notes:	the Future Domain TMC-870 contains 1024 bytes of RAM at offsets 1800h
	  to 1BFFh on-bard the controller for storing drive information and
	  controller status; ES:BX points to the first byte available for other
	  uses
	ES contains the segment at which the controller resides; the
	  controller's two memory-mapped I/O ports are at offsets 1C00h, 1E00h
SeeAlso: AH=1Bh"SCSI"
----------131C0A-----------------------------
INT 13 - ESDI FIXED DISK - GET DEVICE CONFIGURATION
	AX = 1C0Ah
	DL = drive
	ES:BX -> buffer for device configuration (drive physical parameter)
Return: CF set on error
	    AH = status
Note:	device configuration format can be found in IBM ESDI Fixed Disk Drive
	  Adapter/A Technical Reference
----------131C0B-----------------------------
INT 13 - ESDI FIXED DISK - GET ADAPTER CONFIGURATION
	AX = 1C0Bh
	ES:BX -> buffer for adapter configuration
Return: CF set on error
	    AH = status
SeeAlso: AX=1C0Ch
----------131C0C-----------------------------
INT 13 - ESDI FIXED DISK - GET POS INFORMATION
	AX = 1C0Ch
	ES:BX -> POS information
Return: CF set on error
	    AH = status
SeeAlso: AX=1C0Bh
----------131C0E-----------------------------
INT 13 - ESDI FIXED DISK - TRANSLATE RBA TO ABA
	AX = 1C0Eh
	CH = low 8 bits of cylinder number
	CL = sector number, high two bits of cylinder number in bits 6 and 7
	DH = head number
	DL = drive number
	ES:BX -> ABA number
Return: CF set on error
	    AH = status
Note:	ABA (absolute block address) format can be found in IBM ESDI Adapter
	  Technical Reference by using its Device Configuration Status Block
----------131D-------------------------------
INT 13 - IBMCACHE.SYS - CACHE STATUS
	AH = 1Dh
	AL = subfunction
	    01h get status record
		DL = drive???
		Return: ES:BX -> status record
			CF set on error
			    AH = error code
	    02h set cache status
		ES:BX -> status record
		DL = drive???
		Return: CF set on error

Format of status record:
Offset	Size	Description
 00h	DWORD	total number of read requests
 04h	DWORD	total number of hits
 08h	DWORD	number of physical disk reads
 0Ch	DWORD	total number of sectors requested by physical disk reads
 10h  6 bytes	???
 16h	DWORD	pointer to start of error list
 1Ah	DWORD	pointer to end of error list
 1Eh	WORD	???
 20h	BYTE	using extended memory if nonzero
 21h	BYTE	???
 22h  4 BYTEs	ASCII version number
 26h	WORD	cache size in K
 28h	WORD	sectors per page

Format of error list:
Offset	Size	Description
 00h	DWORD	relative block address of bad page
 04h	BYTE	drive
 05h	BYTE	sector bit-map
 06h	WORD	next error
----------1320-------------------------------
INT 13 - DISK - ??? (Western Digital "Super BIOS")
	AH = 20h
	???
Return: ???
Note:	seems to return some kind of status
----------1320FF-----------------------------
INT 13 - QCACHE - DISMOUNT
	AX = 20FFh
Return: ???
----------1321-------------------------------
INT 13 - QCACHE - FLUSH CACHE
	AH = 21h
Return: ???
SeeAlso: AH=25h,AH=2Eh
----------1322-------------------------------
INT 13 - QCACHE - ENABLE/DISABLE CACHE
	AH = 22h
	AL = 00h disable cache
	     01h enable cache
----------1324-------------------------------
INT 13 - QCACHE - SET SECTORS
	AH = 24h
	BX = number of sectors
Return: ???
----------1325-------------------------------
INT 13 - QCACHE - SET FLUSH INTERVAL
	AH = 25h
	BC = interval
Return: ???
SeeAlso: AH=21h,AH=2Eh
----------1327-------------------------------
INT 13 - QCACHE - INSTALLATION CHECK
	AH = 27h
	BX = 0000h
Return: BX nonzero if installed
----------132A-------------------------------
INT 13 - QCACHE - SET BUFFER SIZE
	AH = 2Ah
	AL = buffer size
Return: ???
----------132C-------------------------------
INT 13 - QCACHE - SET BUFFERED WRITES
	AH = 2Ch
	AL = state
	    00h disable
	    01h enable
Return: ???
SeeAlso: AH=2Dh
----------132D-------------------------------
INT 13 - QCACHE - SET BUFFERED READ
	AH = 2Dh
	AL = state
	    00h disable
	    01h enable
Return: ???
SeeAlso: AH=2Ch
----------132E-------------------------------
INT 13 - QCACHE - SET FLUSH COUNT
	AH = 2Eh
	BX = flush count
Return: ???
SeeAlso: AH=21h,AH=25h
----------1330-------------------------------
INT 13 - QCACHE - GET INFO
	AH = 30h
	AL = what to get
	    00h system info
	    01h drive info
	DS:DX -> buffer for info
Return: ???
----------1370-------------------------------
INT 13 - Priam EDVR.SYS DISK PARTITIONING SOFTWARE???
	AH = 70h
	???
Return: ???
Note:	Priam's EDISK.EXE (FDISK replacement) and EFMT.EXE (low-level
	  formatting program) make this call, presumably to EDVR.SYS (the
	  partitioning driver)
SeeAlso: AH=ADh
----------1381--SI4358-----------------------
INT 13 - Super PC Kwik/PC-Cache 5.5 - ???
	AH = 81h
	SI = 4358h
	???
Return: ???
Note:	PC Tools PC Cache 5.5 is an OEM version of Super PC Kwik, and thus
	  supports this call
----------1382--SI4358-----------------------
INT 13 - Super PC Kwik/PC-Cache 5.5 - ???
	AH = 82h
	SI = 4358h
	???
Return: ???
Note:	PC Tools PC Cache 5.5 is an OEM version of Super PC Kwik, and thus
	  supports this call
----------1383--SI4358-----------------------
INT 13 - Super PC Kwik/PC-Cache 5.5 - ???
	AH = 83h
	SI = 4358h
	???
Return: ???
Note:	PC Tools PC Cache 5.5 is an OEM version of Super PC Kwik, and thus
	  supports this call
----------1384--SI4358-----------------------
INT 13 - Super PC Kwik/PC-Cache 5.5 - ???
	AH = 84h
	SI = 4358h
	???
Return: ???
Note:	PC Tools PC Cache 5.5 is an OEM version of Super PC Kwik, and thus
	  supports this call
----------1385--SI4358-----------------------
INT 13 - Super PC Kwik/PC-Cache 5.5 - ???
	AH = 85h
	SI = 4358h
	???
Return: ???
Note:	PC Tools PC Cache 5.5 is an OEM version of Super PC Kwik, and thus
	  supports this call
----------138EED-----------------------------
INT 13 - HyperDisk 4.01 - ???
	AX = 8EEDh
	???
Return: ???
Note:	HyperDisk is a shareware disk cache by Roger Cross
SeeAlso: AX=8EEEh,AX=8EEFh,AH=EEh
----------138EEE-----------------------------
INT 13 - HyperDisk 4.01 - ???
	AX = 8EEEh
Return: CF set
	AX = CS of HyperDisk resident code
	???
SeeAlso: AX=8EEDh,AX=8EEFh,AH=EEh
----------138EEF-----------------------------
INT 13 - HyperDisk 4.01 - ???
	AX = 8EEFh
	???
Return: CF set
	AX = CS of HyperDisk resident code
	???
SeeAlso: AX=8EEDh,AX=8EEEh,AH=EEh
----------13A0--SI4358-----------------------
INT 13 - Super PC Kwik - GET RESIDENT CODE SEGMENT
	AH = A0h
	SI = 4358h
	???
Return: AX = segment of resident code
	???
Note:	PC Tools PC Cache 5.5 is an OEM version of Super PC Kwik, and thus
	  supports this call
----------13A1--SI4358-----------------------
INT 13 - Super PC Kwik - FLUSH CACHE
	AH = A1h
	SI = 4358h
	???
Return: ???
Note:	PC Tools PC Cache 5.5 is an OEM version of Super PC Kwik, and thus
	  supports this call
----------13A2--SI4358-----------------------
INT 13 - Super PC Kwik - ???
	AH = A2h
	SI = 4358h
	???
Return: ???
Note:	PC Tools PC Cache 5.5 is an OEM version of Super PC Kwik, and thus
	  supports this call
----------13AD-------------------------------
INT 13 - Priam HARD DISK CONTROLLER???
	AH = ADh
	???
Return: ???
Note:	this call is made from Priam's EFMT.EXE (low-level formatter), probably
	  to check the ROM type on the controller for their hard disk kits
SeeAlso: AH=70h
----------13B0--SI4358-----------------------
INT 13 - Super PC Kwik - ???
	AH = B0h
	SI = 4358h
	???
Return: ???
Note:	PC Tools PC Cache 5.5 is an OEM version of Super PC Kwik, and thus
	  supports this call
----------13EE-------------------------------
INT 13 - SWBIOS - SET 1024 CYLINDER FLAG
	AH = EEh
	DL = drive number (80h, 81h)
Return: CF clear
	   AH = 00h
Notes:	the following INT 13 call will interpret the cylinder number as 1024
	  less than the desired cylinder
	flag cleared by all INT 13 calls except AH=EEh
	SWBIOS is a TSR by Ontrack Computer Systems; Disk Manager also supports
	  these calls
SeeAlso: AH=F9h,AH=FEh
----------13EE-------------------------------
INT 13 - HyperDisk 4.01 - ???
	AH = EEh
	???
Return: ???
SeeAlso: AX=8EEDh,AX=8EEEh,AX=8EEFh
----------13F9-------------------------------
INT 13 - SWBIOS - INSTALLATION CHECK
	AH = F9h
	DL = drive number (80h,81h)
Return: CF clear 
	    DX = configuration word
		bit 15 set if other SWBIOS extensions available
	CF set on error
Note:	SWBIOS is a TSR by Ontrack Computer Systems; Disk Manager also supports
	  these calls
SeeAlso: AH=EEh
----------13FE-------------------------------
INT 13 - SWBIOS - GET EXTENDED CYLINDER COUNT
	AH = FEh
	DL = drive number (80h, 81h)
Return: CF clear
	DX = number of cylinders beyond 1024 on drive
Notes:	standard INT 13/AH=08h will return a cylinder count truncated to 1024
	BIOS without this extension would return count modulo 1024
	SWBIOS is a TSR by Ontrack Computer Systems; Disk Manager also supports
	  these calls
SeeAlso: AH=EEh
----------1400-------------------------------
INT 14 - SERIAL I/O - INITIALIZE USART
	AH = 00h
	AL = initializing parameters
	    7 - 6 - 5	   4 - 3     2	  1 - 0
	    -BAUD RATE-    PARITY   STOP   WORD
				    BITS  LENGTH
	    000  110 bd    00 none  0: 1   00: 5
	    001  150 bd    01 odd   1: 2   01: 6
	    010  300 bd    11 even	   10: 7
	    011  600 bd 		   11: 8
	    100 1200 bd
	    101 2400 bd
	    110 4800 bd
	    111 9600 bd (4800 on PCjr)
	DX = port number (0-3)
Return: AH = RS-232 status code bits
	    0: data ready
	    1: overrun error
	    2: parity error
	    3: framing error
	    4: break detected
	    5: transmission buffer register empty
	    6: transmission shift register empty
	    7: time out--if set, other bits invalid
	AL = modem status bits
	    0: delta Clear-To-Send
	    1: delta Data-Set-Ready
	    2: trailing edge of ring detected
	    3: change in receive line signal detected
	    4: Clear-To-Send
	    5: Data-Set-Ready
	    6: ring detected
	    7: receive line signal detected
SeeAlso: AH=05h,AH=82h,AH=8Ch
----------1400-------------------------------
INT 14 - FOSSIL (Fido/Opus/Seadog Standard Interface Level) - INITIALIZE
	AH = 00h
	AL = initializing parameters
	    7 - 6 - 5	   4 - 3     2	  1 - 0
	    -BAUD RATE-    PARITY   STOP   WORD
				    BITS  LENGTH
	    000 19200 bd   00 none  0: 1  00: 5
	    001 38400 bd   01 odd   1: 2  01: 6
	    010   300 bd   11 even	  10: 7
	    011   600 bd		  11: 8
	    100  1200 bd
	    101  2400 bd
	    110  4800 bd
	    111  9600 bd (4800 on PCjr)
	DX = port number (0-3 or FFh if only performing non-I/O setup)
Return: AH = RS-232 status code bits
	    0: RDA - input data is available in buffer
	    1: OVRN - data has been lost
	    5: THRE - room is available in output buffer
	    6: TSRE - output buffer empty
	AL = modem status bits
	    3: always 1
	    7: DCD - carrier detect
SeeAlso: AH=05h,AH=82h
----------1401-------------------------------
INT 14 - SERIAL I/O - TRANSMIT CHARACTER
	AH = 01h
	AL = character
	DX = port number (0-3)
Return: AX = port status (see AH=00h)
SeeAlso: AH=02h,AH=0Bh,AH=89h
----------1402-------------------------------
INT 14 - SERIAL I/O - RECEIVE CHARACTER
	AH = 02h
	DX = port number (0-3)
Return: AL = character received
	AH = RS-232 status code (see AH=00h)
Note:	will timeout if DSR is not asserted, even if function 03h returns
	  data ready
SeeAlso: AH=01h,AH=84h
----------1402-------------------------------
INT 14 - FOSSIL - RECEIVE CHARACTER WITH WAIT
	AH = 02h
	DX = port number (0-3)
Return: AL = character received
	AH = 00h
----------1403-------------------------------
INT 14 - SERIAL I/O - GET USART STATUS
	AH = 03h
	DX = port number (0-3)
Return: AX = port status code (see AH=00h)
SeeAlso: AH=81h
----------1404-------------------------------
INT 14 - SERIAL I/O - EXTENDED INITIALIZE (CONVERTIBLE,PS)
	AH = 04h
	AL = break status
	    00h if break
	    01h if no break
	BH = parity
	    00h no parity
	    01h odd parity
	    02h even parity
	    03h stick parity odd
	    04h stick parity even
	BL = number of stop bits
	    00h one stop bit
	    01h two stop bits (1.5 if 5 bit word length)
	CH = word length
	    00h 5 bits
	    01h 6 bits
	    02h 7 bits
	    03h 8 bits
	CL = bps rate
	    00h 110
	    01h 150
	    02h 300
	    03h 600
	    04h 1200
	    05h 2400
	    06h 4800
	    07h 9600
	    08h 19200
	DX = port number
Return: AX = port status code (see AH=00h)
SeeAlso: AH=00h,AH=1Eh
----------1404-------------------------------
INT 14 - FOSSIL - INITIALIZE DRIVER
	AH = 04h
	DX = port number
	optionally BX=4F50h
		   ES:CX -> byte to be set upon ^C
Return: AX = 1954h (if successful)
	BL = maximum function number supported (excluding 7Eh and above)
	BH = revision of FOSSIL supported
	DTR is raised
Note:	the word at offset 6 in the interrupt handler contains 1954h, and the
	  following byte contains the maximum function number supported
SeeAlso: AH=05h"FOSSIL",AH=1Ch
----------1405-------------------------------
INT 14 - SERIAL I/O - EXTENDED COMMUNICATION PORT CONTROL (CONVERTIBLE,PS)
	AH = 05h
	AL = 00h read modem control register
	      Return: BL = modem control register (see below)
		      AH = status
	AL = 01h write modem control register
	      BL = modem control register
		  bit 0: data terminal ready
		  bit 1: request to send
		  bit 2: OUT1
		  bit 3: OUT2
		  bit 4: LOOP
		  bits 5-7 reserved
	      Return: AX = status
	DX = port number
SeeAlso: AH=00h,AH=1Fh
----------1405-------------------------------
INT 14 - FOSSIL - DEINITIALIZE DRIVER
	AH = 05h
	DX = port number
Return: none
	DTR is not affected
SeeAlso: AH=00h,AH=04h"FOSSIL",AH=1Dh,AH=8Dh
----------1406-------------------------------
INT 14 - FOSSIL - RAISE/LOWER DTR
	AH = 06h
	DX = port
	AL = DTR state to be set
	    00h = lower
	    01h = raise
SeeAlso: AH=1Ah
----------1407-------------------------------
INT 14 - FOSSIL - RETURN TIMER TICK PARAMETERS
	AH = 07h
Return: AL = timer tick interrupt number
	AH = ticks per second on interrupt number in AL
	DX = approximate number of milliseconds per tick
SeeAlso: AH=16h
----------1408-------------------------------
INT 14 - FOSSIL - FLUSH OUTPUT BUFFER WAITING TILL ALL OUTPUT IS DONE
	AH = 08h
	DX = port number
SeeAlso: AH=09h
----------1409-------------------------------
INT 14 - FOSSIL - PURGE OUTPUT BUFFER THROWING AWAY ALL PENDING OUTPUT
	AH = 09h
	DX = port number
SeeAlso: AH=08h,AH=0Ah,AH=88h
----------140A-------------------------------
INT 14 - FOSSIL - PURGE INPUT BUFFER THROWING AWAY ALL PENDING INPUT
	AH = 0Ah
	DX = port number
SeeAlso: AH=09h,AH=85h
----------140B-------------------------------
INT 14 - FOSSIL - TRANSMIT NO WAIT
	AH = 0Bh
	AL = character
	DX = port number
Return: AX = 0000h character not accepted
	   = 0001h character accepted
SeeAlso: AH=01h
----------140C-------------------------------
INT 14 - FOSSIL - NON-DESTRUCTIVE READ AHEAD
	AH = 0Ch
	DX = port number
Return: AX = FFFFh character not available
	AX = 00xxh character xx available
SeeAlso: AH=20h
----------140D-------------------------------
INT 14 - FOSSIL - KEYBOARD READ WITHOUT WAIT
	AH = 0Dh
Return: AX = FFFFh character not available
	   = xxyyh standard IBM-style scan code
SeeAlso: AH=0Eh
----------140E-------------------------------
INT 14 - FOSSIL - KEYBOARD READ WITH WAIT
	AH = 0Eh
Return: AX = xxyyh standard IBM-style scan code
SeeAlso: AH=0Dh
----------140F-------------------------------
INT 14 - FOSSIL - ENABLE/DISABLE FLOW CONTROL
	AH = 0Fh
	AL = bit mask describing flow control requested
	    0: xon/xoff on transmit (watch for xoff while sending)
	    1: CTS/RTS (CTS on transmit/RTS on receive)
	    2: reserved
	    3: xon/xoff on receive (send xoff when buffer near full)
	    4-7: all 1
	DX = port number
----------1410-------------------------------
INT 14 - FOSSIL - EXTENDED ^C/^K CHECKING AND TRANSMIT ON/OFF
	AH = 10h
	AL = bit mask
	    0: enable/disable ^C/^K checking
	    1: enable/disable the transmitter
	DX = port number
----------1411-------------------------------
INT 14 - FOSSIL - SET CURRENT CURSOR LOCATION
	AH = 11h
	DH = row
	DL = column
Note:	this is the same as INT 10/AH=02h
SeeAlso: AH=12h
----------1412-------------------------------
INT 14 - FOSSIL - READ CURRENT CURSOR LOCATION
	AH = 12h
Return: DH = row
	DL = column
Note:	this is the same as INT 10/AH=03h
SeeAlso: AH=11h
----------1413-------------------------------
INT 14 - FOSSIL - SINGLE CHARACTER ANSI WRITE TO SCREEN
	AH = 13h
	AL = character
Note:	should not be called if it is unsafe to call DOS
SeeAlso: AH=15h
----------1414-------------------------------
INT 14 - FOSSIL - ENABLE OR DISABLE WATCHDOG PROCESSING
	AH = 14h
	AL = 01h enable watchdog
	     00h disable watchdog
	DX = port number
----------1415-------------------------------
INT 14 - FOSSIL - WRITE CHARACTER TO SCREEN USING BIOS SUPPORT ROUTINES
	AH = 15h
	AL = character
SeeAlso: AH=13h
----------1416-------------------------------
INT 14 - FOSSIL - INSERT/DELETE FUNCTION FROM TIMER TICK CHAIN
	AH = 16h
	AL = function
	    00h = delete
	    01h = add
	ES:DX -> routine to call
Return: AX = 0000h successful
	     0001h unsuccessful
SeeAlso: AH=07h
----------1417-------------------------------
INT 14 - FOSSIL - REBOOT SYSTEM
	AH = 17h
	AL = method
	    00h = cold boot
	    01h = warm boot
----------1418-------------------------------
INT 14 - FOSSIL - READ BLOCK
	AH = 18h
	CX = maximum number of characters to transfer
	DX = port number
	ES:DI -> user buffer
Return: AX = number of characters transfered
SeeAlso: AH=19h,AH=83h,AX=FF02h
----------1419-------------------------------
INT 14 - FOSSIL - WRITE BLOCK
	AH = 19h
	CX = maximum number of characters to transfer
	DX = port number
	ES:DI -> user buffer
Return: AX = number of characters transfered
SeeAlso: AH=18h,AH=86h
----------141A-------------------------------
INT 14 - FOSSIL - BREAK BEGIN OR END
	AH = 1Ah
	AL = 00h stop sending 'break'
	     01h start sending 'break'
	DX = port number
SeeAlso: AH=06h,AH=8Ah,AH=FAh
----------141B-------------------------------
INT 14 - FOSSIL - RETURN INFORMATION ABOUT THE DRIVER
	AH = 1Bh
	DX = port number
	CX = size of user buffer
	ES:DI -> user buffer for driver info (see below)
Return: AX = number of characters transferred
	CX = 3058h ("0X") (X00 FOSSIL only)
	DX = 2030h (" 0") (X00 FOSSIL only)

Format of driver info:
Offset	Size	Description
 00h	WORD	size of structure in bytes
 02h	BYTE	FOSSIL spec driver conforms to
 03h	BYTE	revision level of this specific driver
 04h	DWORD	pointer to ASCIZ identification string
 08h	WORD	size of the input buffer
 0Ah	WORD	number of bytes left in buffer
 0Ch	WORD	size of the output buffer
 0Eh	WORD	number of bytes left in buffer
 10h	BYTE	width of screen
 11h	BYTE	length of screen
 12h	BYTE	actual baud rate, computer to modem
----------141C-------------------------------
INT 14 - X00 FOSSIL - ACTIVATE PORT
	AH = 1Ch
	DX = port number
Return: AX = 1954h if successful
	BL = maximum function number supported (not including 7Eh and above)
	BH = revision of FOSSIL specification supported
Note:	this is a duplicate of AH=04h, so that AH=04h may be made compatible
	  with the PS/2 BIOS in a future release
SeeAlso: AH=04h"FOSSIL",AH=1Dh
----------141D-------------------------------
INT 14 - X00 FOSSIL - DEACTIVATE PORT
	AH = 1Dh
	DX = port number
Return: none
Notes:	this is a duplicate of AH=05h, so that AH=05h may be made compatible
	  with the PS/2 BIOS in a future release
	ignored if the port was never activated with AH=04h or AH=1Ch
SeeAlso: AH=05h"FOSSIL",AH=1Ch
----------141E-------------------------------
INT 14 - X00 FOSSIL - EXTENDED LINE CONTROL INITIALIZATION
	AH = 1Eh
	AL = break status
	    00h if break
	    01h if no break
	BH = parity
	    00h no parity
	    01h odd parity
	    02h even parity
	    03h stick parity odd
	    04h stick parity even
	BL = number of stop bits
	    00h one stop bit
	    01h two stop bits (1.5 if 5 bit word length)
	CH = word length
	    00h 5 bits
	    01h 6 bits
	    02h 7 bits
	    03h 8 bits
	CL = bps rate
	    00h 110
	    01h 150
	    02h 300
	    03h 600
	    04h 1200
	    05h 2400
	    06h 4800
	    07h 9600
	    08h 19200
	DX = port number
Return: AX = port status code (see AH=00h)
Notes:	this function is intended to exactly emulate the PS/2 BIOS AH=04h call
	if the port was locked at X00 load time, the appropriate parameters are
	  ignored
SeeAlso: AH=00h,AH=04h"SERIAL I/O"
----------141F-------------------------------
INT 14 - X00 FOSSIL - EXTENDED SERIAL PORT STATUS/CONTROL
	AH = 1Fh
	AL = 00h read modem control register
	      Return: BL = modem control register (see below)
		      AH = status
	AL = 01h write modem control register
	      BL = modem control register
		  bit 0: data terminal ready
		  bit 1: request to send
		  bit 2: OUT1
		  bit 3: OUT2 (interrupts) enabled
		  bit 4: LOOP
		  bits 5-7 reserved
	      Return: AX = status
	DX = port number
SeeAlso: AH=00h,AH=05h"SERIAL I/O"
Notes:	this function is intended to exactly emulate the PS/2 BIOS AH=05h call
	X00 forces BL bit 3 set (interrupts cannot be disabled)
----------1420-------------------------------
INT 14 - X00 FOSSIL - DESTRUCTIVE READ WITH NO WAIT
	AH = 20h
	DX = port number
Return: AH = 00h if character was available
	    AL = next character (removed from receive buffer)
	AX = FFFFh if no character available
SeeAlso: AH=0Ch
----------1421-------------------------------
INT 14 - X00 FOSSIL - STUFF RECEIVE BUFFER
	AH = 21h
	AL = character
	DX = port number
Notes:	the given character is inserted at the end of the receive buffer as if
	  it had just arrived from the serial port; all normal receive
	  processing (XON/XOFF, ^C/^K) is performed on the character
	fully re-entrant
----------147E-------------------------------
INT 14 - FOSSIL - INSTALL AN EXTERNAL APPLICATION FUNCTION
	AH = 7Eh
	AL = code assigned to external application
	    80h communications FOSSIL
	    81h video FOSSIL
	    82h keyboard FOSSIL
	    83h system FOSSIL
	ES:DX -> entry point
Return: AX = 1954h
	BL = code assigned to application (same as input AL)
	DH = 00h failed
	     01h successful
SeeAlso: AH=7Fh,AH=80h"FOSSIL",AX=8100h,AH=82h"FOSSIL",AH=83h"FOSSIL"
----------147F-------------------------------
INT 14 - FOSSIL - REMOVE AN EXTERNAL APPLICATION FUNCTION
	AH = 7Fh
	AL = code assigned to external application
	ES:DX -> entry point
Return: AX = 1954h
	BL = code assigned to application (same as input AL)
	DH = 00h failed
	     01h successful
SeeAlso: AH=7Eh
----------1480-------------------------------
INT 14 - COMMUNICATIONS FOSSIL
	AH = 80h
SeeAlso: AH=7Eh
----------1480-------------------------------
INT 14 - COURIERS.COM - INSTALLATION CHECK
	AH = 80h
Return: AH = E8h if loaded
Note:	COURIERS is a TSR utility by PC Magazine
----------148100-----------------------------
INT 14 - VIDEO FOSSIL - RETURN VFOSSIL INFORMATION
	AX = 8100h
	ES:DI -> buffer for VFOSSIL information (see below)
Return: AX = 1954h if installed
SeeAlso: AH=7Eh,AX=8101h

Format of VFOSSIL information:
Offset	Size	Description
 00h	WORD	size of information in bytes, including this field
 02h	WORD	VFOSSIL major version
 04h	WORD	VFOSSIL revision level
 06h	WORD	highest VFOSSIL application function supported
----------148101-----------------------------
INT 14 - VIDEO FOSSIL - OPEN VFOSSIL
	AX = 8101h
	CX = length of buffer for application function table in bytes
	ES:DI -> application function table (see below)
Return: AX = 1954h if installed
	    BH = highest VFOSSIL application function supported
Note:	the number of initialized pointers in the application function table
	  will never exceed CX/4; if the buffer is large enough, BH+1 pointers
	  will be initialized
SeeAlso: AX=8102h

Format of application function table:
Offset	Size	Description
 00h	DWORD	-> function to query current video mode (VioGetMode)
 04h	DWORD	-> function to set video mode (VioSetMode)
 08h	DWORD	-> function to query hardware config (VioGetConfig)
 0Ch	DWORD	-> function to write data in TTY mode (VioWrtTTY)
 10h	DWORD	-> function to get current ANSI state (VioGetANSI)
 14h	DWORD	-> function to set new ANSI state (VioSetANSI)
 18h	DWORD	-> function to get curr cursor position (VioGetCurPos)
 1Ch	DWORD	-> function to set cursor position (VioSetCurPos)
 20h	DWORD	-> function to get cursor shape (VioGetCurType)
 24h	DWORD	-> function to set cursor shape (VioSetCurType)
 28h	DWORD	-> function to scroll screen up (VioScrollUp)
 2Ch	DWORD	-> function to scroll screen down (VioScrollDn)
 30h	DWORD	-> function to read cell string from screen (VioReadCellStr)
 34h	DWORD	-> function to read char string from screen (VioReadCharStr)
 38h	DWORD	-> function to write a cell string (VioWrtCellStr)
 3Ch	DWORD	-> function to write char string, leaving attr (VioWrtCharStr)
 40h	DWORD	-> function to write char string,const attr (VioWrtCharStrAttr)
 44h	DWORD	-> function to replicate an attribute (VioWrtNAttr)
 48h	DWORD	-> function to replicate a cell (VioWrtNCell)
 4Ch	DWORD	-> function to replicate a character (VioWrtNChar)

Format of video mode data structure:
Offset	Size	Description
 00h	WORD	length of structure including this field
 02h	BYTE	mode characteristics
		bit 0: clear if MDA, set otherwise
		bit 1: graphics mode
		bit 2: color disabled (black-and-white)
 03h	BYTE	number of colors supported (1=2 colors, 4=16 colors, etc)
 04h	WORD	number of text columns
 06h	WORD	number of text rows
 08h	WORD	reserved
 0Ah	WORD	reserved
 0Ch	DWORD	reserved

Format of video configuration data:
Offset	Size	Description
 00h	WORD	structure length including this field
 02h	WORD	adapter type
		00h monochrome/printer
		01h CGA
		02h EGA
		03h VGA
		07h 8514/A
 04h	WORD	display type
		00h monochrome
		01h color
		02h enhanced color
		09h 8514
 06h	DWORD	adapter memory size

Format of cursor type record:
Offset	Size	Description
 00h	WORD	cursor start line
 02h	WORD	cursor end line
 04h	WORD	cursor width (always 01h)
 06h	WORD	cursor attribute (FFFFh = hidden)

Call VioGetMode with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to video mode data structure (see above)
Return: AX = error code (00h, 74h, 17Eh, 1B4h)
	    0000h successful
	    0074h internal VIO failure
	    0163h unsupported mode
	    0166h invalid row value
	    0167h invalid column value
	    017Eh buffer too small
	    01A5h invalid VIO parameter
	    01B4h invalid VIO handle

Call VioSetMode with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to video mode data structure (see above)
Return: AX = error code (00h, 74h, 163h, 17Eh, 1A5h, 1B4h) (see above)

Call VioGetConfig with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to video configuration data buffer (see above)
Return: AX = error code (00h, 74h, 17Eh, 1B4h) (see above)

Call VioWrtTTY with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	length of string
		DWORD	pointer to character string to be written to screen
Return: AX = error code (00h, 74h, 1B4h) (see above)
Notes:	write wraps at end of line and terminates if it reaches end of screen
	in ANSI mode, ANSI control sequences are interpreted, and this func is
	  not required to be reentrant; in non-ANSI mode, the function is
	  reentrant and may be called from within an MSDOS function call

Call VioGetANSI with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to WORD which will be set to 00h if ANSI is off
			or 01h if ANSI is on
Return: AX = error code (00h, 74h, 1B4h) (see above)

Call VioSetANSI with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to WORD indicating new state of ANSI
			00h off
			01h on
Return: AX = error code (00h, 74h, 1A4h, 1B4h) (see above)

Call VioGetCurPos with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to WORD to hold current cursor column (0-based)
		DWORD	pointer to WORD to hold current cursor row (0-based)
Return: AX = error code (00h, 74h, 1B4h) (see above)

Call VioSetCurPos with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	cursor column
		WORD	cursor row
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	if either coordinate is invalid, the cursor is not moved

Call VioGetCurType with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to cursor type record (see above)
Return: AX = error code (00h, 74h, 1B4h) (see above)

Call VioSetCurType with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to cursor type record (see above)
Return: AX = error code (00h, 74h, 1A4h, 1B4h) (see above)

Call VioScrollUp with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to char/attr cell for filling emptied rows
		WORD	number or rows to scroll (FFFFh = clear area)
		WORD	right column of scroll area
		WORD	bottom row of scroll area
		WORD	left column of scroll area
		WORD	top row of scroll area
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)

Call VioScrollDn with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to char/attr cell for filling emptied rows
		WORD	number or rows to scroll (FFFFh = clear area)
		WORD	right column of scroll area
		WORD	bottom row of scroll area
		WORD	left column of scroll area
		WORD	top row of scroll area
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)

Call VioReadCellStr with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start reading
		WORD	row at which to start reading
		DWORD	pointer to WORD containing length of buffer in bytes
			on return, WORD contains number of bytes actually read
		DWORD	pointer to buffer for cell string
Return: AX = error code (00h, 74h, 166h ,167h, 1B4h) (see above)

Call VioReadCharStr with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start reading
		WORD	row at which to start reading
		DWORD	pointer to WORD containing length of buffer in bytes
			on return, WORD contains number of bytes actually read
		DWORD	pointer to buffer for character string
Return: AX = error code (00h, 74h, 166h ,167h, 1B4h) (see above)

Call VioWrtCellStr with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start writing
		WORD	row at which to start writing
		WORD	length of cell string in bytes
		DWORD	pointer to cell string to write
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	write wraps at end of line and terminates if it reaches end of screen

Call VioWrtCharStr with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start writing
		WORD	row at which to start writing
		WORD	length of character string
		DWORD	pointer to character string to write
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	write wraps at end of line and terminates if it reaches end of screen

Call VioWrtCharStrAttr with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to attribute to be applied to each character
		WORD	column at which to start writing
		WORD	row at which to start writing
		WORD	length of character string
		DWORD	pointer to character string to write
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	write wraps at end of line and terminates if it reaches end of screen

Call VioWrtNAttr with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start writing
		WORD	row at which to start writing
		WORD	number of times to write attribute
		DWORD	pointer to display attribute to replicate
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	write wraps at end of line and terminates if it reaches end of screen

Call VioWrtNCell with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start writing
		WORD	row at which to start writing
		WORD	number of times to write cell
		DWORD	pointer to cell to replicate
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	write wraps at end of line and terminates if it reaches end of screen

Call VioWrtNChar with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start writing
		WORD	row at which to start writing
		WORD	number of times to write character
		DWORD	pointer to character to replicate
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	write wraps at end of line and terminates if it reaches end of screen
----------148102-----------------------------
INT 14 - VIDEO FOSSIL - CLOSE VFOSSIL
	AX = 8102h
Return: AX = 1954h
Note:	terminates all operations; after this call, the video FOSSIL may either
	  be removed from memory or reinitialized
SeeAlso: AX=8101h,AX=8103h
----------148103-----------------------------
INT 14 - VIDEO FOSSIL - UNINSTALL
	AX = 8103h
Return:	AX = 1954h
Note:	this is an extension to the VFOSSIL spec by Bob Hartman's VFOS_IBM
----------1481-------------------------------
INT 14 - COURIERS.COM - CHECK IF PORT BUSY
	AH = 81h
	AL = port number (1-4)
Return: AH = 00h port available
	     01h port exists but already in use
	     02h port nonexistent
Note:	COURIERS is a TSR utility by PC Magazine
SeeAlso: AH=83h,AH=8Dh
----------1482-------------------------------
INT 14 - KEYBOARD FOSSIL
	AH = 82h
SeeAlso: AH=7Eh
----------1482-------------------------------
INT 14 - COURIERS.COM - CONFIGURE PORT
	AH = 82h
	AL = port number (1-4)
	BX = speed (bps)
	CX = bit flags
	    bit 0: enable input flow control
	    bit 1: enable output flow control
	    bit 2: use X.PC protocol (not yet implemented)
SeeAlso: AH=00h,AH=8Ch
----------1483-------------------------------
INT 14 - SYSTEM FOSSIL
	AH = 83h
SeeAlso: AH=7Eh
----------1483-------------------------------
INT 14 - COURIERS.COM - START INPUT
	AH = 83h
	ES:BX -> circular input buffer
	CX = length of buffer 
		(should be at least 128 bytes if input flow control enabled)
SeeAlso: AH=18h,AH=87h,AH=8Dh,AH=A5h
----------1484-------------------------------
INT 14 - COURIERS.COM - READ CHARACTER
	AH = 84h
Return: ZF set if no characters available
	ZF clear
	   AL = character
	   AH = modem status bits
		bit 7: set on input buffer overflow
SeeAlso: AH=02h,AH=86h,AH=89h
----------1485-------------------------------
INT 14 - COURIERS.COM - FLUSH PENDING INPUT
	AH = 85h
SeeAlso: AH=0Ah,AH=88h
----------1486-------------------------------
INT 14 - COURIERS.COM - START OUTPUT
	AH = 86h
	ES:BX -> output buffer
	CX = length of output buffer
SeeAlso: AH=19h,AH=83h,AH=A4h
----------1487-------------------------------
INT 14 - COURIERS.COM - OUTPUT STATUS
	AH = 87h
Return: AX = number of unsent characters
----------1488-------------------------------
INT 14 - COURIERS.COM - ABORT OUTPUT
	AH = 88h
SeeAlso: AH=09h,AH=85h
----------1489-------------------------------
INT 14 - COURIERS.COM - SEND SINGLE CHARACTER
	AH = 89h
	CL = character to send
SeeAlso: AH=01h,AH=84h
----------148A-------------------------------
INT 14 - COURIERS.COM - SEND BREAK
	AH = 8Ah
SeeAlso: AH=89h,AH=FAh
----------148C-------------------------------
INT 14 - COURIERS.COM - SET SPEED
	AH = 8Ch
	BX = speed in bps
SeeAlso: AH=00h,AH=82h
----------148D-------------------------------
INT 14 - COURIERS.COM - DECONFIGURE PORT
	AH = 8Dh
SeeAlso: AH=82h
----------14A0-------------------------------
INT 14 - 3com BAPI SERIAL I/O - CONNECT TO PORT
	AH = A0h
	???
Return: ???
----------14A1-------------------------------
INT 14 - 3com BAPI SERIAL I/O - DISCONNECT FROM PORT
	AH = A1h
	???
Return: ???
----------14A4-------------------------------
INT 14 - 3com BAPI SERIAL I/O - WRITE BLOCK
	AH = A4h
	CX = length
	DH = session number (00h)
	ES:BX -> buffer
Return: CX = number of bytes sent
SeeAlso: AH=19h,AH=86h
----------14A5-------------------------------
INT 14 - 3com BAPI SERIAL I/O - READ BLOCK
	AH = A5h
	CX = length
	DH = session number (00h)
	ES:BX -> buffer
Return: CX = number of bytes read
SeeAlso: AH=18h,AH=83h,AX=FF02h
----------14A6-------------------------------
INT 14 - 3com BAPI SERIAL I/O - SEND SHORT BREAK
	AH = A6h
	DH = session number (00h)
SeeAlso: AH=1Ah,AH=8Ah,AH=FAh
----------14A7-------------------------------
INT 14 - 3com BAPI SERIAL I/O - READ STATUS
	AH = A7h
	???
Return: ???
----------14AF00-----------------------------
INT 14 - 3com BAPI SERIAL I/O - INSTALLATION CHECK
	AX = AF00h
	BX = AAAAh
Return: AX = AF01h if installed
----------14B0-------------------------------
INT 14 - 3com BAPI SERIAL I/O - ENABLE/DISABLE "ENTER COMMAND MODE" CHARACTER
	AH = B0h
	AL = 00h disable
	   = 01h enable
----------14B1-------------------------------
INT 14 - 3com BAPI SERIAL I/O - ENTER COMMAND MODE
	AH = B1h
----------14F4FF-----------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - INSTALLATION CHECK
	AX = F4FFh
	DX = port (00h-03h)
Return: CF clear if present
	    AX = 0000h
	CF set if not present
	    AX <> 0000h
----------14F9-------------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - REGAIN CONTROL
	AH = F9h
	DX = port (00h-03h)
----------14FA-------------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - SEND BREAK
	AH = FAh
	DX = port (00h-03h)
SeeAlso: AH=1Ah,AH=8Ah
----------14FB-------------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - SET OUTGOING MODEM SIGNALS
	AH = FBh
	AL = modem control register
	    bit 0: data terminal ready
		1: request to send
		2: OUT1
		3: OUT2
		4: loopback
	    bits 5-7 unused
	DX = port (00h-03h)
----------14FC-------------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - READ CHARACTER, NO WAIT
	AH = FCh
	DX = port (00h-03h)
Return: AH = RS232 status bits (see AH=00h)
	AL = character
SeeAlso: AH=02h,AH=0Ch
----------14FD02-----------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - READ STATUS
	AX = FD02h
Return: CX = number of characters available
----------14FF02-----------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - BUFFERED READ
	AX = FF02h
	CX = length
	DX = port (00h-03h)
	ES:BX -> buffer
Return: CX = number of characters read
SeeAlso: AH=18h,AH=83h,AH=A5h
----------1500-------------------------------
INT 15 - CASSETTE - TURN ON MOTOR (PC,Jr)
	AH = 00h
Return: CF set on error, AH = 86h if no cassette present
----------1500-------------------------------
INT 15 - Amstrad PC1512 - GET AND RESET MOUSE COUNTS
	AH = 00h
Return: CX = signed X count
	DX = signed Y count
----------1500-------------------------------
INT 15 - VMiX v2+ - INSTALLATION CHECK???
	AH = 00h
Return: DX = 0798h???
----------1501-------------------------------
INT 15 - CASSETTE - TURN OFF MOTOR (PC,Jr)
	AH = 01h
Return: CF set on error, AH = 86h if no cassette present
----------1501-------------------------------
INT 15 - Amstrad PC1512 - WRITE DATA TO NON-VOLATILE RAM
	AH = 01h
	AL = NVRAM location (00h to 3Fh)
	BL = NVRAM data value
Return: AH = return code
	    00h OK
	    01h address bad
	    02h write error
SeeAlso: AH=02h"Amstrad"

Format of NVRAM:
Offset	Size	Description
 00h	BYTE	time of day: seconds
 01h	BYTE	alarm time: seconds
 02h	BYTE	time of day: minutes
 03h	BYTE	alarm time: minutes
 04h	BYTE	time of day: hours
 05h	BYTE	alarm time: hours
 06h	BYTE	day of week, 1 = Sunday
 07h	BYTE	day of month
 08h	BYTE	month
 09h	BYTE	year mod 100
 0Ah	BYTE	RTC status register A
		bit 7: set if date/time being updated
		    6-4: time base speed, default 010 = 32768 Hz
		    3-0: interrupt rate selection, default 0110 = 1024 Hz
 0Bh	BYTE	RTC status register B
		bit 7: clear if normal update, set if abort update
		    6: periodic interrupt enable
		    5: alarm interrupt enable
		    4: update end interrupt enable
		    3: square wave enable
		    2: date mode (clear = BCD, set = binary)
		    1: 24-hour format
		    0: daylight saving time enable
 0Ch	BYTE	RTC status register C (read-only)
		bit 7: IRQF flag
		    6: PF flag
		    5: AF flag
		    4: UF flag
 0Dh	BYTE	RTC status register D
		bit 7: battery good
 0Eh  6 BYTEs	time and date machine last used
 14h	BYTE	user RAM checksum
 15h	WORD	Enter key scancode/ASCII code
 17h	WORD	Forward delete key scancode/ASCII code
 19h	WORD	Joystick fire button 1 scancode/ASCII code
 1Bh	WORD	Joystick fire button 2 scancode/ASCII code
 1Dh	WORD	mouse button 1 scancode/ASCII code
 1Fh	WORD	mouse button 2 scancode/ASCII code
 21h	BYTE	mouse X scaling factor
 22h	BYTE	mouse Y scaling factor
 23h	BYTE	initial VDU mode and drive count
 24h	BYTE	initial VDU character attribute
 25h	BYTE	size of RAM disk in 2K blocks
 26h	BYTE	initial system UART setup byte
 27h	BYTE	initial external UART setup byte
 28h 24 BYTEs	available for user application
Note:	bytes 00h-0Dh are the same on the IBM AT as they are used/updated by
	  the clock chip
----------1501-------------------------------
INT 15 - VMiX - I/O CHANNEL OBJECT MANAGER
	AH = 01h
	STACK: WORD  object ID of requestor
	       DWORD pointer to name of requested method
	       WORD  arg1
	       WORD  arg2
	       WORD  arg3
	       WORD  arg4
Return: DX:AX??? -> IRP structure or 0000h:0000h 
----------1502-------------------------------
INT 15 - CASSETTE - READ DATA BLOCKS (PC,Jr)
	AH = 02h
	CX = count of bytes
	ES:BX -> data area
Return: CF set on error
	AH = status
	    01h CRC error
	    02h bad tape signals
	    04h no data
	    80h invalid command
	    86h no cassette present
	DX = count of bytes read
	ES:BX = pointer past last byte read
----------1502-------------------------------
INT 15 - Amstrad PC1512 - READ DATA FROM NON-VOLATILE RAM
	AH = 02h
	AL = NVRAM location (00h to 3Fh)
Return: AH = return code
	    00h OK
	    01h address bad
	    02h checksum error
	AL = NVRAM data value
SeeAlso: AH=01h"Amstrad"
----------1502-------------------------------
INT 15 - VMiX - MEMORY OBJECT MANAGER
	AH = 02h
	STACK:	WORD	object ID of requestor
		DWORD	pointer to name of requested method
		WORD	arg1
		WORD	arg2
		WORD	arg3
		WORD	arg4
		WORD	arg5
Return: DX:AX??? = pointer to memory block
----------1503-------------------------------
INT 15 - CASSETTE - WRITE DATA BLOCKS (PC,Jr)
	AH = 03h
	CX = count of bytes to write
	ES:BX -> data area
Return: CF set on error
	   AH = status (see AH=02h)
	ES:BX = pointer past last byte written
	CX = 0
----------1503-------------------------------
INT 15 - Amstrad PC1512 - WRITE VDU COLOR PLANE WRITE REGISTER
	AH = 03h
	AL = value (I,R,G,B bits)
SeeAlso: AH=04h"Amstrad"
----------1503-------------------------------
INT 15 - VMiX - PROMPTED CONSOLE INPUT
	AH = 03h
	STACK:	DWORD	pointer to ASCII prompt
		WORD	field outline character
		WORD	length of input field
		DWORD	address of pointer to input buffer
		WORD	number of characters input
Return: AX = length of input (input buffer is padded with blanks)
----------1504-------------------------------
INT 15 - SYSTEM - BUILD ABIOS SYSTEM PARAMETER TABLE (PS)
	AH = 04h
	ES:DI -> results buffer length 20h for System Parameter Table
	DS = segment containing ABIOS RAM extensions (zero if none)
Return: AH = 00h success: results at ES:DI
	CF set on failure
SeeAlso: AH=05h"ABIOS",C1h

Format of ABIOS System Parameter Table:
Offset	Size	Description
 00h	DWORD	FAR address of ABIOS Common Start Routine
 04h	DWORD	FAR address of ABIOS Interrupt Routine
 08h	DWORD	FAR address of ABIOS Time-out Routine
 0Ch	WORD	number of bytes of stack required by this ABIOS implementation
 0Eh 16 BYTEs	reserved
 1Eh	WORD	number of entries in initialisation table
----------1504-------------------------------
INT 15 - Amstrad PC1512 - WRITE VDU COLOR PLANE READ REGISTER
	AH = 04h
	AL = value (RDSEL1 and RDSEL0)
SeeAlso: AH=03h"Amstrad",05h"Amstrad"
----------1504-------------------------------
INT 15 - VMiX - VPRINTF
	AH = 04h
	STACK:	DWORD	control string
		DWORD	array of arguments
----------1505-------------------------------
INT 15 - SYSTEM - BUILD ABIOS INITIALISATION TABLE (PS)
	AH = 05h
	ES:DI -> results buffer length (18h * Number_of_Entries)
	DS = segment containing ABIOS RAM extensions (zero if none)
Return: AH = 00h success: results at ES:DI
	CF set on failure
SeeAlso: AH=04h"ABIOS",C1h

Format of one entry of ABIOS Initialisation Table:
Offset	Size	Description
 00h	WORD	device ID
 02h	WORD	number of Logical IDs
 04h	WORD	Device Block length (zero for ABIOS patch or extension)
 06h	DWORD	-> init routine for Device Block and Function Transfer Table
 0Ah	WORD	request block length
 0Ch	WORD	Function Transfer Table length (zero for a patch)
 0Eh	WORD	Data Pointers length (in Common Data Area)
 10h	BYTE	secondary device ID (hardware level this ABIOS ver supports)
 11h	BYTE	revision (device driver revision level this ABIOS supports)
 12h  6 BYTEs	reserved
----------1505-------------------------------
INT 15 - Amstrad PC1512 - WRITE VDU GRAPHICS BORDER REGISTER
	AH = 05h
	AL = value (I,R,G,B bits)
SeeAlso: AH=04h"Amstrad"
----------1505-------------------------------
INT 15 - VMiX - GET PROCESS ID OF CURRENT PROCESS
	AH = 05h
Return: AX = process ID
----------1506-------------------------------
INT 15 - Amstrad PC1512 - GET ROS VERSION NUMBER
	AH = 06h
Return: BX = version number
----------1506-------------------------------
INT 15 - VMiX - GET POINTER TO PROCESS CONTROL BLOCK
	AH = 06h
	STACK:	WORD	process ID
Return: DX:AX??? -> process control block
----------1507-------------------------------
INT 15 - VMiX - GET POINTER TO OBJECT CONTROL BLOCK
	AH = 07h
	STACK:	WORD	object type
Return: DX:AX??? -> object control block
----------1508-------------------------------
INT 15 - VMiX - GET CHANNEL CONTROL BLOCK
	AH = 08h
	STACK:	WORD	channel ID
Return: DX:AX??? -> channel control block
----------1509-------------------------------
INT 15 - VMiX - GET ID OF QUEUED ELEMENT
	AH = 09h
	STACK:	WORD	queue ID (0 = process queue, 1 = object, 3 = type)
		WORD	subqueue ID
Return: AX = ID
----------150A-------------------------------
INT 15 - VMiX - GET ID OF NEXT QUEUED ELEMENT
	AH = 0Ah
	STACK:	WORD	queue ID (0 = process queue, 1 = object, 3 = type)
		WORD	ID of current element in queue chain
Return: AX = ID of next element
----------150B-------------------------------
INT 15 - VMiX - GET TOTAL NUMBER OF ACTIVE PROCESSES
	AH = 0Bh
Return: AX = number of active processes
----------150C-------------------------------
INT 15 - VMiX - GET POINTER TO PROCESS TSS STACK
	AH = 0Ch
	STACK:	WORD	process ID
Return: DX:AX??? -> TSS stack store
----------150D-------------------------------
INT 15 - VMiX - START A CHILD PROCESS JOB SHELL
	AH = 0Dh
	STACK:	DWORD	ASCIZ string starting with requested I/O channel and
			followed by standard VMiX shell command string
Return: AX = status
SeeAlso: AH=0Eh"VMIX"
----------150E-------------------------------
INT 15 - VMiX - TERMINATE PROCESS
	AH = 0Eh
	STACK:	WORD	process ID
Return: AX = status
SeeAlso: AH=0Dh"VMIX"
----------150F-------------------------------
INT 15 - SYSTEM - FORMAT UNIT PERIODIC INTERRUPT (PS ESDI drives only)
	AH = 0Fh
	AL = phase code
	    00h reserved
	    01h surface analysis
	    02h formatting
Return: CF clear if formatting should continue, set if it should terminate
Note:	called during ESDI drive formatting after each cylinder is completed
SeeAlso: INT 13/AH=1Ah
----------150F-------------------------------
INT 15 - VMiX - GET KEY FIELD OF QUEUED ELEMENT
	AH = 0Fh
	STACK:	WORD	queue ID (0 = process queue, 1 = object q, 3 = type q)
		WORD	ID of element in queue chain
Return: AX = key
----------1510-------------------------------
INT 15 - VMiX - EXECUTE FUNCTION IN PROTECTED MODE
	AH = 10h
	STACK:	DWORD	pointer to function
	      N	WORDs	function args
Return: ???
----------151000-----------------------------
INT 15 - TopView - "PAUSE" - GIVE UP CPU TIME
	AX = 1000h
Return: after other processes run
Note:	under DESQview, if the process issuing this call has hooked INT 08h,
	  the current time-slice is set to expire at the next clock tick rather
	  than immediately
SeeAlso: INT 2F/AX=1680h
----------151001-----------------------------
INT 15 - TopView - "GETMEM" - ALLOCATE "SYSTEM" MEMORY
	AX = 1001h
	BX = number of bytes to allocate
Return: ES:DI -> block of memory or 0000h:0000h (DV 2.26+)
Note:	use SETERROR (AX=DE15h) to avoid a user prompt if there is insufficient
	  common memory
SeeAlso: AX=1002h,AX=DE0Ch,AX=DE15h
----------151002-----------------------------
INT 15 - TopView - "PUTMEM" - DEALLOCATE "SYSTEM" MEMORY
	AX = 1002h
	ES:DI -> previously allocated block
Return: block freed
SeeAlso: AX=1001h,DE0Dh
----------151003-----------------------------
INT 15 - TopView - "PRINTC" - DISPLAY CHARACTER/ATTRIBUTE ON SCREEN
	AX = 1003h
	BH = attribute
	BL = character
	DX = segment of object handle for window
Note:	BX=0 does not display anything, it only positions the hardware cursor
----------1510-------------------------------
INT 15 - TopView - UNIMPLEMENTED IN DV 2.x
	AH = 10h
	AL = 04h thru 12h
Return: pops up "Programming error" window in DV 2.x
----------151013-----------------------------
INT 15 - TopView - "GETBIT" - DEFINE A 2ND-LEVEL INTERRUPT HANDLER
	AX = 1013h
	ES:DI -> FAR service routine
Return: BX = bit mask indicating which bit was allocated
	     0000h if no more bits available
SeeAlso: AX=1014h,AX=1015h
Note:	only a few TopView/DESQview API calls are allowed during a hardware
	  interrupt; if other calls need to be made, the interrupt handler
	  must schedule a 2nd-level interrupt with "SETBIT" (AX=1015h)
----------151014-----------------------------
INT 15 - TopView - "FREEBIT" - UNDEFINE A 2ND-LEVEL INTERRUPT HANDLER
	AX = 1014h
	BX = bit mask from INT 15/AX=1013h
SeeAlso: AX=1013h,AX=1015h
----------151015-----------------------------
INT 15 - TopView - "SETBIT" - SCHEDULE ONE OR MORE 2ND-LEVEL INTERRUPTS
	AX = 1015h
	BX = bit mask for interrupts to post
Return: indicated routines will be called: (DV 2.0x) at next task switch
					   (DV 2.2x) immediately
SeeAlso: AX=1013h,AX=1014h
Notes:	this is one of the few TopView calls which are allowed from a hardware
	  interrupt handler
	the handler will be called with ES containing the segment of the handle
	  of the next task to be executed; on return, ES must be the segment of
	  a task handle
----------151016-----------------------------
INT 15 - TopView - "ISOBJ" - VERIFY OBJECT HANDLE
	AX = 1016h
	ES:DI = possible object handle
Return: BX = FFFFh if ES:DI is a valid object handle
	     0000h if ES:DI is not
SeeAlso: AX=DE14h
----------151017-----------------------------
INT 15 - TopView - UNIMPLEMENTED IN DV 2.x
	AX = 1017h
Return: pops up "Programming error" window in DV 2.x
----------151018-----------------------------
INT 15 - TopView - "LOCATE" - FIND WINDOW AT A GIVEN SCREEN LOCATION
	AX = 1018h
	BH = column
	BL = row
	ES = segment of object handle for window below which to search
	     0000h = start search with topmost window
Return: ES = segment of object handle for window which is visible at the
	       indicated position, or covered by indicated window
	   = 0000h no window
SeeAlso: AX=1023h,AX=1024h
----------151019-----------------------------
INT 15 - TopView - "SOUND" - MAKE TONE
	AX = 1019h
	BX = frequency in Hertz (0000h = silence)
	CX = duration in clock ticks (18.2 ticks/sec)
Return: immediately, tone continues to completion
Notes:	if another tone is already playing, the new tone does not start until
	  completion of the previous one.  Up to 32 tones may be queued before
	  the process is blocked until a note completes.
	in DV 2.00, the lowest tone allowed is 20 Hz
	if CX = 0, the current note is cancelled; if BX = 0 as well, all queued
	  notes are also cancelled
----------15101A-----------------------------
INT 15 - TopView - "OSTACK" - SWITCH TO TASK'S INTERNAL STACK
	AX = 101Ah
Return: stack switched
Notes:	this call may not be nested; a second call must be preceded by a call
	  to "USTACK" (AX=1025h)
	while TopView requires many API calls to be executed while on the
	  task's internal stack, DESQview allows those calls to be executed
	  regardless of the current stack
SeeAlso: AX=1025h
----------15101B-----------------------------
INT 15 - TopView - "BEGINC" - BEGIN CRITICAL REGION
	AX = 101Bh
Return: task-switching temporarily disabled
Notes:	will not task-switch until "ENDC" (AX = 101Ch) called unless task
	  voluntarily releases the CPU (upon regaining the CPU, task-switching
	  will again be disabled)
	suspends the caller until DOS is free
SeeAlso: AX=101Ch,AX=DE13h,AX=DE1Ch,INT 2F/AX=1681h
----------15101C-----------------------------
INT 15 - TopView - "ENDC" - END CRITICAL REGION
	AX = 101Ch
Return: task-switching enabled
Note:	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=101Bh,AX=DE13h,AX=DE1Bh,INT 2F/AX=1682h
----------15101D-----------------------------
INT 15 - TopView - "STOP" - STOP TASK
	AX = 101Dh
	ES = segment of object handle for task to be stopped
	     (== handle of main window for that task)
Return: indicated task will not get any CPU time until restarted with AX=101Eh
Note:	once a task has been stopped, additional "STOP"s are ignored
BUG:	in DV 2.00, this function is ignored unless the indicated task is the
	  current task
SeeAlso: AX=101Eh,102Bh
----------15101E-----------------------------
INT 15 - TopView - "START" - START TASK
	AX = 101Eh
	ES = segment of object handle for task to be started
	     (== handle of main window for that task)
Return: indicated task is started up again
Note:	once a task has been started, additional "START"s are ignored
SeeAlso: AX=101Dh,102Bh
----------15101F-----------------------------
INT 15 - TopView - "DISPEROR" - POP-UP ERROR WINDOW
	AX = 101Fh
	BX = bit fields
	     bits 0-12: number of characters to display
	     bits 13,14: which mouse button may be pressed to remove window
			 00 = either
			 01 = left
			 10 = right
			 11 = either
	     bit 15: beep if 1
	DS:DI -> text of message
	CH = width of error window (0 = default)
	CL = height of error window (0 = default)
	DX = segment of object handle
Return: BX = status: 1 = left button, 2 = right, 27 = ESC pressed
Note:	window remains on-screen until ESC or indicated mouse button is pressed
----------151020-----------------------------
INT 15 - TopView - UNIMPLEMENTED IN DV 2.0x
	AX = 1020h
Return: pops up "Programming error" window in DV 2.0x
----------151021-----------------------------
INT 15 - TopView - "PGMINT" - INTERRUPT ANOTHER TASK
	AX = 1021h
	BX = segment of object handle for task to interrupt (not self)
	DX:CX -> FAR routine to jump to next time task is run
Return: nothing
Notes:	the FAR routine is entered with the current ES, DS, SI, DI, and BP
	  values, using the task's internal stack (see AX=101Ah); only SS:SP
	  needs to be preserved
	multiple PGMINTs to a single task are processed last-in first-out
	if the other task is in a DOS or DV API call, the interruption will
	  occur on return from that call
----------151022-----------------------------
INT 15 - TopView - "GETVER" - GET VERSION
	AX = 1022h
	BX = 0
Return: BX nonzero, TopView or compatible loaded
	(BL = major version, BH = minor version)
Notes:	TaskView returns BX = 0001h, DESQview 2.0 returns BX = 0A01h
----------151023-----------------------------
INT 15 - TopView - "POSWIN" - POSITION WINDOW
	AX = 1023h
	BX = segment of object handle for parent window within which to
	     position the window (0 = full screen)
	ES = segment of object handle for window to be positioned
	DL = bit flags
	     bits 0,1: horizontal position
		00 = current
		01 = center
		10 = left
		11 = right
	     bits 2,3: vertical position
		00 = current
		01 = center
		10 = top
		11 = bottom
	     bit 4: don't redraw screen if set
	     bits 5-7 not used
	CH = number of columns to offset from position specified by DL
	CL = number of rows to offset from position specified by DL
Return: nothing
----------151024-----------------------------
INT 15 - TopView - "GETBUF" - GET VIRTUAL SCREEN INFO
	AX = 1024h
	BX = segment of object handle for window
	      (0 = use default)
Return: ES:DI -> virtual screen
	CX = size of virtual screen in bytes
	DL = 00h text screen
	     01h graphics screen
SeeAlso: INT 10/AH=FEh
----------151025-----------------------------
INT 15 - TopView - "USTACK" - SWITCH BACK TO USER'S STACK
	AX = 1025h
Return: stack switched back
Notes:	call only after having switched to internal stack with AX=101Ah
	while TopView requires many API calls to be executed while on the
	  task's private stack, DESQview allows those calls to be executed
	  regardless of the current stack
SeeAlso: AX=101Ah
----------1510-------------------------------
INT 15 - DESQview (TopView???) - UNIMPLEMENTED IN DV 2.x
	AH = 10h
	AL = 26h thru 2Ah
Return: pops up "Programming error" window in DV 2.x
----------15102B-----------------------------
INT 15 - DESQview 2.0 (TopView???) - "POSTTASK" - AWAKEN TASK
	AX = 102Bh
	BX = segment of object handle for task
Return: nothing
Note:	forces a task which is waiting on its objectq to continue by placing
	  the handle for the task on the objectq
SeeAlso: AX=101Dh,AX=101Eh
----------15102C-----------------------------
INT 15 - DESQview 2.0 (TopView???) - START NEW APPLICATION IN NEW PROCESS
	AX = 102Ch
	ES:DI -> contents of .PIF/.DVP file (see below)
	BX = size of .PIF/.DVP info
Return: BX = segment of object handle for new task
	     0000h on error

Format of .PIF/.DVP file:
Offset	Size	Description
 00h	WORD	reserved (0)
 02h 30 BYTEs	blank-padded program title
 20h	WORD	maximum memory to allocate to partition in K
 22h	WORD	minimum memory required in K
 24h 64 BYTEs	ASCIZ program pathname
 64h	BYTE	default drive letter ('A',...)
 65h 64 BYTEs	ASCIZ default directory name
 A5h 64 BYTEs	ASCIZ program parameters
 E5h	BYTE	initial screen mode (0-7) (see also offset 189h)
 E6h	BYTE	number of text pages used
 E7h	BYTE	number of first interrupt to save
 E8h	BYTE	number of last interrupt to save
 E9h	BYTE	rows in virtual screen buffer
 EAh	BYTE	columns in virtual screen buffer
 EBh	BYTE	initial window position, row
 ECh	BYTE	initial window position, column
 EDh	WORD	system memory in K
 EFh 64 BYTEs	ASCIZ shared program name
12Fh 64 BYTEs	ASCIZ shared program data file
16Fh	BYTE	flags1
		bit 7: writes text directly to screen
		bit 6: runs in foreground only
		bit 5: uses math coprocessor
		bit 4: accesses system keyboard buffer directly
		bits 3-1: reserved (0)
		bit 0: swappable
170h	BYTE	flags2
		bit 6: uses command-line parameters in field at A5h
		bit 5: swaps interrupt vectors
---information unique to .DVP files---
171h  2 BYTEs	keys to use on open menu
173h	WORD	size of script buffer in bytes
175h	WORD	automatically give up CPU after this many tests for keyboard
		input in one clock tick (default 0 = never)
177h	BYTE	nonzero = "uses own colors"
178h	BYTE	nonzero if application swappable
179h  3 BYTEs	reserved (0)
17Ch	BYTE	nonzero to automatically close on exit
17Dh	BYTE	nonzero if copy-protect floppy is required
---information unique to DESQview 2.0+---
17Eh	BYTE	.DVP version number
		00h DESQview 1.2+
		01h DESQview 2.0+
		02h DESQview 2.2+
17Fh	BYTE	reserved (0)
180h	BYTE	initial number of rows in physical window
181h	BYTE	initial number of columns in physical window
182h	WORD	maximum expanded memory to allow, in K
184h	BYTE	flags3
		bit 7: automatically assign window position
		bit 5: maximum memory value has been specified
		bit 4: disallow "Close" command
		bit 3: foreground-only when doing graphics
		bit 2: don't virtualize
185h	BYTE	keyboard conflict level (0-4 for DV<2.26, 00h-0Fh for DV2.26+)
186h	BYTE	number of graphics pages used
187h	WORD	extra system memory size
189h	BYTE	initial screen mode (FFh = default) (overrides offset E5h)
---information unique to DESQview 2.2+---
18Ah	BYTE	serial port usage
		FFh uses all serial ports
		00h no serial ports
		01h only COM1
		02h only COM2
18Bh	BYTE	flags4
		bit 7: automatically close application on exit if .COM or .EXE
			specified
		bit 6: swappable if not using serial ports
		bit 5: start program with window hidden (v2.26+)
		bit 4: start program in background (v2.26+)
		bit 3: virtualize text
		bit 2: virtualize graphics
		bit 1: share CPU when foreground
		bit 0: share EGA when foreground and zoomed
18Ch	BYTE	protection level for 386 machines
18Dh 19 BYTEs	reserved (0)
----------15102D-----------------------------
INT 15 - DESQview 2.0 - KEYBOARD MOUSE CONTROL
	AX = 102Dh
	BL = subfunction
	     00h determine whether using keyboard mouse
		Return: BL = 00h using real mouse
			     01h using keyboard mouse
	     01h turn keyboard mouse on
	     02h turn keyboard mouse off
----------1511-------------------------------
INT 15 - TopView commands
	AH = 11h
	AL = various (except 17h)
Note:	in DESQview 2.x, these function calls are identical to AH=DEh, so
	  see those below
SeeAlso: AH=DEh
----------1511-------------------------------
INT 15 - VMiX - EXECUTE SHELL SYSTEM COMMANDS
	AH = 11h
	STACK:	DWORD	pointer to ASCIZ string containing a VMiX shell
			request (max len = 127)
Return: AX = status
----------151117-----------------------------
INT 15 - DESQview 2.2+ - "ASSERTMAP" - GET/SET MAPPING CONTEXT
	AX = 1117h
	BX = 0000h	get current mapping context without setting
	     nonzero	set new mapping context
Return: BX = mapping context in effect before call
	interrupts enabled
Notes:	this function differs from AX = DE17h for DESQview v2.20 through 2.25
	mapping contexts determine conventional-memory addressability; setting
	  a mapping context ensures that the associated program and data areas
	  are in memory for access.  Usable by drivers, TSRs and shared
	  programs.
	caller need not be running under DESQview, but must ensure that the
	  stack in use will not be mapped out by the call
SeeAlso: AX=DE17h, INT 2F/AX=1685h
----------1511DE-----------------------------
INT 15 - DESQview - XDV.COM - INSTALLATION CHECK
	AX = 11DEh
Return: CF clear if installed
	    AX = segment at which XDV is located
----------1512-------------------------------
INT 15 - VMiX - PUT PROCESS TO SLEEP
	AH = 12h
	STACK:	WORD	process ID
Return: AX = status
----------1512--BH00-------------------------
INT 15 - TopView - SEND MESSAGE - "HANDLE" - RETURN OBJECT HANDLE
	AH = 12h
	BH = 00h
	BL = which handle to return
	    00h handle in DWORD on top of stack
	    01h current task's window handle
	    02h given task's mailbox handle (task's handle on stack)
	    03h current task's mailbox handle
	    04h given task's keyboard handle (task's handle on stack)
	    05h current task's keyboard object handle
	    06h given task's OBJECTQ handle (task's handle on stack)
	    07h current task's OBJECTQ handle
	    08h   \
	      thru > return 0000:0000 under DV < 2.26
	    10h   /
	    0Ch (2.26+) task owning object with handle in DWORD on top of stack
	    0Dh (2.26+) task handle of owner (parent) of current task
Return: DWORD on top of stack is object handle
Note:	BL=0Ch,0Dh returns 00000000h if the object is not open (keyboard,
	  mailbox, panel, pointer, and timer objects) or is an orphan (task,
	  window)
----------1512--BH01-------------------------
INT 15 - TopView - SEND MESSAGE - "NEW" - CREATE NEW OBJECT
	AH = 12h
	BH = 01h
	BL = object type to create
	    00h (DV 2.0x only) handle is DWORD on top of stack
	    01h (DV 2.0x only) use task's window handle
	    02h (DV 2.0x only) given task's mailbox (task's handle on stack)
	    03h (DV 2.0x only) current task's mailbox
	    04h (DV 2.0x only) given task's keyboard (task's handle on stack)
	    05h (DV 2.0x only) current task's keyboard object
	    08h WINDOW class
	    09h MAILBOX class
	    0Ah KEYBOARD class
	    0Bh TIMER object (counts down 32-bit time in 10ms increments)
	    0Fh POINTER object
	    10h PANEL object
	STACK: (if window object or WINDOW class)
	       DWORD address to jump to (no new task if high word == 0)
	       DWORD (reserved) 0 = non-task window, FFFFh = task window
	       DWORD bytes for task's private stack (FFFFh == default of 0100h)
	       DWORD bytes system memory for input buffer for READ/READN
			(0 == none, -1 == default--same as logical window size)
	       DWORD window size, columns
	       DWORD window size, rows
	       DWORD length of window title
	       DWORD address of window title
Return: DWORD on top of stack is new object handle
Notes:	if a new task is created, it is started with
	  AX = BX = SI = DI = BP = 0
	  DX:CX = handle of parent task
	  DS = ES = SS = segment of private stack (and new task's handle)
	new windows are orphans, inherit the colors/hidden status of the
	  creating task's window, and are placed in the upper left hand corner
	  of the screen but not automatically redrawn
	new keyboards are closed, and have all object bits cleared except for
	  the hardware cursor bit
SeeAlso: AH=12h/BH=02h
----------1512--BH02-------------------------
INT 15 - TopView - SEND MESSAGE - "FREE" - FREE AN OBJECT
	AH = 12h
	BH = 02h
	BL = object
	    00h handle in DWORD on top of stack
		window: close window and free
		timer: free timer
		panel: free panel object
		pointer: free pointer
	    01h task's window handle - kills task, never returns
	    02h given task's mailbox (task's handle on top of stack)
	    03h current task's mailbox
	    04h given task's keyboard (task's handle on top of stack)
	    05h current task's keyboard object
Notes:	when a window is freed, its keyboard and pointer objects are freed;
	  task windows also free any mailbox, objectq, and panel objects held
	  by the task and any child tasks
	if the keyboard being freed is the default keyboard for a task, this
	  call is equivalent to CLOSE
	panel and pointer objects are automatically closed if open
SeeAlso: AH=12h/BH=01h,AH=12h/BH=0Dh
----------1512--BH03-------------------------
INT 15 - TopView - SEND MESSAGE - "ADDR" - GET HANDLE OF MESSAGE SENDER
	AH = 12h
	BH = 03h
	BL = object
	    00h mailbox handle in DWORD on top of stack
	    02h sender of last msg read from mailbox (task's handle on stack)
	    03h sender of last msg read from current task's mailbox
Return: DWORD on stack is task handle of message sender
SeeAlso: AH=12h/BH=00h
----------1512--BH03-------------------------
INT 15 - DESQview 2.26+ - "CONNECT" - CONNECT TWO WINDOWS
	AH = 12h
	BH = 03h
	BL = window to be connected
	    00h handle of window to be attached in DWORD on top of stack
	    01h attach current task's main window
	STACK: DWORD handle of window to attach to or 00000000h to detach
Return: ???
Notes:	when two windows are connected, both will move if the user moves either
	multiple windows may be attached to a single window, but each window
	  may only be attached to one window at a time
----------1512--BX0300-----------------------
INT 15 - TopView - SEND MESSAGE - "DIR" - GET PANEL FILE DIRECTORY
	AH = 12h
	BX = 0300h
	STACK: DWORD handle of panel object
Return: STACK: DWORD length of directory (always multiple of 14 bytes)
	       DWORD address of directory
Note:	a null string is returned if the object is not open

Format of panel file:
Offset	Size	Description
 00h  2 BYTEs	C0h C3h
 02h	BYTE	number of panels in file
 03h	for each panel in file:
	    8 BYTEs  blank-padded panel name
	      DWORD  panel offset in file
	      WORD   panel length
	data for panels (each consists of one or more window/query/manager
	streams)
	    first byte of each panel must be 1Bh, fifth byte must be E5h
----------1512--BH04-------------------------
INT 15 - TopView - SEND MESSAGE - "READ" - READ NEXT LOGICAL LINE OF WINDOW
	AH = 12h
	BH = 04h
	BL = window to read from
	    00h handle is DWORD on top of stack
	    01h use calling task's default window
	    0Ch (DV 2.26+) default window of task owning handle on top of stack
	    0Dh (DV 2.26+) default window of parent task of current task
Return: STACK:	DWORD number of bytes read
		DWORD address of buffer
Notes:	reading starts at the current logical cursor position; the cursor is
	  updated to point at the character following the last one read
	any translucent blanks (FFh) which are visible on screen are changed
	  to the character which is seen through them
	the string produced by the read is placed in an input buffer which may
	  be reused by the next READ or READN of a window
	window stream opcodes D8h and D9h determine whether the read returns
	  characters or attributes
SeeAlso: AH=12h/BH=05h"WINDOW",AH=12h/BH=12h
----------1512--BH04-------------------------
INT 15 - TopView - SEND MESSAGE - "READ" - GET NEXT RECORD FROM OBJECT
	AH = 12h
	BH = 04h
	BL = object
	    00h handle is DWORD on top of stack
		mailbox: wait for and get next message
		keyboard: wait for and get pointer to next input buffer
		pointer: wait for and get next message
	    02h get next message from mailbox (task's handle on top of stack)
	    03h get next message from current task's mailbox
	    04h get the next input from keyboard (handle on top of stack)
	    05h get the next input from task's default keyboard
	    06h wait for input from any object in OBJECTQ (handle on stack)
	    07h wait for input from any object in task's default OBJECTQ
Return: STACK: (if objectq) DWORD handle of object with input
	       (otherwise)  DWORD number of bytes
			    DWORD address
Notes:	for a keyboard in keystroke mode, the input buffer is a single byte
	  containing the character code as returned by the BIOS; the BIOS scan
	  code is available via the STATUS call if the character is zero
	for a keyboard in field mode, the input buffer format is determined
	  by the field table header for the window the keyboard is attached to
	keyboard input buffers and mailbox message buffers may be invalidated
	  by the next READ, ERASE, CLOSE, or FREE message to the same object
SeeAlso: AH=12h/BH=05h"OBJECT"

Format of pointer message:
Offset	Size	Description
 00h	WORD	row
 02h	WORD	column
 04h	BYTE	status
		bit 6: set when press/release mode active and button released
		bits 7-2: number of clicks-1 if multiple-click mode active
		bits 1,0: button pressed (00=none,01=button1,10=button2)
 05h	BYTE	field number or zero (APILEVEL >= 2.00 only)
----------1512--BX0400-----------------------
INT 15 - TopView - SEND MESSAGE - "READ" - WAIT FOR TIMER TO EXPIRE
	AH = 12h
	BX = 0400h
	STACK: DWORD timer's handle
Return: after timer expires
	STACK: DWORD time in 1/100 sec after midnight when timer expired
----------1512--BX0400-----------------------
INT 15 - TopView - SEND MESSAGE - "APPLY" - WRITE PANEL TO WINDOW
	AH = 12h
	BX = 0400h
	STACK: DWORD handle of panel object
	       DWORD window's handle (or 0 for current task's window)
	       DWORD length of panel name
	       DWORD pointer to panel name
Return: STACK: DWORD handle of keyboard or 0
	       DWORD handle of window which was used
Notes:	status of APPLY may be checked with STATUS message
	panel MUST have the following format
	  first byte must be 1Bh (i.e. must start with a stream)
	  first opcode in stream must be E5h
	    single byte arg of opcode is interpreted thus:
	      bits 7,6	11 means create new window
			10 means create new field table for existing window
			01 means use existing window and field table
	      bit 5 if set, panel contains a field table 
			(creates a new keyboard and puts it in field mode)
	      bit 4 if set, panel contains input fields
	      bit 3 if set, panel contains select fields but no input fields
	if the panel contains input or select fields, a keyboard handle is
	  returned; either the window's current open keyboard or a
	  newly-created keyboard object.  The caller should read that keyboard
	  to obtain input from the panel.
----------1512--BH05------------------------
INT 15 - TopView - SEND MESSAGE - "WRITE" - WRITE TO OBJECT
	AH = 12h
	BH = 05h
	BL = object
	    00h handle is DWORD on top of stack
		timer: start timer to end at a specified time
		keyboard: add input buffer to queue
		pointer: move pointer icon to specified position
	    02h send message by value/status=0 to mbox (task's handle on stack)
	    03h send message by value/status=0 to current task's mailbox
	    04h add input buffer to KEYBOARD queue (handle on top of stack)
	    05h add input buffer to task's default KEYBOARD queue
	    06h add an object to OBJECTQ (handle on top of stack)
	    07h add an object to task's default OBJECTQ
	STACK: (if mailbox)  DWORD length
			     DWORD address
	       (if keyboard) DWORD status (scan code in keystroke mode)
			     DWORD length (should be 1 in keystroke mode)
			     DWORD address
	       (if objectq)  DWORD handle of object to add
	       (if timer)    DWORD 1/100ths seconds since midnight (actually
				   only accurate to 1/18 sec)
	       (if pointer)  DWORD column relative to origin of window
			     DWORD row relative to origin of window
Notes:	under DV 2.2+, failed mailbox writes may return CF set (see AX=DE15h)
	the data and status written to a keyboard object must match the format
	  returned by the keyboard object in the current mode
	the pointer position is scaled according to the current scaling factors
SeeAlso: AH=12h/BH=04h
----------1512--BH05-------------------------
INT 15 - TopView - SEND MESSAGE - "WRITE" - WRITE STRING TO WINDOW
	AH = 12h
	BH = 05h
	BL = window to write to
	    00h DWORD on top of stack is window handle
	    01h write string to task's default window
	    0Ch (DV 2.26+) default window of task owning handle on top of stack
	    0Dh (DV 2.26+) default window of parent of current task
	STACK: DWORD object handle if handle passed on stack
	       DWORD total length of string (high word == 0)
	       DWORD address of string to display
Return: indicated actions performed
	a. non-control characters are displayed (opcodes DEh and DFh control
	   whether the attributes are left or changed to the current attrib)
	b. CR/LF/BS/Tab cause the usual cursor movement
	c. ESC starts a data structure with additional commands if following
	   byte is less than 20h; otherwise, it is written to the window
	STACK:	DWORD handle of new window if window stream opcode E6h
		else nothing

Data Structure:
	MAGIC  DB  1Bh
	MODE   DB  ?   ; 00h, 01h, 10h, 14h-1Fh legal
	LENGTH DW  ?   ; length of remainder in bytes
	var-length fields follow, each an OPCODE followed by
	     zero or more args

MODE 00h (set or display values) "WINDOW STREAM"
    Opcodes:args
	00h  display 20h blanks with the default attribute
	01h-1Fh display OPCODE blanks with the default attribute
	20h  display char with default attribute 20h times
	     BYTE char to repeat
	21h-3Fh display char with default attribute OPCODE-20h times
	     BYTE char to repeat
	40h  display 20h blanks with specified attribute
	     BYTE attribute of blanks
	41h-5Fh display OPCODE-40h blanks with specified attribute
	     BYTE attribute of blanks
	60h  display next 20h characters
	     20h BYTES characters to display
	61h-7Fh display next OPCODE-60h characters
	     N BYTES characters to display
	80h-87h  display N blanks with default attribute
	     BYTE low 8 bits of 11-bit count (high 3 in low 3 bits of OPCODE)
		      [000h means 800h]
	88h-8Fh display N copies of the character
	     BYTE low 8 bits of 11-bit count (high 3 in low 3 bits of OPCODE)
		      [000h means 800h]
	     BYTE character to repeat
	90h-97h  display N blanks with specified attribute
	     BYTE low 8 bits of 11-bit length (high 3 in low 3 bits of OPCODE)
		      [000h means 800h]
	     BYTE attribute
	98h-9FH  display string at logical cursor pos
	     BYTE low 8 bits of 11-bit length (high 3 in low 3 bits of OPCODE)
		      [000h means 800h]
	     N BYTES string to display
	A0h  set logical cursor row
	     BYTE row number (0 is top)
	A1h  set logical cursor column
	     BYTE column number (0 is leftmost)
	A2h  set top edge of scrolling region
	     BYTE row
	A3h  set left edge of scrolling region
	     BYTE column
	A4h  set row of physical window position
	     BYTE line
	A5h  set column of physical window position
	     BYTE column
	A6h  set height of physical window
	     BYTE #rows
	A7h  set width of physical window
	     BYTE #columns
	A8h  set viewport row
	     BYTE row
	A9h  set viewport column
	     BYTE column
	AAh  set virtual screen height [contents of window unpredictable after]
	     BYTE rows
	ABh  set virtual screen width [contents of window unpredictable after]
	     BYTE columns
	ACh-AEh  unused
	AFh  set compatible/preferred video modes
	     BYTE compatibility/preference mask
		bit 7	compatible with monochrome
		bit 6	compatible with color text, EGA/VGA graphics
		bit 5	compatible with medium-resolution CGA graphics
		bit 4	compatible with high-resolution CGA graphics
		bit 3	prefer monochrome
		bit 2	prefer color text, EGA/VGA graphics
		bit 1	prefer medium-resolution CGA graphics
		bit 0	prefer high-resolution CGA graphics
	B0h  move logical cursor down
	     BYTE #rows (signed, negative values move up)
			[if #rows=0 and hardware cursor owner, update hw crsr]
	B1h  move logical cursor right
	     BYTE #cols (signed, negative values move left)
			[if #cols=0 and hardware cursor owner, update hw crsr]
	B2h  shift top edge of scrolling region
	     BYTE #rows (signed)
	B3h  shift left edge of scrolling region
	     BYTE #cols (signed)
	B4h  shift physical window down
	     BYTE #lines (signed)
	B5h  shift physical window right
	     BYTE #columns (signed)
	B6h  expand physical window vertically
	     BYTE #lines (signed)
	B7h  expand physical window horizontally
	     BYTE #columns (signed)
	B8h  adjust viewport row
	     BYTE #rows (signed)
	B9h  adjust viewport column
	     BYTE #columns (signed)
	BAh  adjust virtual screen height [contents of window unpredict after]
	     BYTE #rows to increase (signed)
	BBh  adjust virtual screen width [contents of window unpredictbl after]
	     BYTE #cols to increase (signed)
	BCh-BFh  reserved (currently unused)
	C0h  set logical cursor position
	     BYTE row number (0 is top border)
	     BYTE column number (0 is left border)
	C1h  set top left corner of scrolling region
	     BYTE row
	     BYTE column
	C2h  set physical window pos
	     BYTE upper left row (no top border if 0)
	     BYTE upper left column (no left border if 0)
	C3h  set current window size
	     BYTE #rows
	     BYTE #cols
	C4h  set upper left corner of viewport (portion of virtual screen
	     displayed in window)
	     BYTE row
	     BYTE column
	C5h  set size of virtual screen [contents unpredictable afterwards]
	     BYTE #rows
	     BYTE #cols
	C6h  unused
	C7h  unused
	C8h  set logical cursor relative to current position
	     BYTE number of rows to move down (signed)
	     BYTE number of columns to move right (signed)
		  [if #rows=#cols=0 and hardware cursor owner, update hw cursr]
	C9h  shift top left corner of scrolling region
	     BYTE #rows (signed)
	     BYTE #cols (signed)
	CAh  set window pos relative to current position
	     BYTE number of rows to shift down (signed)
	     BYTE number of columns to shift right (signed)
	CBh  set window size relative to current size
	     BYTE number of rows to expand (signed)
	     BYTE number of cols to expand (signed)
	CCh  shift viewport relative to current position
	     BYTE rows to shift (signed)
	     BYTE cols to shift (signed)
	CDh  resize virtual screen
	     BYTE #rows to expand (signed)
	     BYTE #cols to expand (signed)
	CEh  scroll text when using E8h-EBh/F8h-FBh opcodes (default)
	CFh  scroll attributes when using  E8h-EBh/F8h-FBh opcodes
	D0h  allow window frame to extend beyond screen
	D1h  always display a complete frame, even if window extends beyond 
	     edge of screen
	D2h  allow DV to change logical colors on video mode switch (default)
	D3h  application changes logical attributes
	D4h  window is visible [must redraw to actually make visible]
	D5h  window is hidden [must redraw to actually remove]
	D6h  window has frame (default)
	D7h  window unframed [must redraw to actually remove frame]
	D8h  READ/READN will read characters from window (default)
	D9h  READ/READN will read attributes from window
	DAh  use logical attributes, which may be remapped
		attributes
		   1 normal text
		   2 highlighted normal text
		   3 help text
		   4 highlighted help text
		   5 error message
		   6 highlighted error message
		   7 emphasized text
		   8 marked text
		   9-16 are reverse video versions of 1-8
	DBh  use physical attributes for characters
	DCh  enable special actions for control characters (default)
	DDh  disable special control char handling, all chars displayable by
	     BIOS TTY call
	DEh  write both character and attribute (default)
	DFh  write character only, leave attribute untouched
	E0h  repeat following commands through E1h opcode
	     BYTE number of times to repeat (00h means 256 times)
	E1h  end of commands to repeat, start repeating them
	E2h  set current output color
	     BYTE color
	E3h  clear virtual screen from scroll origin to end using current color
	E4h  redraw window
	E5h  select menu style
	     BYTE style (normally 18h)
		bits 5,4 = 01 use two-letter menu entries for remainder of
		  this stream
	E5h  (panel file only)
	     BYTE modifier
		bits 7,6 = 11 panel stream creates new window
			 = 10 panel defines new field table for existing window
			 = 01 panel stream uses existing window & field table
		bit 5 = 1 stream contains a field table (create kyboard object)
		bit 4 = 1 stream defines input fields (create keyboard object)
		bit 3 = 1 stream defines select fields but not input fields
		bit 2 = 1 stream defines exclusive input window (DV 2.2)
		bit 1 reserved
		bit 0 reserved
	E6h  create new window and perform rest of manipulations in new window
	     BYTE number of rows
	     BYTE number of columns
	     Return: DWORD object handle of new window returned on stack at end
	E7h  no operation
	E8h  scroll area up (top left corner defined by opcode C1h)
	     BYTE height
	     BYTE width
	E9h  scroll area down (top left corner defined by opcode C1h)
	     BYTE height
	     BYTE width
	EAh  scroll area left (top left corner defined by opcode C1h)
	     BYTE height
	     BYTE width
	EBh  scroll area right (top left corner defined by opcode C1h)
	     BYTE height
	     BYTE width
	ECh  set logical attributes for window contents
	     BYTE video modes command applies to
		bit 7	monochrome
		bit 6	color text, EGA/VGA graphics
		bit 5	medium-resolution CGA graphics
		bit 4	high-resolution CGA graphics
	     BYTE which attributes to set
		bit 7  if set, copy single following byte to indicated attribs
		bits 4-6  # of first attribute to change - 1
		bits 0-3  # of consecutive attributes to change
	     N BYTEs new attributes
	EDh  set logical attributes for window frame
	     BYTE video modes command applies to (see opcode ECh)
	     BYTE which attributes to set
		bit 7  if set, copy single following byte to indicated attrs
		bits 4-6  # of first attribute to change - 1
		bits 0-3  # of consecutive attributes to change
	     N BYTEs new attributes
		  attributes
		       1 = top left corner
		       2 = top right corner
		       3 = bottom left corner
		       4 = bottom right corner
		       5 = top edge
		       6 = bottom edge
		       7 = left edge
		       8 = right edge
	EEh  set characters for window frame
	     BYTE video modes command applies to (see opcode ECh)
	     BYTE which characters to set
		bit 7  if set, copy single following byte to indicated chars
		bits 4-6  # of first char to change - 1
		bits 0-3  # of consecutive chars to change
	     N BYTEs new chars (same relative position as attributes above)
	EFh  set window name
	     BYTE length of name (should be in range 0 to logical screen width)
	     N BYTEs name
	F0h  clear input field to blanks
	     BYTE field number
	F1h  fill input field with character
	     BYTE field number
	     BYTE char
	F2h  set color of input field
	     BYTE field number (1-N)
	     BYTE attribute
	F3h  set initial contents of input field
	     BYTE field number (1-N)
	     N BYTEs enough chars to exactly fill field as defined by op FFh
	F4h  position cursor to start of specific input field
	     BYTE field number (1-N)
	F5h  change field table entry
	     BYTE field number
	     7-8 BYTEs field table entry (see opcode FFh below)
	F6h  set field type
	     BYTE field number
	     BYTE type
			00h inactive
			40h output field
			80h input field
			C0h deselected field
			C2h selected field
	F7h  "broadcast write"	write data to fields with program output bit
		set in field table entry, in field number order
	     N BYTEs (total length of all program output fields)
	F8h  scroll field up a line
	     BYTE field number
	F9h  scroll field down a line
	     BYTE field number
	FAh  scroll field left
	     BYTE field number
	FBh  scroll field right
	     BYTE field number
	FCh  set field table header
	     BYTE number of fields (must be <= existing number of fields)
	     BYTE screen behavior bits
		bit 7  reserved
		bit 6  set if menu items may be selected via keyboard
		bit 5  set if left mouse button may terminate entry
		bit 4  set if right mouse button may terminate entry
		bit 3  if set, select fields return contents or blanks rather
			than 'Y' or 'N'
		bit 2  if set, modified bits reset on return to application
		bits 0,1 = 00 no data returned on read of keyboard
			   01 data returned as array of chars containing
				all fields packed together, with no field
				numbers
			   10 data returned as numbered variable-length
				records for all fields
			   11 data returned as numbered variable-length
				records for the fields which were modified
	     BYTE current input field (updated by DESQview)
	     BYTE current select field (updated by DESQview)
	     BYTE attribute for select fields when they are pointed at
	     BYTE attribute for select fields which have been selected
	FDh  reset modified bit for all fields
	FEh  reset selected and modified bits for all fields
	FFh  set up input fields
	     6 BYTEs table header (see opcode FCh above)
	     the field table entries, one for each field
		 BYTE start row    \
		 BYTE start column  \ if menu selection and start is to
		 BYTE end row	    / right or below end, select from kbd only
		 BYTE end column   /
		 BYTE field type
		    bits 7,6 = 00 inactive (non-entry) field
			       01 echos keystrokes input to make menu selection
			       10 fill-in field
			       11 select field
		    bit 5  field can be filled by broadcast write (F7h opcode)
		    bit 4  reserved
		    bit 3  reserved
		    bit 2  reserved
		    bit 1  set if field selected
		    bit 0  set if field modified
		 BYTE modifier
		      if type is fill-in, then bit flags to determine behavior
			  bit 7  if set, automatically enter CR when field full
			  bit 6  move to next field when current field is full
			  bit 5  if set, enter text from right end (for numbers)
			  bit 4  if set, force input to uppercase
			  bit 3  if set, clear old contents on first keystroke
			  bit 2  if set, input returned when cursor moves out
				 of modified field (API level 2.02+)
			  bit 1  reserved
			  bit 0  reserved
		      if select field, first key to press to activate
			  00h if have to point-&-click or is an extended-ASCII
			      keystroke (only if two-key menus enabled)
		 BYTE (select field only) normal color of field
		 BYTE second key for select field.  This byte is present iff
		      two-letter menu entries selected with opcode E5h, and
		      in that case is present regardless of field type
	     Note: DESQview uses and updates the actual copy of the information
	       which is contained in the stream.  Thus this info must remain
	       intact until after the data entry is complete.

MODE 01h "QUERY STREAM" (valid only for those opcodes listed here)
	A0h return logical cursor row in next byte
	A1h return logical cursor column in next byte
	A2h return top row of scrolling region in next byte
	A3h return left column of scrolling region in next byte
	A4h return row of physical window origin in next byte
	A5h return column of physical window origin in next byte
	A6h return height of physcial window in next byte
	A7h return width of physical window in next byte
	A8h return row of viewport origin in next byte
	A9h return column of viewport origin in next byte
	AAh return height of virtual screen in next byte
	ABh return width of virtual screen in next byte
	AFh return current video mode in next byte
	C0h return current logical cursor position in next two bytes
	C1h return top left corner of scrolling region in next two bytes
	C2h return current window position in next two bytes
	C3h return current window size in next two bytes
	C4h return current viewport origin in next two bytes
	C5h return current virtual screen size in next two bytes
	D0h \ overwritten with D0h if frames may fall off screen edge
	D1h /		       D1h if frames always displayed entirely
	D2h \ overwritten with D2h if DESQview controls color palette
	D3h /		       D3h if application changes color palette
	D4h \ overwritten with D4h if window visible
	D5h /		       D5h if window hidden
	D6h \ overwritten with D6h if window has frame
	D7h /		       D7h if window unframed
	D8h \ overwritten with D8h if reading characters from window
	D9h /		       D9h if reading attributes from window
	DAh \ overwritten with DAh if using logical attributes
	DBh /		       DBh if using physical attributes
	DCh \ overwritten with DCh if TTY control char interpretation on
	DDh /		       DDh if TTY control char interpretation off
	DEh \ overwritten with DEh if writing both characters and attributes
	DFh /		       DFh if leaving attributes untouched
	E2h return current color in next byte
	ECh get logical attributes for window contents
	    BYTE execute call if currently in specified video mode
		bit 7	monochrome
		bit 6	color text, EGA/VGA graphics
		bit 5	medium-resolution CGA graphics
		bit 4	high-resolution CGA graphics
	    BYTE which attributes to get
		bit 7 unused???
		bits 4-6 first attribute to get - 1
		bits 0-3 # consecutive attributes
	    N BYTEs buffer to hold attributes
	EDh get logical attributes for window frame
	    BYTE execute call if currently in video mode (see opcode ECh)
	    BYTE which attributes to get
		bit 7 unused???
		bits 4-6 first attribute to get - 1
		bits 0-3 # consecutive attributes
	    N BYTEs buffer to hold attributes
	EEh get characters for window frame
	    BYTE execute call if currently in video mode (see opcode ECh)
	    BYTE which attributes to get
		bit 7 unused???
		bits 4-6 first char to get - 1
		bits 0-3 # consecutive chars
	    N BYTEs buffer to hold chars
	EFh return first N characters of current window name
	    BYTE    max length of returned name
	    N BYTEs buffer to hold window name
	F3h return contents of specified field
	    BYTE field number
	    N BYTEs buffer to hold field contents (size exactly equal to field
		    size)
	F5h get field table entry
	    BYTE field number
	    7-8 BYTEs buffer to hold field table entry
	       Notes: DV < 2.26 always returns 7 bytes
		      DV 2.26+ w/ APILEVEL < 2.26 returns 8 bytes iff field
			table is using 8-byte entries and eighth byte after
			F5h is E7h (NOP); otherwise, 7 bytes are returned
		      DV 2.26+ w/ APILEVEL > 2.26 returns 7 or 8 bytes
			depending on the field table entry size
	F6h get type of a field
	    BYTE field number
	    BYTE type
	FCh get field table header
	    6 BYTEs buffer to store header

MODE 10h "MANAGER STREAM" (valid only for opcodes listed here)
	00h allow window to be moved horizontally
	01h allow window to be moved vertically
	02h allow window to change width
	03h allow window to change height
	04h allow window to be scrolled horizontally
	05h allow window to be scrolled vertically
	06h allow "Close Window" menu selection for application
	07h allow "Hide Window" menu selection for application
	08h allow application to be suspended ("Rearrange/Freeze")
	0Eh allow "Scissors" menu
	10h allow DESQview main menu to be popped up
	11h allow "Switch Windows" menu
	12h allow "Open Window" menu
	13h allow "Quit" menu selection
	20h-33h opposite of 00h-13h, disallow specified action
	40h notify if horizontal position of window changes
	41h notify if vertical position of window changes
	42h notify if width of window changes
	43h notify if height of window changes
	44h notify if window scrolled horizontally
	45h notify if window scrolled vertically
	46h notify if window is closed--program has to clean up and exit itself
	47h notify if window is hidden
	48h notify if "?" on main menu selected
	49h notify if pointer message sent to window
	4Ah notify if window is placed in foreground
	4Bh notify if window is placed in background
	4Ch notify if video mode changes
	4Dh notify if "Scissors" menu "Cut" option selected
	4Eh notify if "Scissors" menu "Copy" option selected
	4Fh notify if "Scissors" menu "Paste" option selected
	50h notify if DESQview main menu about to pop up
	51h notify if DESQview main menu popped down
	60h-71h  opposite of 40h-51h: don't notify on specified event
	84h attach window to parent task's window (both move together)
	85h detach window from parent task's window (may move independently)
	86h disable background operation for application
	87h enable running in background
	88h set minimum size of physical window
	    BYTE rows
	    BYTE columns
	89h set maximum size of physical window
	    BYTE rows
	    BYTE cols
	8Ah set primary asynchronous notification routine
	    DWORD address of routine, 0000h:0000h means none (see also below)
	8Bh set async notification parameter
	    DWORD 32-bit value passed to 8Ah async routine in DS:SI
	ACh (DV2.2+) perform regular select field attribute processing
	ADh (DV2.2+) protect attributes in selected field from being lost
	AEh make window default notify window for owning app (API level 2.00+)
	AFh set selected field marker character
	    BYTE character to display at left edge of selected fields
	BCh set standard field processing mode 
	BDh set alternate field processing mode (enables cursor pad for menus)
	BEh disables changing reverse logical attributes with ECh opcode
	BFh enables changing reverse logical attributes with ECh opcode
	C0h make current window topmost in system
	C1h force current process into foreground
	C2h make current window topmost in process
	C3h position mouse pointer relative to origin of current field
	    BYTE rows below upper left corner of field
	    BYTE columns to right of upper left corner of field
	C4h position mouse pointer relative to origin of given field
	    BYTE field number
	    BYTE rows below upper left corner of field
	    BYTE columns to right of upper left corner of field
	C5h orphan current window (also hides it)
		Note: must be last in stream; all subsequent commands ignored
	C6h show all windows for this process
	C7h hide all windows for this process
	C8h suspend process and hide all its windows
	C9h force current process into background
	CAh make current window bottom-most in process
	CBh cancel current window manager operation, remove DV menu, give 
	    control to topmost application
	CCh orphan window and give it to the system for use as paste data
	CEh reorder windows
	    DWORD pointer to null-terminated list of words
		  each word is segment of object handle for a window
	FFh no operation

MODES 14h to 1Fh "USER STREAMS"
	normally NOPs, but may be defined by SETESC message to invoke FAR
	routines, one for each mode number
	  on entry to handler,
		DS:SI -> first byte of actual stream (not header)
		CX = #bytes in stream
		ES:DI = window's handle

Asynchronous notification routine defined by manager stream 8Ah called with:
	ES:DI = handle of window
	DS:SI is 32-bit value set by 8Bh manager stream opcode
	   mailbox contains message indicating event
	      Opcode
	       40h  horizontal movement
		   DWORD object handle of window
		   BYTE  new row
		   BYTE  new col
	       41h  vertical movement
		   DWORD object handle of window
		   BYTE  new row
		   BYTE  new col
	       42h  horizontal size change
		   DWORD object handle of window
		   BYTE  new rows
		   BYTE  new cols
	       43h  vertical size change
		   DWORD object handle of window
		   BYTE  new rows
		   BYTE  new cols
	       44h  scrolled horizontally
		   DWORD object handle of window
		   BYTE  mouse row within window
		   BYTE  mouse column within window
		   BYTE  field mouse is on, 0 if none
		   BYTE  amount moved: >0 right, <0 left, 0 done
	       45h  scrolled vertically
		   DWORD object hande of window
		   BYTE  mouse row within window
		   BYTE  mouse column within window
		   BYTE  field mouse is on, 0 if none
		   BYTE  amount moved: >0 down, <0 up, 0 done
	       46h  window close request
		   DWORD object handle of window
		   BYTE  mouse pointer row
		   BYTE  mouse pointer column
		   BYTE  field mouse is on, 0 if none
	       47h  application's windows hidden
	       48h  Help for Program selected
		   DWORD object handle of window
		   BYTE  mouse pointer row
		   BYTE  mouse pointer column
		   BYTE  field mouse is on, 0 if none
	       49h  pointer message sent to window
		   DWORD pointer handle which received message
	       4Ah  switched to window from another ("raise")
	       4Bh  switched away from the window ("lower")
	       4Ch  video mode changed
		   BYTE new BIOS video mode
	       4Dh  Scissors/cUt selected
		   DWORD object handle of window
		   BYTE  row of upper left corner
		   BYTE  column of upper left corner
		   BYTE  field number ul corner is in, 0=none
		   DWORD handle of orphaned window created with
			 copy of data from specified region
		   BYTE  height of region
		   BYTE  width of region
	       4Eh  Scissors/Copy selected
		   DWORD object handle of window
		   BYTE  row of upper left corner
		   BYTE  column of upper left corner
		   BYTE  field number ul corner is in, 0=none
		   DWORD handle of orphaned window created with
			 copy of data from specified region
		   BYTE  height of region
		   BYTE  width of region
	       4Fh  Scissors/Paste selected
		   DWORD object handle of window
		   BYTE  row of upper left corner
		   BYTE  column of upper left corner
		   BYTE  field number ul corner is in, 0=none
		   DWORD handle of orphaned window with data
		   BYTE  height of region
		   BYTE  width of region
			Note: orphaned data window should be adopted or freed
				when done
	       50h  main menu about to pop up
	       51h  main menu popped down
Return: all registers unchanged
----------1512--BH06-------------------------
INT 15 - DESQview 2.2+ - SEND MESSAGE - "SETPRI" - SET PRIORITY WITHIN OBJECTQ
	AH = 12h
	BH = 06h
	BL = object
	    00h object handle in DWORD on top of stack
		mailbox, keyboard, pointer, or timer
	    04h given task's keyboard (task's handle on top of stack)
	    05h current task's default keyboard
	STACK: DWORD new priority of object in task's OBJECTQ 
Notes:	initially all objects have the same default value.  Should only make 
	  relative adjustments to this default value.
	when changing priorities, all objects already on the objectq are
	  reordered
SeeAlso: AH=12h/BH=07h
----------1512--BH07-------------------------
INT 15 - DESQview 2.2+ - SEND MESSAGE - "GETPRI" - GET PRIORITY WITHIN OBJECTQ
	AH = 12h
	BH = 07h
	BL = object
	    00h object handle in DWORD on top of stack
		mailbox, keyboard, pointer, or timer
	    04h given task's keyboard (task's handle on top of stack)
	    05h current task's default keyboard
Return: STACK: DWORD object priority
Note:	initially all objects have the same default value.  Should only make 
	  relative adjustments to this default value.
SeeAlso: AH=12h/BH=06h
----------1512--BH08-------------------------
INT 15 - TopView - SEND MESSAGE - "SIZEOF" - GET OBJECT SIZE
	AH = 12h
	BH = 08h
	BL = object
	    00h handle in DWORD on top of stack
		window: total character positions in window
		timer: elapsed time since timer started
		pointer: number of messages queued to pointer object
		panel: number of panels in panel file
		keyboard: number of input buffers queued
	    01h total chars in current task's default window
	    02h number of messages in task's mailbox (task's handle on stack)
	    03h number of messages in current task's mailbox
	    04h number of input buffers queued in task's kbd (handle on stack)
	    05h number of input buffers queued for current task's default kbd
	    06h number of objects queued in OBJECTQ (task's handle on stack)
	    07h number of objects queued in current task's OBJECTQ
	    0Ch (DV 2.26+) total chars in window owning handle on top of stack
	    0Dh (DV 2.26+) total chars in parent task's window
Return: DWORD on top of stack is result
Note:	for panel objects, a count of zero is returned if no panel file is open
	  for the object
SeeAlso: AH=12h/BH=04h,AH=12h/BH=09h
----------1512--BH09-------------------------
INT 15 - TopView - SEND MESSAGE - "LEN" - GET OBJECT LENGTH
	AH = 12h
	BH = 09h
	BL = object
	    00h handle in DWORD on top of stack
		window: get chars/line
		timer: get 1/100 seconds remaining before timer expires
	    01h get number of chars/line in current task's default window
	    0Ch (DV 2.26+) get chars/line in window owning handle on top of stk
	    0Dh (DV 2.26+) get chars/line in parent task's window
Return: DWORD on top of stack is length
SeeAlso: AH=12h/BH=08h
----------1512--BH0A-------------------------
INT 15 - TopView - SEND MESSAGE - "ADDTO" - WRITE CHARS AND ATTRIBS TO WINDOW
	AH = 12h
	BH = 0Ah
	BL = window to write to
	    00h window handle is DWORD on top of stack
	    01h current task's default window
	    0Ch (DV 2.26+) default window of task owning handle on top of stack
	    0Dh (DV 2.26+) default window of parent of current task
	STACK:	DWORD count of attributes
		DWORD address of attribute string
		DWORD count of characters
		DWORD address of character string
Notes:	if one string is longer than the other, the shorter one will be reused
	  until the longer one is exhausted
	the cursor is left just after the last character written
SeeAlso: AH=12h/BH=0Bh"WINDOW"
----------1512--BH0A-------------------------
INT 15 - TopView - SEND MESSAGE - "ADDTO" - SEND MAILBOX MESSAGE/STAT BY VALUE
	AH = 12h
	BH = 0Ah
	BL = mailbox to write to
	    00h handle is DWORD on top of stack
	    02h default mailbox of task whose handle is on top of stack
	    03h current task's default mailbox
	STACK:	DWORD	status (low byte)
		DWORD	length of message
		DWORD	address of message
Notes:	the message is copied into either system or common memory
	insufficient memory normally causes the process to be aborted; under
	  DESQview 2.2+, failed writes may return CF set instead (see AX=DE15h)
SeeAlso: AH=12h/BH=0Bh"MAILBOX"
----------1512--BH0A-------------------------
INT 15 - TopView - SEND MESSAGE - "ADDTO" - SET OBJECT BITS
	AH = 12h
	BH = 0Ah
	BL = object
	    00h handle is DWORD on top of stack
		timer: start timer for specified interval
		pointer: set control flags
		keyboard: set control flags
	    04h set control flags on KEYBOARD object (handle on top of stack)
	    05h set control flags on task's default KEYBOARD object
	STACK: (if timer)   DWORD duration in 1/100 seconds
	       (otherwise)  DWORD bits to set
SeeAlso: AH=12h/BH=0Bh"OBJECT"

For keyboard objects, the bits have the following significance:
	bit 15 reserved, can't be set
	bit 14 unused
	bit 13 reserved, can't be set
	bit 12-6 unused
	bit 5  (DV 2.2+) exclusive input
	bit 4  filter all keys (used with handler established by SETESC)
		if 0, only keys that would normally be displayed are filtered
	bit 3  program continues executing while input in progress
	bit 2  insert mode active for field mode
	bit 1  hardware cursor displayed when task is hardware cursor owner
		must be set if keyboard in field mode and field table includes
		input fields
	bit 0  keyboard is in field mode rather than keystroke mode

For pointer objects, the bits have the following significance:
	bit 15 reserved, can't be set
	bit 14-8 unused
	bit 7  mouse pointer is hidden while in window
	bit 6  get messages even if window not topmost
	bit 5  get messages even if window not foreground
	bit 4  multiple clicks separated by less than 1/3 second are counted
		and returned in a single message
	bit 3  pointer position is relative to screen origin, not window origin
	bit 2  send message on button release as well as button press
	bit 1  (DV 2.23+) send message with row=FFFFh and col=FFFFh whenever
		pointer leaves the window
	bit 0  send message only on button activity, not movement
	       DV-specific, and INT 15h/AX=DE0Fh must have been called first
----------1512--BH0B-------------------------
INT 15 - TopView - SEND MESSAGE - "SUBFROM" - WRITE ATTRIBUTES TO WINDOW
	AH = 12h
	BH = 0Bh
	BL = window to write attributes to
	    00h handle is DWORD on top of stack
	    01h current task's default window
	    0Ch (DV 2.26+) default window of task owning handle on top of stack
	    0Dh (DV 2.26+) default window of parent of current task
	STACK:	DWORD number of attributes to write
		DWORD address of attributes
Note:	the attributes are written starting at the current cursor position; the
	  cursor is left just after the last position written
SeeAlso: AH=12h/BH=0Ah"WINDOW"
----------1512--BH0B-------------------------
INT 15 - TopView - SEND MESSAGE - "SUBFROM" - SEND MAILBOX MESSAGE/STAT BY REF
	AH = 12h
	BH = 0Bh
	BL = mailbox to write to
	    00h handle is DWORD on top of stack
	    02h default mailbox of task whose handle is on top of stack
	    03h current task's default mailbox
	STACK:	DWORD	status (low byte)
		DWORD	length of message
		DWORD	address of message
Notes:	only a pointer to the message is stored, but the write may still fail
	  due to insufficient memory
	under DV 2.2+, failed mailbox writes may return CF set (see AX=DE15h)
SeeAlso: AH=12h/BH=0Ah"MAILBOX"
----------1512--BH0B-------------------------
INT 15 - TopView - SEND MESSAGE - "SUBFROM" - REMOVE OBJECT FROM OBJECTQ
	AH = 12h
	BH = 0Bh
	BL = OBJECTQ from which to remove all copies of a particular object
	    06h OBJECTQ of task whose handle is on top of stack
	    07h task's default OBJECTQ
	STACK:	DWORD	handle of object to remove
Note:	should be sent whenever an object is erased or closed
----------1512--BH0B-------------------------
INT 15 - TopView - SEND MESSAGE - "SUBFROM" - RESET OBJECT BITS
	AH = 12h
	BH = 0Bh
	BL = object
	    00h handle is DWORD on top of stack
		pointer: reset control flags
		keyboard: reset control flags
	    04h clear control flags on KEYBOARD object (handle on top of stack)
	    05h clear control flags on task's default KEYBOARD object
	STACK:	DWORD	which bits to clear (see AH=12h/BH=0Ah"OBJECT")
SeeAlso: AH=12h/BH=0Ah"OBJECT"
----------1512--BH0C-------------------------
INT 15 - TopView - SEND MESSAGE - "OPEN" - OPEN OBJECT
	AH = 12h
	BH = 0Ch
	BL = object
	    00h handle is DWORD on top of stack
		window:   fill with given character from scroll origin to end
		keyboard: attach to a window
		timer:	  open
		pointer:  start taking input for window
		panel:	  associate with a panel file
	    01h fill task's default window with given char from scrl org to end
	    02h open given task's mailbox for input (task's handle on stack)
	    03h open current task's mailbox
	    04h attach a KEYBOARD to a window (handle on top of stack)
	    05h attach task's default KEYBOARD to a window
	    06h open a task's OBJECTQ (task's handle on top of stack)
	    07h open current task's OBJECTQ
	    0Ch (DV 2.26+) fill def window of task owning handle on top of stck
	    0Dh (DV 2.26+) fill default window of parent of current task
	 STACK: (if window)   DWORD character to fill with
		(if keyboard) DWORD handle of window to attach to
		(if pointer)  DWORD handle of window to attach to
		(if panel)    DWORD length of filename or resident panel
			      DWORD address of filename or resident panel
		(otherwise)   nothing
Notes:	if first byte of panel file name is 1Bh, then the "name" IS a panel
	if first two bytes of panel file "name" are C0hC3h, then the "name" IS
	  the panel file
	result code of open may be retrieved with STATUS message
	logical cursor is left at scroll origin after filling window
	the task opening a mailbox becomes its owner, and the only task allowed
	  to read the mailbox
	messages are only sent to a pointer object when the mouse is positioned
	  in the window to which the pointer has been attached
	there is no need to explicitly open a timer object, as ADDTO and WRITE
	  messages automatically open the timer
SeeAlso: AH=12h/BH=0Dh,AH=12h/BH=14h"LOCK"
----------1512--BH0D-------------------------
INT 15 - TopView - SEND MESSAGE - "CLOSE" - CLOSE OBJECT
	AH = 12h
	BH = 0Dh
	BL = object
	    00h handle is DWORD on top of stack
		timer:	  close
		keyboard: detach from window and discard queued input
		pointer:  stop taking input
		panel:	  close
		mailbox:  close, unlock, and discard any pending messages
	    02h close given task's mailbox (task's handle on top of stack)
	    03h close task's default mailbox
	    04h close KEYBOARD object (handle on top of stack)
	    05h close task's default KEYBOARD
	    06h close givent task's OBJECTQ (task's handle on top of stack)
	    07h close current task's OBJECTQ
Notes:	when an OBJECTQ is closed, each object in the OBJECTQ is sent an
	  ERASE message (AH=12h/BH=0Eh)
	when a panel object is closed, the panel file and any panels currently
	  in use are freed; window and keyboard objects created by APPLY are
	  not affected, but field mode input ceases
	open but idle timer objects consume a small amount of CPU time
SeeAlso: AH=12h/BH=0Ch,AH=12h/BH=0Eh,AH=12h/BH=14h"LOCK"
----------1512--BH0E-------------------------
INT 15 - TopView - SEND MESSAGE - "ERASE" - ERASE OBJECT
	AH = 12h
	BH = 0Eh
	BL = object
	    00h handle is DWORD on top of stack
		window:   clear from scroll origin to end of window
		keyboard: discard input
		timer:	  cancel current interval
		pointer:  discard all pending messages
		mailbox:  discard all pending messages
	    01h clear task's default window from scroll origin to end
	    02h discard all queued messages in mailbox (handle on top of stack)
	    03h discard all queued messages in current task's default mailbox
	    04h discard all input queued to KEYBOARD (handle on top of stack)
	    05h discard all input queued to task's default KEYBOARD
	    06h remove all objects from OBJECTQ (task's handle on top of stack)
	    07h remove all objects from current task's OBJECTQ
	    0Ch (DV 2.26+) clear window of task owning handle on top of stack
	    0Dh (DV 2.26+) clear default window of parent of current task
Note:	when an OBJECTQ is erased, each object in the OBJECTQ is also erased
SeeAlso: AH=12h/BH=02h
----------1512--BH0F-------------------------
INT 15 - TopView - SEND MESSAGE - "STATUS" - GET OBJECT STATUS
	AH = 12h
	BH = 0Fh
	BL = object
	    00h handle is DWORD on top of stack
		timer:	 is it running?
		pointer: return status of last message
		panel:	 verify success of last OPEN or APPLY
	    02h return status of last msg READ from mailbox (handle on stack)
	    03h return status of last msg READ from task's default mailbox
	    04h get status of last msg from task's KEYBOARD (task handle on stk)
	    05h get status of last msg from task's default KEYBOARD
	    06h return whether OBJECTQ is open or not (handle on top of stack)
	    07h return whether task's default OBJECTQ is open or not
Return: DWORD on top of stack is status
Notes:	if object is a panel object, the status indicates the error code:
	  00h successful
	  14h panel name not in panel directory
	  15h not enough memory to apply panel
	  16h invalid panel format
	  17h panel file already open
	  81h-92h  DOS error codes+80h			\  codes > 80h indicate
	  95h not enough memory to open panel file	 > that the panel was
	  98h null panel file name			/  not opened
	if object is a timer, the status is:
	  00000000h open but not running
	  40000000h open and running
	  80000000h closed
	if object is an OBJECTQ, the status is:
	  00000000h open
	  80000000h closed
	if object is a keyboard in keystroke mode, the status is the extended
	  character code (scan code) of teh last keystroke
	if object is a keyboard in field mode, the status indicates the reason
	  for the last return from the field manager
	  00h Enter key pressed
	  01h Button 1 or keystroke selection
	  02h Button 2
	  03h validation
	  04h auto Enter on field
	  1Bh Escape pressed
	  46h ^Break pressed
	  other: extended code for key terminating input
	the status of mailbox messages sent by the window manager is always 80h
	the status of a pointer message is the same as the status field in the
	  message
SeeAlso: AH=12h/BH=04h"READ"
----------1512--BH10-------------------------
INT 15 - TopView - SEND MESSAGE - "EOF" - GET OBJECT EOF STATUS
	AH = 12h
	BH = 10h
	BL = object
	    00h handle is DWORD on top of stack
		window: return TRUE if logical cursor past end of window
		mailbox: ???
	    01h returns TRUE if logical cursor past end of task's def window
	    02h return ??? for task's mailbox (task's handle on top of stack)
	    03h return ??? for current task's mailbox
	    0Ch (DV 2.26+) check log crsr of window owning handle on top of stk
	    0Dh (DV 2.26+) check log cursor of window of parent task
Return: DWORD on top of stack is status
----------1512--BH11-------------------------
INT 15 - TopView - SEND MESSAGE - "AT" - POSITION OBJECT CURSOR
	AH = 12h
	BH = 11h
	BL = window for which to move cursor
	    00h window's handle is DWORD on top of stack
	    01h task's default window
	    0Ch (DV 2.26+) default window of task owning handle on top of stack
	    0Dh (DV 2.26+) default window of parent of current task
	STACK: DWORD column
	       DWORD row
----------1512--BH11-------------------------
INT 15 - TopView - SEND MESSAGE - "SETNAME" - ASSIGN NAME TO MAILBOX
	AH = 12h
	BH = 11h
	BL = mailbox to name
	    00h DWORD on top of stack is mailbox handle
	    02h use given task's mailbox (task's handle on top of stack)
	    03h use current task's default mailbox
	STACK: DWORD length of name
	       DWORD address of name
SeeAlso: AX=DE0Eh
----------1512--BX1100-----------------------
INT 15 - TopView - SEND MESSAGE - "SETSCALE" - SET POINTER SCALE FACTOR
	AH = 12h
	BX = 1100h
	STACK: DWORD object handle for pointer object
	       DWORD number of colums to scale pointer position to
	       DWORD number of rows to scale pointer position to
SeeAlso: AH=12h/BX=1200h
----------1512--BH12-------------------------
INT 15 - TopView - SEND MESSAGE - "READN" - GET NEXT N OBJECT BYTES
	AH = 12h
	BH = 12h
	BL = window to read from
	    00h handle is DWORD on top of stack
	    01h read next N chars or attributes on task's default window
	    0Ch (DV 2.26+) read window of task owning handle on top of stack
	    0Dh (DV 2.26+) read default window of parent of current task
	STACK: DWORD count
Return: STACK: DWORD width of screen line
	       DWORD address
	       DWORD count actually read
Notes:	reading starts at the current logical cursor position; the cursor is
	  updated to point at the character following the last one read
	any translucent blanks (FFh) which are visible on screen are changed
	  to the character which is seen through them
	the string produced by the read is placed in an input buffer which may
	  be reused by the next READ or READN of a window
	window stream opcodes D8h and D9h determine whether the read returns
	  characters or attributes
SeeAlso: AH=12h/BH=04h"WINDOW",AH=12h/BH=05h"WINDOW"
----------1512--BX1200-----------------------
INT 15 - TopView - SEND MESSAGE - "GETSCALE" - GET POINTER SCALE FACTOR
	AH = 12h
	BX = 1200h
	STACK: DWORD object handle for pointer
Return: STACK: DWORD pointer pos scaled as if window were this many colums wide
	       DWORD pointer pos scaled as if window were this many rows high
SeeAlso: AH=12h/BX=1100h
----------1512--BH13-------------------------
INT 15 - TopView - SEND MESSAGE - "REDRAW" - REDRAW WINDOW
	AH = 12h
	BH = 13h
	BL = window object
	    00h DWORD on top of stack is handle for window to redraw
	    01h redraw task's default window
	    0Ch (DV 2.26+) redraw window of task owning handle on top of stack
	    0Dh (DV 2.26+) redraw default window of parent of current task
SeeAlso: AH=12h/BH=0Eh
----------1512--BX1300-----------------------
INT 15 - TopView - SEND MESSAGE - "SETICON" - SPECIFY POINTER ICON
	AH = 12h
	BX = 1300h
	STACK: DWORD object handle for pointer
	       DWORD character to use for pointer
----------1512--BH14-------------------------
INT 15 - TopView - SEND MESSAGE - "SETESC" - SET ESCAPE ROUTINE ADDRESS
	AH = 12h
	BH = 14h
	BL = message modifier
	    00h handle is DWORD on top of stack
	    01h define user stream
	    04h intercept keystrokes from KEYBOARD to a window (handle on stack)
	    05h intercept keystrokes from task's default KEYBOARD to a window
	STACK: (if window)   DWORD user stream number (14h-1Fh)
			     DWORD address of FAR user stream handler
	       (if keyboard) DWORD address of FAR filter function

The keyboard filter function is called when the keyboard is in field mode.  On
entry,
	AL = character
	AH = 00h or extended ASCII code if AL = 00h
	BL = field number
	CH = cursor column
	CL = cursor row
	DL = field type modifier (sixth item in field table entry)
	DH = seventh item in field table entry
	ES:SI = window's handle
	DS:DI -> field table entry for field containing the cursor
The filter function should return
	AH = 00h use keystroke
	     01h ignore keystroke
	     FFh beep and ignore keystroke
Note: the filter function is not allowed to make INT 15, DOS, or BIOS calls
----------1512--BH14-------------------------
INT 15 - TopView - SEND MESSAGE - "LOCK" - REQUEST EXCLUSIVE ACCESS TO RESOURCE
	AH = 12h
	BH = 14h
	BL = object
	    00h mailbox handle is DWORD on top of stack
	    02h use given task's mailbox (task's handle on top of stack)
	    03h use current task's default mailbox
Note:	release exclusive access by sending CLOSE message to mailbox
	access may be requested multiple times, and requires multiple CLOSEs
SeeAlso: AH=12h/BH=0Dh
----------1512--BH15-------------------------
INT 15 - DESQview 2.2+ - SEND MESSAGE - "SETFLAGS" - SET OBJECT FLAGS
	AH = 12h
	BH = 15h
	BL = object
	    00h DWORD on top of stack
		mailbox, keyboard, or pointer only
	    02h mailbox for task whose handle is on top of stack
	    03h mailbox for current task
	    04h keyboard for task whose handle is on top of stack
	    05h keyboard for current task
	STACK: DWORD flags
		if mailbox:
			bit 0: all mail messages in common memory
			bit 1: allow write even if closed
			bit 2: don't erase messages when mailbox closed
		if keyboard:
			bit 5: exclusive input when keyboard in use for input
Return: nothing
Notes:	only available if the API level has been set to at least 2.20
	equivalent to performing SUBFROM and ADDTO calls on the object
SeeAlso: AH=12h/BH=0Ah,AH=12h/BH=0Bh,AH=12h/BH=16h
----------1512--BH16-------------------------
INT 15 - DESQview 2.2+ - SEND MESSAGE - "GETFLAGS" - GET OBJECT FLAGS
	AH = 12h 
	BH = 16h
	BL = object
	    00h DWORD on top of stack
		mailbox, keyboard, or pointer only
	    02h mailbox for task whose handle is on top of stack
	    03h mailbox for current task
	    04h keyboard for task whose handle is on top of stack
	    05h keyboard for current task
Return: STACK: DWORD current control flags
Note:	only available if the API level has been set to at least 2.20
SeeAlso: AH=12h/BH=0Ah,AH=12h/BH=0Bh,AH=12h/BH=15h
----------1513-------------------------------
INT 15 - VMiX - WAKE PROCESS
	AH = 13h
	STACK:	WORD	process ID
Return: AX = status
----------1514-------------------------------
INT 15 - VMiX - CLEAR WINDOW
	AH = 14h
	STACK:	WORD	top left corner of window
		WORD	bottom right corner of window
Return: AX = status
----------1515-------------------------------
INT 15 - VMiX - SET BANNER WINDOW MESSAGE
	AH = 15h
	STACK:	DWORD	pointer to ASCIZ banner	message
Return: AX = status
----------1516-------------------------------
INT 15 - VMiX - SET ROOT WINDOW SIZE AND HOME CURSOR
	AH = 16h
	STACK:	DWORD	pointer to I/O Request Packet
		WORD	top left corner of window
		WORD	bottom right corner of window
Return: AX = status
----------1517-------------------------------
INT 15 - VMiX - GET CONSOLE WINDOW COLORS
	AH = 17h
Return: AH = foreground color
	AL = background color
SeeAlso: AH=18h
----------1518-------------------------------
INT 15 - VMiX - SET CONSOLE COLORS
	AH = 18h
	STACK:	WORD	new background/foreground colors
Return: AX = color
SeeAlso: AH=17h
----------1519-------------------------------
INT 15 - VMiX v2+ - ???
	AH = 19h
	STACK: WORD ???
Return: ???
----------151A-------------------------------
INT 15 - VMiX v2+ - ???
	AH = 1Ah
	STACK: 3 WORDs ???
Return: ???
----------151B-------------------------------
INT 15 - VMiX v2+ - ???
	AH = 1Bh
	STACK: 5 WORDs ???
Return: ???
----------151C-------------------------------
INT 15 - VMiX v2+ - ???
	AH = 1Ch
	STACK: 5 WORDs ???
Return: ???
----------151D-------------------------------
INT 15 - VMiX v2+ - ???
	AH = 1Dh
	???
Return: ???
----------151E-------------------------------
INT 15 - VMiX v2+ - ???
	AH = 1Eh
	STACK: WORD ???
Return: ???
----------152000-----------------------------
INT 15 - DOS 3.x PRINT.COM - DISABLE CRITICAL REGION FLAG (AT,XT286,PS50+)
	AX = 2000h
SeeAlso: AX=2001h
----------152001-----------------------------
INT 15 - DOS 3.x PRINT.COM - SET CRITICAL REGION FLAG (AT,XT286,PS50+)
	AX = 2001h
	ES:BX -> byte which is to be incremented while in a DOS call
SeeAlso: AX=2000h
----------152010-----------------------------
INT 15 - OS HOOK - SETUP SYSREQ ROUTINE (AT,XT286,PS50+)
	AX = 2010h
	???
Return: ???
SeeAlso: AX=2011h
----------152011-----------------------------
INT 15 - OS HOOK - COMPLETION OF SYSREQ FUNCTION (AT,XT286,PS50+)
	AX = 2011h
	???
Return: ???
SeeAlso: AX=2010h
----------1521-------------------------------
INT 15 - SYSTEM - POWER-ON SELF-TEST ERROR LOG (PS50+)
	AH = 21h
	AL = subfunction
	    00h read POST log
	    01h write POST log
		BH = device ID
		BL = error code
Return: CF set on error
	AH = status (00h OK, 01h list full, 80h invalid cmd, 86h unsupported)
	if function 00h:
	   BX = number of error codes stored
	   ES:DI -> error log
Note:	the log is a series of words, the first byte of which identifies the
	  error code and the second the device.
----------1540-------------------------------
INT 15 - SYSTEM - READ/MODIFY PROFILES (CONVERTIBLE)
	AH = 40h
	AL = subfunction
	    00h get system profile in CX and BX
	    01h set system profile from CX and BX
	    02h get internal modem profile in BX
	    03h set internal modem profile from BX
----------154000-----------------------------
INT 15 - Compaq SLT/286 or Portable 386 - READ LCD/PLASMA TIMEOUT
	AX = 4000h
Return: AX = 4000h
	CL = 00h timeout disabled
	   else timeout in minutes
SeeAlso: AX=4001h,AX=4600h
----------154001-----------------------------
INT 15 - Compaq SLT/286 or Portable 386 - SET LCD/PLASMA TIMEOUT
	AX = 4001h
	CL = 00h timeout disabled
	   else  timeout in minutes
Return: AL = 00h timeout modified
	     01h timeout cannot be modified
	     40h timeout cannot be modified
	CL = 00h timeout disabled
	   else timeout in minutes
SeeAlso: AX=4000h,AX=4601h
----------1541-------------------------------
INT 15 - SYSTEM - WAIT ON EXTERNAL EVENT (CONVERTIBLE)
	AH = 41h
	AL = condition type
	    bits 0-2: condition to wait for
		     0 any external event
		     1 compare and return if equal
		     2 compare and return if not equal
		     3 test and return if not zero
		     4 test and return if zero
	    bit 3:    reserved
	    bit 4:    1=port address, 0=user byte
	    bits 5-7: reserved
	BH = condition compare or mask value
	BL = timeout value times 55 milliseconds
	    00h means no timeout
	DX = I/O port address if AL bit 4 set
	ES:DI -> user byte if AL bit 4 clear
----------1542-------------------------------
INT 15 - SYSTEM - REQUEST POWER OFF (CONVERTIBLE)
	AH = 42h
	AL = 00h to use system profile
	     01h to force suspend regardless of system profile
SeeAlso: AH=44h
----------154280-----------------------------
INT 15 - Compaq SLT/286 - ENTER STANDBY
	AX = 4280h
Return: AH = 42h
	CF clear if successful
	CF set if unable to enter standby
SeeAlso: AX=4600h
----------1543-------------------------------
INT 15 - SYSTEM - READ SYSTEM STATUS (CONVERTIBLE)
	AH = 43h
Return: AL = status bits
	    bit 0: LCD detached
	    bit 1: reserved
	    bit 2: RS232/parallel adapter powered on
	    bit 3: internal modem powered on
	    bit 4: power activated by alarm
	    bit 5: standby power lost
	    bit 6: external power in use
	    bit 7: power low
----------1544-------------------------------
INT 15 - SYSTEM - (DE)ACTIVATE INTERNAL MODEM POWER (CONVERTIBLE)
	AH = 44h
	AL = 00h to power off
	     01h to power on
SeeAlso: AH=42h
----------154600-----------------------------
INT 15 - Compaq SLT/286 - READ POWER CONSERVATION/MODEM CONFIGURATION
	AX = 4600h
Return: AH = modem configuration information
	    bit 0 powerup state
		    0 off
		    1 on
	    	1 modem installed
		2 IRQ line assignment
		    0 IRQ 4
		    1 IRQ 3
		3 COM port assignment
		    0 = COM 2
		    1 = COM 1
		4 modem state
		    0 not assigned
		    1 assigned
		5 modem is on
	AL = power conservation status information
	    bit 0  power source (0 internal, 1 external)
	       1-2 low battery state
		    00 no low battery condition
		    01 low battery 1
		    10 reserved
		    11 low battery 2
	       3-4 power conservation mode
		    00 automatic
		    01 on
		    10 off
		    11 reserved
	BH = default system inactivity timeout (1-21 minutes)
	BL = current system inactivity timeout (1-21 minutes)
	CH = default video display inactivity timeout (1-63 minutes)
	CL = current video display inactivity timeout (1-63 minutes)	    
	DH = default fixed disk drive inactivity timeout (1-21 minutes)
	DL = current fixed disk drive inactivity timeout (1-21 minutes)
SeeAlso: AX=4280h,AX=4601h,INT 77
----------154601-----------------------------
INT 15 - Compaq SLT/286 - Modify Power Conservation/Modem Configuration
	AX = 4601h
	BL = system inactivity timeout (1-21 minutes)
	   = FFh do not change
	CL = video display inactivity timeout (1-63 minutes)	    
	   = FFh do not change
	DL = current fixed disk drive inactivity timeout (1-21 minutes)
	   = FFh do not change
	DH = 00h turn modem OFF
	   = 01h turn modem ON
	   = FFh do not change modem state
Return: CF clear if successful
	    AH = 00h
	    BL = current system inactivity timeout (1-21 minutes)
	    CL = current video display inactivity timeout (1-63 minutes)	
	    DL = current fixed disk drive inactivity timeout (1-21 minutes)
	    DH = FFh modem state unchanged
	       = 00h modem turned OFF
	       = 01h modem turned ON
	CF set on error
	    AH = 01h input is out of range
	       = 02h - No modem present
SeeAlso: AX=4600h,INT 77
----------154F-------------------------------
INT 15 - OS HOOK - KEYBOARD INTERCEPT (AT model 3x9,XT2,XT286,CONV,PS)
	AH = 4Fh
	AL = scan code
	CF set
Return: CF set
	   AL = scan code
	CF clear
	   scan code should be ignored
Note:	called by INT 9 handler to translate scan codes
SeeAlso: INT 09
----------155400-----------------------------
INT 15 - Omniview Multitasker - INSTALLATION NOTIFICATION
	AX = 5400h
	ES:BX -> device information tables
	DI:DX -> dispatcher entry point
Note:	called by OmniView to notify programs loaded before OmniView of state
	  changes inside OmniView
SeeAlso: AX=5407h
----------155401-----------------------------
INT 15 - Omniview Multitasker - PROCESS CREATION
	AX = 5401h
	ES:BX = process handle
Note:	called by OmniView to notify programs loaded before OmniView of state
	  changes inside OmniView
SeeAlso: AX=5402h
----------155402-----------------------------
INT 15 - Omniview Multitasker - PROCESS DESTRUCTION
	AX = 5402h
	ES:DX = process handle
Note:	called by OmniView to notify programs loaded before OmniView of state
	  changes inside OmniView
SeeAlso: AX=5401h
----------155403-----------------------------
INT 15 - Omniview Multitasker - SAVE
	AX = 5403h
	ES:DX = process swapping out
Note:	called by OmniView to notify programs loaded before OmniView of state
	  changes inside OmniView
SeeAlso: AX=5404h
----------155404-----------------------------
INT 15 - Omniview Multitasker - RESTORE
	AX = 5404h
	ES:DX = process swapping in
Note:	called by OmniView to notify programs loaded before OmniView of state
	  changes inside OmniView
SeeAlso: AX=5403h
----------155405-----------------------------
INT 15 - Omniview Multitasker - SWITCHING TO BACKGROUND
	AX = 5405h
	ES:DX = process swapping in
Note:	called by OmniView to notify programs loaded before OmniView of state
	  changes inside OmniView
SeeAlso: AX=5406h
----------155406-----------------------------
INT 15 - Omniview Multitasker - SWITCHING TO FOREGROUND
	AX = 5406h
	ES:DX = process swapping in
Note:	called by OmniView to notify programs loaded before OmniView of state
	  changes inside OmniView
SeeAlso: AX=5405h
----------155407-----------------------------
INT 15 - Omniview Multitasker - EXIT NOTIFICATION
	AX = 5407h
Note:	called by OmniView to notify programs loaded before OmniView of state
	  changes inside OmniView
SeeAlso: AX=5400h
----------1580-------------------------------
INT 15 - OS HOOK - DEVICE OPEN (AT,XT2,XT286,PS)
	AH = 80h
	BX = device ID
	CX = process type
Return: CF set on error
	    AH = status
	CF clear if successful
	    AH = 00h	    
SeeAlso: AH=81h,82h
----------1581-------------------------------
INT 15 - OS HOOK - DEVICE CLOSE (AT,XT2,XT286,PS)
	AH = 81h
	BX = device ID
	CX = process type
Return: CF set on error
	    AH = status
	CF clear if successful
	    AH = 00h	    
SeeAlso: AH=80h,82h
----------1582-------------------------------
INT 15 - OS HOOK - DEVICE PROGRAM TERMINATE (AT,XT2,XT286,PS)
	AH = 82h
	BX = device ID
Return: CF set on error
	    AH = status
	CF clear if successful
	    AH = 00h	    
Note:	closes all devices opened with function 80h
SeeAlso: AH=80h,81h
----------1583-------------------------------
INT 15 - SYSTEM - EVENT WAIT (AT,XT286,CONV,PS)
	AH = 83h
	AL = subservice
	    00h = set interval
	    01h = cancel
	ES:BX -> event flag (bit 7 set when interval expires)
	CX:DX = number of microseconds to wait (only accurate to 977 us)
Return: CF set if function already busy
Note:	the resolution of the wait period is 977 microseconds on most systems
	  because most BIOSes use the 1/1024 second fast interrupt from the AT
	  real-time clock chip which is available on INT 70
SeeAlso: AH=86h, INT 70
----------1584-------------------------------
INT 15 - SYSTEM - READ JOYSTICK (AT,XT2,XT286,PS)
	AH = 84h
	DX = subservice
	    0000h get switch settings
		Return: AL = switch settings
			    bit 7: stick B button 2
			    bit 6: stick B button 1
			    bit 5: stick A button 2
			    bit 4: stick A button 1
	    0001h read joystick inputs
		Return: AX = A(x) value
			BX = A(y) value
			CX = B(x) value
			DX = B(y) value
----------1585-------------------------------
INT 15 - OS HOOK - SYSTEM REQUEST KEY PRESSED (AT,XT2,XT286,CONV,PS)
	AH = 85h
	AL = 00h press
	   = 01h release
Return: CF set on error
	AH = status
Note:	called by keyboard decode routine
SeeAlso: INT 09
----------1586-------------------------------
INT 15 - SYSTEM - WAIT (AT,XT2,XT286,CONV,PS)
	AH = 86h
	CX,DX = number of microseconds to wait (only accurate to 977 us)
Return: CF clear: after wait elapses
	CF set: immediately due to error
Note:	the resolution of the wait period is 977 microseconds on most systems
	  because most BIOSes use the 1/1024 second fast interrupt from the AT
	  real-time clock chip which is available on INT 70
SeeAlso: AH=83h, INT 70
----------1587-------------------------------
INT 15 - EXTENDED MEMORY - BLOCK MOVE (AT,XT286,PS)
	AH = 87h
	CX = number of words to move
	ES:SI -> global descriptor table (see below)
Return: CF set on error
	AH = status
	    00h source copied into destination
	    01h parity error
	    02h interrupt error
	    03h address line 20 gating failed
SeeAlso: AH=88h

Format of global descriptor table:
Offset	Size	Description
 00h 16 BYTEs	zeros
 10h	WORD	source segment length in bytes (2*CX-1 or greater)
 12h  3 BYTEs	24-bit linear source address, low byte first
 15h	BYTE	source segment access rights (93h)
 16h	WORD	zero
 18h	WORD	destination segment length in bytes (2*CX-1 or greater)
 1Ah  3 BYTEs	24-bit linear destination address, low byte first
 1Dh	BYTE	destination segment access rights (93h)
 1Eh 18 BYTEs	zeros
----------1588-------------------------------
INT 15 - EXTENDED MEMORY - GET MEMORY SIZE (AT,XT286,PS)
	AH = 88h
Return: AX = memory size in K
SeeAlso: AH=87h
Note:	TSRs which wish to allocate extended memory to themselves often hook
	  this call, and return a reduced memory size.	They are then free to
	  use the memory between the new and old sizes at will.
----------1589-------------------------------
INT 15 - SYSTEM - SWITCH TO VIRTUAL MODE (AT,XT286,PS50+)
	AH = 89h
	BL = interrupt number of IRQ0 (IRQ1-7 use next 7 interrupts)
	BH = interrupt number of IRQ8 (IRQ9-F use next 7 interrupts)
	DS:SI -> GDT for protected mode
	       offset 0h  null descriptor
		      8h  GDT descriptor
		     10h  IDT descriptor
		     18h  DS
		     20h  ES
		     28h  SS
		     30h  CS
		     38h  uninitialized, used to build descriptor for BIOS CS
	CX = offset into protected-mode CS to jump to
Return: CF set on error
	   AH = 0FFh  error enabling address line 20
	in protected mode at specified address if successful
SeeAlso: INT 67/AX=DE0Ch
----------1590-------------------------------
INT 15 - OS HOOK - DEVICE BUSY LOOP (AT,XT2,XT286,CONV,PS)
	AH = 90h
	AL = type code
	    00h disk
	    01h diskette
	    02h keyboard
	    03h PS/2 pointing device
	    80h network
	    FCh disk reset
	    FDh diskette motor start
	    FEh printer
	ES:BX -> request block for type codes 80h through BFh
Return: CF set if wait time satisfied
	CF clear if driver must perform wait
Note:	type codes are allocated as follows:
	  00-7F non-reentrant devices; OS must arbitrate access
	  80-BF reentrant devices; ES:BX points to a unique control block
	  C0-FF wait-only calls, no complementary INT 15/AH=91h call
SeeAlso: AH=91h
----------1591-------------------------------
INT 15 - OS HOOK - SET FLAG AND COMPLETE INTERRUPT (AT,XT2,XT286,CONV,PS)
	AH = 91h
	AL = type code (see AH=90h)
	ES:BX -> request block for type codes 80h through BFh
Return: AH = 00h
SeeAlso: AH=90h
----------15C0-------------------------------
INT 15 - SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
	AH = C0h
Return: CF set if BIOS doesn't support call
	CF clear on success
	    ES:BX -> ROM table (see below)
Note:	the 1/10/86 XT BIOS returns an incorrect value for the feature byte

Format of ROM configuration table:
Offset	Size	Description
 00h	WORD	number of bytes following
 02h	BYTE	model (see below)
 03h	BYTE	submodel (see below)
 04h	BYTE	BIOS revision: 0 for first release, 1 for 2nd, etc.
 05h	BYTE	features:
		bit 7 = DMA channel 3 used by hard disk BIOS
		bit 6 = 2nd 8259 installed
		bit 5 = Real-Time Clock installed
		bit 4 = INT 15h/AH=4Fh called upon INT 9h
		bit 3 = wait for external event supported
		bit 2 = extended BIOS area allocated at 640K
		bit 1 = bus is Micro Channel instead of ISA
		bit 0 reserved
 06h	WORD	reserved (0)
 08h	WORD	reserved (0)
 0Ah		AWARD copyright notice here

Values for model/submodel/revision:
Model  Submdl  Rev	BIOS date	System
 FFh	*	*	04/24/81	PC (original)
 FFh	*	*	10/19/81	PC (some bugfixes)
 FFh	*	*	10/27/82	PC (HD, 640K, EGA support)
 FEh	*	*	08/16/82	PC XT
 FEh	*	*	11/08/82	PC XT and Portable
 FDh	*	*	06/01/83	PCjr
 FCh	*	*	01/10/84	AT models 068,099 6 MHz 20MB
 FCh	00h	01h	06/10/85	AT model  239	  6 MHz 30MB
 FCh	00h	<> 01h	  ???		7531/2 Industrial AT
 FCh	01h	00h	11/15/85	AT models 319,339 8 MHz, Enh Keyb, 3.5"
 FCh	01h	00h	01/15&88	Toshiba T5200/100
 FCh	01h	00h	12/26*89	Toshiba T1200/XE
			(Those date characters are not typos)
 FCh	01h	???	  ???		Compaq 286/386
 FCh	02h	00h	04/21/86	PC XT-286
 FCh	04h	00h	02/13/87     ** PS/2 Model 50
 FCh	04h	03h	04/18/88	PS/2 Model 50Z
 FCh	05h	00h	02/13/87     ** PS/2 Model 60
 FCh	06h	???	  ???		7552 "Gearbox"
 FCh	09h	02h	06/28/89	PS/2 Model 30-286
 FCh	0Bh	00h	02/16/90	PS/1
 FCh	81h	00h	01/15/88	Phoenix 386 BIOS v1.10 10a
 FBh	00h	01h	01/10/86	PC XT, Enh Keyb, 3.5" support
 FBh	00h	02h	05/09/86	PC XT
 FAh	00h	00h	09/02/86	PS/2 Model 30
 FAh	00h	01h	12/12/86	PS/2 Model 30
 FAh	01h	00h	  ???		PS/2 Model 25
 F9h	00h	00h	09/13/85	PC Convertible
 F8h	00h	00h	03/30/87     ** PS/2 Model 80 16MHz
 F8h	01h	00h	10/07/87	PS/2 Model 80 20MHz
 F8h	04h	02h	04/11/88	PS/2 Model 70 20MHz, type 2 system brd
 F8h	04h	03h	03/17/89	PS/2 Model 70 20MHz, type 2 system brd
 F8h	09h	???	  ???		PS/2 Model 70 16MHz, type 1 system brd
 F8h	09h	02h	04/11/88	PS/2 Model 70 some models
 F8h	09h	03h	03/17/89	PS/2 Model 70 some models
 F8h	0Bh	00h	01/18/89	PS/2 Model P70 (8573-121)
 F8h	0Bh	02h	12/16/89	PS/2 Model P70 ??
 F8h	0Ch	00h	11/02/88	PS/2 Model 55SX
 F8h	0Dh	???	  ???		PS/2 Model 70 25MHz, type 3 system brd
 F8h	11h	00h	10/01/90	PS/2 Model ??
 F8h	13h	00h	10/01/90	PS/2 Model ??
 F8h	14h	00h	10/01/90	PS/2 Model 90-AK9
 F8h	16h	00h	10/01/90	PS/2 Model 90-AKD
 F8h	1Bh	00h	10/02/89	PS/2 Model 70-486
 F8h	1Ch	00h	02/08/90	PS/2 Model 65-121
 F8h	1Eh	00h	02/08/90	PS/2 Model ??
 F8h	50h	01h	12/16/89	PS/2 Model P70 (8570-031)
 F8h	80h	01h	11/21/89	PS/2 Model 80-A21
 9Ah	*	*	  ???		Compaq XT/Compaq Plus
 30h	???	???	  ???		Sperry PC
 2Dh	*	*	  ???		Compaq PC/Compaq Deskpro

    * This BIOS call is not implemented in these early versions.
      Read Model byte at F000h:FFFEh and BIOS date at F000h:FFF5h.
   ** These BIOS versions require the DASDDRVR.SYS patches.
----------15C1-------------------------------
INT 15 - SYSTEM - RETURN EXTENDED-BIOS DATA-AREA SEGMENT ADDRESS (PS)
	AH = C1h
Return: CF set on error
	CF clear if successful
	    ES = segment of data area
SeeAlso: AH=04h"ABIOS"
----------15C200-----------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - ENABLE/DISABLE
	AX = C200h
	BH = 00h disable
	     01h enable
Return: CF set on error
	AH = status
	    00h successful
	    01h invalid function
	    02h invalid input
	    03h interface error
	    04h need to resend
	    05h no device handler installed
----------15C201-----------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - RESET
	AX = C201h
Return: CF set on error
 	    AH = status (see AX=C200h)
	CF clear if successful
	    BH = device ID
SeeAlso: INT 33/AX=0000h
----------15C202-----------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - SET SAMPLING RATE
	AX = C202h
	BH = sampling rate
	    00h 10/second
	    01h 20/second
	    02h 40/second
	    03h 60/second
	    04h 80/second
	    05h 100/second
	    06h 200/second
Return: CF set on error
	    AH = status (see AX=C200h)
SeeAlso: INT 33/AX=001Ch
----------15C203-----------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - SET RESOLUTION
	AX = C203h
	BH = resolution
	    00h one count per mm
	    01h two counts per mm
	    02h four counts per mm
	    03h eight counts per mm
Return: CF set on error
	    AH = status (see AX=C200h)
----------15C204-----------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - GET TYPE
	AX = C204h
Return: CF set on error
	    AH = status (see AX=C200h)
	CF clear if successful
	    BH = device ID
----------15C205-----------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - INITIALIZE
	AX = C205h
	BH = data package size (1 - 8 bytes)
Return: CF set on error
	    AH = status (see AX=C200h)
SeeAlso: AX=C201h
----------15C206-----------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - GET/SET SCALING FACTOR
	AX = C206h
	BH = subfunction
	    00h return device status
		Return: BL = status
			   bit 0: right button pressed
			   bit 1: reserved
			   bit 2: left button pressed
			   bit 3: reserved
			   bit 4: 0 if 1:1 scaling, 1 if 2:1 scaling
			   bit 5: device enabled
			   bit 6: 0 if stream mode, 1 if remote mode
			   bit 7: reserved
			CL = resolution (see AX=C203h)
  			DL = sample rate, reports per second
	    01h set scaling at 1:1
 	    02h set scaling at 2:1
Return: CF set on error
	    AH = status (see AX=C200h)
----------15C207-----------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - SET DEVICE HANDLER ADDR
	AX = C207h
	ES:BX = user device handler
Return: CF set on error
	    AH = status (see AX=C200h)
SeeAlso: INT 33/AX=000Ch
----------15C3------------------------------
INT 15 - SYSTEM - ENABLE/DISABLE WATCHDOG TIMEOUT (PS50+)
	AH = C3h
	AL = 00h disable
	     01h enable
		BX = timer counter
Return: CF set on error
	CF clear if successful
Note:	the watchdog timer generates an NMI
----------15C4-------------------------------
INT 15 - SYSTEM - PROGRAMMABLE OPTION SELECT (PS50+)
	AH = C4h
	AL = 00h return base POS register address
	     01h enable slot
		 BL = slot number
	     02h enable adapter
Return: CF set on error
	DX = base POS register address (if function 00h)
----------15D800-----------------------------
INT 15 - EISA SYSTEM ROM - READ SLOT CONFIGURATION INFORMATION
	AX = D800h
	CL = slot number (including embedded and virtual)
Return: CF clear if successful
	    AH = 00h
	CF set on error
	    AH = error code
		80h invalid slot number
		82h EISA CMOS corrupt
		83h empty slot
		86h invalid BIOS-FW function call
		87h invalid system configuration
	AL bit flags
	    bit 7: set if duplicate IDs
		6: set if product ID readable
	      4,5: slot type (00=expansion, 01=embedded, 10=virtual device)
	      0-3: duplicate ID number if bit 7 set
	BH = major revision level of configuration utility
	BL = minor revision level of configuration utility
	CX = checksum of configuration file
	DH = number of device functions
	DL = combined function information byte
	SI:DI = 4-byte compressed ID (DI = bytes 0&1, SI = bytes 2&3)
Note:	call with AL=80h if using 32-bit CS addressing mode instead of 16-bit
SeeAlso: AX=D801h,AX=D804h
----------15D801-----------------------------
INT 15 - EISA SYSTEM ROM - READ FUNCTION CONFIGURATION INFORMATION
	AX = D801h
	CH = function number to read
	CL = slot number (including embedded and virtual)
	DS:SI -> 320-byte buffer for standard configuration data block
Return: CF clear if successful
	    AH = 00h
	    DS:SI buffer filled
	CF set on error
	    AH = error code
		80h invalid slot number
		81h invalid function number
		82h EISA CMOS corrupt
		83h empty slot
		86h invalid BIOS-FW function call
		87h invalid system configuration
	BX destroyed
Note:	call with AL=81h if using 32-bit CS addressing mode instead of 16-bit
----------15D802-----------------------------
INT 15 - EISA SYSTEM ROM - CLEAR NONVOLATILE MEMORY (EISA CMOS)
	AX = D802h
	BH = EISA config utility major revision level
	BL = EISA config utility minor revision level
Return: CF clear if successful
	    AH = 00h
	CF set on error
	    AH = error code
		84h error clearing CMOS
		86h invalid BIOS-FW function call
		88h config utility version not supported
Note:	call with AL=82h if using 32-bit CS addressing mode instead of 16-bit
SeeAlso: AX=D803h
----------15D803-----------------------------
INT 15 - EISA SYSTEM ROM - WRITE NONVOLATILE MEMORY
	AX = D803h
	CX = length of data structure (0000h = empty slot)
		includes two bytes for config file checksum
	DS:SI -> configuration data
Return: CF clear if successful
	    AH = 00h
	CF set on error
	    AH = error code
		84h error clearing CMOS
		85h EISA CMOS is full
		86h invalid BIOS-FW function call
Note:	call with AL=83h if using 32-bit CS addressing mode instead of 16-bit
SeeAlso: AX=D802h
----------15D804-----------------------------
INT 15 - EISA SYSTEM ROM - READ PHYSICAL SLOT
	AX = D804h
	CL = slot number (including embedded and virtual)
Return: CF clear if successful
	    AH = 00h
	CF set on error
	    AH = error code
		80h invalid slot number
		83h empty slot
		86h invalid BIOS-FW function call
	SI:DI = 4-byte compressed ID (DI = bytes 0&1, SI = bytes 2&3)
Note:	call with AL=84h if using 32-bit CS addressing mode instead of 16-bit
SeeAlso: AX=D800h
----------15D8-------------------------------
INT 15 - EISA SYSTEM ROM - 32-bit CS ADDRESSING MODE CALLS
	AH = D8h
	AL = 80h to 84h
	other registers as appropriate for AL=00h to 04h
Return: as appropriate for AL=00h to 04h
Note:	these functions are identical to AX=D800h to D804h, except that they
	  should be called when using 32-bit CS addressing mode (pointers use
	  ESI rather than SI as offset) instead of 16-bit addressing mode
SeeAlso: AX=D800h, AX=D801h, AX=D802h, AX=D803h, AX=D804h
----------15DE00-----------------------------
INT 15 - DESQview - GET PROGRAM NAME
	AX = DE00h
Return: AX = offset into DESQVIEW.DVO of current program's record (see below)
SeeAlso: AX=DE07h

Format of program entry in DESQVIEW.DVO:
Offset	Size	Description
 00h	BYTE	length of name
 01h  N BYTEs	name
      2 BYTEs	keys to invoke program (second = 00h if only one key used)
	WORD	??? seems always to be 0000h
	BYTE	end flag: 00h for all but last entry, which is FFh
----------15DE01-----------------------------
INT 15 - DESQview - UPDATE "OPEN WINDOW" MENU
	AX = DE01h
Return: nothing
Note:	reads DESQVIEW.DVO, disables Open menu if file not in current directory
----------15DE02-----------------------------
INT 15 - DESQview 1.x only - SET ??? FLAG FOR CURRENT WINDOW
	AX = DE02h
Return: nothing
Note:	this call is a NOP in DV 2.x
SeeAlso: AX=DE03h
----------15DE03-----------------------------
INT 15 - DESQview 1.x only - GET ??? FOR CURRENT WINDOW
	AX = DE03h
Return: AX = ??? for current window
	BX = ??? for current window
Note:	this call is a NOP in DV 2.x
SeeAlso: AX=DE02h
----------15DE04-----------------------------
INT 15 - DESQview - GET AVAILABLE COMMON MEMORY
	AX = DE04h
Return: BX = bytes of common memory available
	CX = largest block available
	DX = total common memory in bytes
SeeAlso: AX=DE05h,DE06h
----------15DE05-----------------------------
INT 15 - DESQview - GET AVAILABLE CONVENTIONAL MEMORY
	AX = DE05h
Return: BX = K of memory available
	CX = largest block available
	DX = total conventional memory in K
SeeAlso: AX=DE04h,DE06h
----------15DE06-----------------------------
INT 15 - DESQview - GET AVAILABLE EXPANDED MEMORY
	AX = DE06h
Return: BX = K of expanded memory available
	CX = largest block available
	DX = total expanded memory in K
SeeAlso: AX=DE04h,DE05h
----------15DE07-----------------------------
INT 15 - DESQview - "APPNUM" - GET CURRENT PROGRAM'S NUMBER
	AX = DE07h
Return: AX = number of program as it appears on the "Switch Windows" menu
Note:	this API call may be made from a hardware interrupt handler
SeeAlso: AX=DE00h
----------15DE08-----------------------------
INT 15 - DESQview - GET ???
	AX = DE08h
Return: AX = 0000h if ??? is not set to the current task
	     0001h if ??? is set to the current task
----------15DE09-----------------------------
INT 15 - DESQview - UNIMPLEMENTED
	AX = DE09h
Return: nothing (NOP in DV 1.x and 2.x)
----------15DE0A-----------------------------
INT 15 - DESQview 2.x - "DBGPOKE" - DISPLAY CHARACTER ON STATUS LINE
	AX = DE0Ah
	BL = character
Return: character displayed, next call will display in next position (which
	wraps back to the start of the line if off the right edge of screen)
Notes:	displays character on bottom line of *physical* screen, regardless
	  of current size of window (even entirely hidden)
	does not know about graphics display modes, just pokes the characters
	  into display memory
	this API call may be made from a hardware interrupt handler
SeeAlso: AX=1003h
----------15DE0B-----------------------------
INT 15 - DESQview 2.x - "APILEVEL" - DEFINE MINIMUM API LEVEL REQUIRED
	AX = DE0Bh
	BL = API level major version number
	BH = API level minor version number
Return: AX = maximum API level (AL = major, AH = minor)
Notes:	if the requested API level is greater than the version of DESQview, a
	  "You need a newer version" error window is popped up
	the API level defaults to 1.00, and is inherited by child tasks
	some early copies of DV 2.00 return AX=0200h instead of 0002h
----------15DE0C-----------------------------
INT 15 - DESQview 2.x - "GETMEM" - ALLOCATE "SYSTEM" MEMORY
	AX = DE0Ch
	BX = number of bytes
Return: ES:DI -> allocated block or 0000h:0000h (DV 2.26+)
Note:	use SETERROR (AX=DE15h) to avoid a user prompt if there is insufficient
	  system memory
SeeAlso: AX=1001h,AX=DE0Dh,AX=DE15h
----------15DE0D-----------------------------
INT 15 - DESQview 2.x - "PUTMEM" - DEALLOCATE "SYSTEM" MEMORY
	AX = DE0Dh
	ES:DI -> previously allocated block
Return: nothing
SeeAlso: AX=1002h,AX=DE0Ch
----------15DE0E-----------------------------
INT 15 - DESQview 2.x - "FINDMAIL" - FIND MAILBOX BY NAME
	AX = DE0Eh
	ES:DI -> name to find
	CX = length of name
Return: BX = 0000h not found
	     0001h found
		DS:SI = object handle
SeeAlso: AH=12h/BH=11h
----------15DE0F-----------------------------
INT 15 - DESQview 2.x - ENABLE DESQview EXTENSIONS
	AX = DE0Fh
Return: AX and BX destroyed (seems to be bug, weren't saved&restored)
Notes:	sends a manager stream with opcodes AEh, BDh, and BFh to task's window
	enables an additional mouse mode
----------15DE10-----------------------------
INT 15 - DESQview 2.x - "PUSHKEY" - PUT KEY INTO KEYBOARD INPUT STREAM
	AX = DE10h
	BH = scan code
	BL = character
Return: nothing
Notes:	a later read will get the keystroke as if it had been typed by the user
	multiple pushes are read last-in first-out
	if a script exists for the pushed key in the current application, the
	  script will be executed
	early copies of DV 2.00 destroy AX, BX, ES, and DI
SeeAlso: INT 16/AH=05h
----------15DE11-----------------------------
INT 15 - DESQview 2.x - ENABLE/DISABLE AUTOMATIC JUSTIFICATION OF WINDOW
	AX = DE11h
	BL = 00h      viewport will not move automatically
	     nonzero  viewport will move to keep cursor visible (default)
Return: nothing
----------15DE12-----------------------------
INT 15 - DESQview 2.01+ - "CSTYLE" - SET "C"-COMPATIBLE CONTROL CHAR INTERPRET
	AX = DE12h
	BX = 0000h    select normal style (linefeed only moved down)
	     nonzero  select C style (linefeed moves to start of next line)
Return: nothing
Note:	set on a per-task basis, and inherited from the parent task
----------15DE13-----------------------------
INT 15 - DESQview 2.2+ - GET CRITICAL NESTING COUNT
	AX = DE13h
Return: BX = number of calls to BEGINC or ENTERC (see INT 15/AX=101Bh,DE1Ch)
	     without matching ENDC (see INT 15/AX=101Ch)
Note:	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=101Bh,101Ch,DE1Bh,DE1Ch
----------15DE14-----------------------------
INT 15 - DESQview 2.2+ - GET OBJECT TYPE
	AX = DE14h
	ES:DI -> object
Return: BL = 00h not an object
	     08h window or task
	     09h mailbox
	     0Ah keyboard
	     0Bh timer
	     0Ch objectq
	     0Fh pointer
	     10h panel
SeeAlso: AX=1016h
----------15DE15-----------------------------
INT 15 - DESQview 2.2+ - SET ERROR HANDLING
	AX = DE15h
	BL = 00h post system error on all error conditions
	     01h return carry flag set on calls to ADDTO, SUBFROM, and WRITE
		 messages sent to mailboxes which fail due to lack of system
		 or common memory
	     02h (v2.26+) same as 01h, but return null pointer for GETMEM
		 calls which fail due to lack of system memory
Return: nothing
SeeAlso: AX=DE16h
----------15DE16-----------------------------
INT 15 - DESQview 2.2+ - GET ERROR HANDLING
	AX = DE16h
Return: BL = 00h always post system error
	     01h return carry flag set on failed mailbox writes
	     02h return CF set on failed mailbox writes and NULL on failed
		 GETMEM calls
SeeAlso: AX=DE15h
----------15DE17-----------------------------
INT 15 - DESQview 2.20-2.25 - reserved
	AX = DE17h
Return: pops up "Programming error" window
Note:	AX = 1117h is NOT identical to this call under DESQview 2.20 thru 2.25
SeeAlso: AX=1117h
----------15DE17-----------------------------
INT 15 - DESQview 2.26+ - "ASSERTMAP" - GET/SET MAPPING CONTEXT
	AX = DE17h
	BX = 0000h	get current mapping context without setting
	     nonzero	set new mapping context
Return: BX = mapping context in effect before call
Notes:	mapping contexts determine conventional-memory addressability; setting
	  a mapping context ensures that the associated program and data areas
	  are in memory for access.  Usable by drivers, TSRs and shared
	  programs.
	caller need not be running under DESQview
	this API call may be made from a hardware interrupt handler
SeeAlso: AX=1117h,INT 2F/AX=1685h
----------15DE18-----------------------------
INT 15 - DESQview 2.2+ internal -
	AX = DE18h
	BP = function number
	    high byte must be 10h
	    low byte is function
		00h set ???
		    BL = ???  (00h-10h, video mode???)
		    BH = value to store
		03h set ???
		    BL = ??? (stored in driver)
		0Ah get ???
		    ES:DI -> 18-byte buffer to hold ???
Note:	calls video driver (NOP for Hercules driver,probably CGA and MCGA also)
----------15DE19-----------------------------
INT 15 - DESQview 2.23+ - "GETCOMMON" - ALLOCATE "COMMON" MEMORY
	AX = DE19h
	BX = number of bytes to allocate
Return: AX = 0000h successful
		ES:DI -> allocated block
	     nonzero insufficient memory
Note:	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=DE0Ch,AX=DE15h,AX=DE1Ah
----------15DE1A-----------------------------
INT 15 - DESQview 2.23+ - "PUTCOMMON" - DEALLOCATE "COMMON" MEMORY
	AX = DE1Ah
	DS:SI -> previously allocated block
Note:	this function may be called from within a hardware interrupt handler
SeeAlso: AX=DE0Dh,DE19h
----------15DE1B-----------------------------
INT 15 - DESQview 2.23+ internal - DECREMENT CRITICAL NESTING COUNT
	AX = DE1Bh
Return: nothing
SeeAlso: AX=101Ch,AX=DE13h,AX=DE1Ch
----------15DE1C-----------------------------
INT 15 - DESQview 2.23+ - "ENTERC" - INCREMENT CRITICAL NESTING COUNT
	AX = DE1Ch
Return: nothing
Notes:	similar to AX=101Bh, but begins the critical region without ensuring
	  that DOS is free
	the official documentation states that this call should be paired with
	  "ENDC" (AX=101Ch); no mention is made of AX=DE1Bh
	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=101Bh,AX=101Ch,AX=DE13h,AX=DE1Bh
----------15DE1D-----------------------------
INT 15 - DESQview 2.23+ - "PUTKEY" - FAKE USER KEYSTROKES
	AX = DE1Dh
	DX = segment of handle for task to receive keystroke
	BL = character
	BH = scan code
Return: AX = 0000h if successful
	   nonzero if receiver's keyboard buffer was full
Notes:	the key is treated as though the user had pressed it, ignoring any
	  script which may be bound to the key, and using the current field
	  table if the keyboard object is in field processing mode
	multiple PUTKEYs are seen in the order in which they are executed
SeeAlso: AX=DE10h
----------15DE1E-----------------------------
INT 15 - DESQview 2.23+ - "SCRNINFO" - GET TRUE VIDEO PARAMETERS
	AX = DE1Eh
Return:	CL = actual number of rows on screen
	CH = actual number of columns on screen
	BL = actual video mode (may differ from INT 10/AH=0Fh return) (v2.26+)
Note:	this API call may be made from a hardware interrupt handler
SeeAlso: INT 10/AH=0Fh
----------15DE1F-----------------------------
INT 15 - DESQview 2.23+ - "DOSUSER" - GET HANDLE OF TASK CURRENTLY USING DOS
	AX = DE1Fh
Return: BX = segment of task handle or 0000h if no tasks are using DOS
Note:	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=DE13h
----------15DE20-----------------------------
INT 15 - DESQview 2.26+ - "DISPATCHINT" - INTERRUPT ANOTHER TASK
	AX = DE20h
	BX = segment of handle of task to interupt
	DX:CX -> FAR interrupt routine
Return: nothing
Notes:	unlike "PGMINT" (AX=1021h), DISPATCHINT may be applied to the task
	  making the DISPATCHINT call
	multiple "DISPATCHINT" calls are processed in the order in which they
	  were executed
	the FAR routine is entered with the current ES, DS, SI, DI, and BP
	  values, using the task's internal stack (see AX=101Ah); only SS:SP
	  needs to be preserved
	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=1021h
----------15DE21-----------------------------
INT 15 - DESQview 2.26+ - "ASSERTVIR" - CONTROL 386 SCREEN VIRTUALIZATION
	AX = DE21h
	BX = 0000h turn off
	     nonzero turn on
Return: BX = old state of virtualization
Note:	this API call may be made from within a hardware interrupt handler
----------15DE22-----------------------------
INT 15 - DESQview 2.26+ - "PROCESSMEM" - GET TASK MEMORY STATUS
	AX = DE22h
	DX = segment of task handle
Return: DX = total amount of memory in paragraphs
	BX = amount of system memory in paragraphs
	CX = largest block of system memory available in paragraphs
	AX = flags
	    bit 0: system memory resides in shared memory
		1: process's memory is swapped out
		2: process's system memory is swapped out
Notes:	if the task handle is a child task, the returned values will be for the
	  process containing the task, rather than the task itself
	if the process's system memory is swapped out, BX,CX,DX remain
	  unchanged, because the memory usage cannot be determined
SeeAlso: AX=DE04h,AX=DE05h,AX=DE06h
----------15DE23-----------------------------
INT 15 - DESQview 2.31+ - ???
	AX = DE23h
	BX = ???
	CX = ???
Return: ???
----------15E00F-----------------------------
INT 15 - Compaq Systempro - MULTIPROCESSOR DISPATCH
	AX = E00Fh
	ES:BX -> start of 2nd processor's execution
Return: AL = 0Fh successful
	   = 00h failure	
----------15E10E-----------------------------
INT 15 - Compaq Systempro - MULTIPROCESSOR END-OF-DISPATCH
	AX = E10Eh
	ES:BX -> start of 2nd processor's execution
Return: AL = 0Fh successful (halted)
	   = 00h failure (not halted)
----------15E200-----------------------------
INT 15 - Compaq Systempro - MULTIPROCESSOR AVAILABLE
	AX = E200h
Return: AX = 8000h if 2nd processor available
----------1600-------------------------------
INT 16 - KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
	AH = 00h
Return: AH = scan code
	AL = character
Note:	on extended keyboards, this function discards any extended keystrokes,
	  returning only when a non-extended keystroke is available
SeeAlso: AH=01h,10h
----------1601-------------------------------
INT 16 - KEYBOARD - CHECK BUFFER, DO NOT CLEAR
	AH = 01h
Return: ZF clear if character in buffer
	    AH = scan code
	    AL = character
	ZF set if no character in buffer
SeeAlso: AH=00h,11h
----------1602-------------------------------
INT 16 - KEYBOARD - GET SHIFT STATUS
	AH = 02h
	AL = shift status bits
	    0 = right shift key depressed
	    1 = left shift key depressed
	    2 = CTRL depressed
	    3 = ALT depressed
	    4 = SCROLL LOCK active
	    5 = NUM LOCK active
	    6 = CAPS LOCK active
	    7 = INSERT state active
SeeAlso: AH=12h
----------1603-------------------------------
INT 16 - KEYBOARD - SET DELAYS (Jr,AT model 339,XT286,PS)
	AH = 03h
	AL = subfunction
	    00h reset typematic (PCjr)
	    01h increase initial delay (PCjr)
	    02h increase continuing delay (PCjr)
	    03h increase both delays (PCjr)
	    04h turn off typematic (PCjr)
	    05h Set typematic rate (AT or PS/2)
	BH = 00h - 03h for delays of 250ms, 500ms, 750ms, or 1s
	BL = 00h - 1Fh for typematic rates of 30cps down to 2cps
----------1604-------------------------------
INT 16 - KEYBOARD - KEYCLICK (Jr,CONV)
	AH = 04h
	AL = 00h click off
	     01h click on
----------1605-------------------------------
INT 16 - KEYBOARD - WRITE TO KEYBOARD BUFFER (AT model 339,XT2,XT286,PS)
	AH = 05h
	CH = scan code
	CL = character
Return: AL = 01h if buffer full
SeeAlso: AH=71h, INT 15/AX=DE10h
----------1610-------------------------------
INT 16 - KEYBOARD - GET ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS)
	AH = 10h
Return: AH = scan code
	AL = character
Note:	unlike AH=00h, this function does not discard extended keystrokes
SeeAlso: AH=00h,11h
----------1611-------------------------------
INT 16 - KEYBOARD - CHECK ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS)
	AH = 11h
Return: ZF clear if keystroke available
	    AH = scan code \ meaningless if ZF = 1
	    AL = character /
	ZF set if kbd buffer empty
SeeAlso: AH=01h,10h
----------1612-------------------------------
INT 16 - KEYBOARD - GET ENHANCED SHIFT FLAGS (AT model 339,XT2,XT286,PS)
	AH = 12h
Return: AL = shift flags (same as for AH=02h)
	   bit 7: Ins ON
	   bit 6: CapsLock ON
	   bit 5: NumLock ON
	   bit 4: ScrollLock ON
	   bit 3: Either ALT key down
	   bit 2: Either CTRL key down
	   bit 1: Left shift key down
	   bit 0: Right shift key down
	AH
	   bit 7: SysReq key down
	   bit 6: CapsLock key down
	   bit 5: NumLock key down
	   bit 4: ScrollLock key down
	   bit 3: Right Alt key down
	   bit 2: Right Ctrl key down
	   bit 1: Left Alt key down
	   bit 0: Left Ctrl key down
Notes:	AL bit 3 set only for left Alt key on many machines
	AH bits 7 through 4 always clear on a Compaq SLT/286
SeeAlso: AH=02h
----------165500-----------------------------
INT 16 - Microsoft Word internal - MICROSOFT WORD COOPERATION WITH TSR
	AX = 5500h
Return: AX = 4D53h if keyboard TSR present
Notes:	during startup, Microsoft Word tries to communicate with any TSRs
	  that are present through this call.
	If the return is not 4D53h, Word installs its own INT 9h and INT 16h
	  handlers, otherwise it assumes that the TSR will handle the keyboard.
----------166969BX6968-----------------------
INT 16 - PC Tools v5.1+ BACKTALK - UNHOOK
	AX = 6969h
	BX = 6968h
Return: resident code unhooked, but not removed from memory
----------166969BX6969-----------------------
INT 16 - PC Tools v5.1+ BACKTALK - INSTALLATION CHECK
	AX = 6969h
	BX = 6969h
	DX = 0000h
Return: DX nonzero if installed
	    BX = CS of resident code
	    DX = PSP segment of resident code
	    DS:SI -> ASCIZ identification string "CPoint Talk"
----------166F-------------------------------
INT 16 - MS Windows - ???
	AH = 6Fh
	???
Return: ???
----------1670-------------------------------
INT 16 - FAKEY.COM - INSTALLATION CHECK
	AH = 70h
Return: AX = 1954h if installed
Note:	FAKEY is a keystroke faking utility by System Enhancement Associates
----------1671-------------------------------
INT 16 - FAKEY.COM - PUSH KEYSTROKES
	AH = 71h
	CX = number of keystrokes
	DS:SI -> array of words containing keystrokes to be returned by AH=00h
Note:	FAKEY is a keystroke faking utility by System Enhancement Associates
SeeAlso: AH=05h,72h
----------1672-------------------------------
INT 16 - FAKEY.COM - CLEAR FAKED KEYSTROKES
	AH = 72h
Note:	FAKEY is a keystroke faking utility by System Enhancement Associates
SeeAlso: AH=71h
----------1673-------------------------------
INT 16 - FAKEY.COM - PLAY TONES
	AH = 73h
	CX = number of tones to play
	DS:SI -> array of tones (see below)
Note:	FAKEY is a keystroke faking utility by System Enhancement Associates

Format of tone array entries:
Offset	Size	Description
 00h	WORD	divisor for timer channel 2
 02h	WORD	duration in clock ticks
----------1675-------------------------------
INT 16 - pcANYWHERE - SET TICK COUNT FOR SCANNING
	AH = 75h
	AL = number of ticks between checks for new screen changes
----------1676-------------------------------
INT 16 - pcANYWHERE - SET ERROR CHECKING TYPE
	AH = 76h
	AL = error checking type
	    00h none
	    01h fast
	    02h slow
----------1677-------------------------------
INT 16 - pcANYWHERE - LOG OFF
	AH = 77h
	AL = mode
	    00h wait for another call
	    01h leave in Memory Resident Mode
	    02h leave in Automatic Mode
	    FFh leave in current operating mode
----------167761-----------------------------
INT 16 - WATCH.COM - INSTALLATION CHECK
	AX = 7761h ('wa')
Return: AX = 5741h ('WA') if installed
Note:	WATCH.COM is part of the "TSR" package by Kim Kokkonen
----------167788BX7789-----------------------
INT 16 - PC Magazine PUSHDIR.COM - INSTALLATION CHECK
	AX = 7788h
	BX = 7789h
Return: AX = 7789h
	BX = 7788h
	DS:SI -> signature string
----------1679-------------------------------
INT 16 - pcANYWHERE - CHECK STATUS
	AH = 79h
Return: AX = status
	    FFFFh if resident and active
	    FFFEh if resident but not active
	    FFFDh if in Memory Resident mode
	    FFFCh if in Automatic mode
	    other value if not resident
----------167A-------------------------------
INT 16 - pcANYWHERE - CANCEL SESSION
	AH = 7Ah
----------167B00-----------------------------
INT 16 - pcANYWHERE - SUSPEND
	AX = 7B00h
SeeAlso: AX=7B01h
----------167B01-----------------------------
INT 16 - pcANYWHERE - RESUME
	AX = 7B01h
SeeAlso: AX=7B00h
----------167C-------------------------------
INT 16 - pcANYWHERE - GET PORT CONFIGURATION
	AH = 7Ch
Return: AH = port number
	AL = baud rate
	    00h = 50 baud
	    01h = 75 baud
	    02h = 110 baud
	    03h = 134.5 baud
	    04h = 150 baud
	    05h = 300 baud
	    06h = 600 baud
	    07h = 1200 baud
	    08h = 1800 baud
	    09h = 2000 baud
	    0Ah = 2400 baud
	    0Bh = 4800 baud
	    0Ch = 7200 baud
	    0Dh = 9600 baud
	    0Eh = 19200 baud
----------167D-------------------------------
INT 16 - pcANYWHERE - GET/SET TERMINAL PARAMETERS
	AH = 7Dh
	AL = subfunction
	    00h set terminal parameters
	    01h get terminal parameters
	    02h get configuration header and terminal parameters
	DS:CX -> terminal parameter block
----------167E-------------------------------
INT 16 - pcANYWHERE - COMMUNICATIONS I/O THROUGH PORT
	AH = 7Eh
	AL = subfunction
	    01h port input status
		Return AX = 0 if no characer ready,
		       AX = 1 if character ready
	    02h port input character
		Return AL = received character
	    03h port output character in CX
	    11h hang up phone
----------167F-------------------------------
INT 16 - pcANYWHERE - SET KEYBOARD/SCREEN MODE
	AH = 7Fh
	AL = subfunction
	    00h enable remote keyboard only
	    01h enable host keyboard only
	    02h enable both keyboards
	    08h display top 24 lines
	    09h display bottom 24 lines
	    10h Hayes modem
	    11h other modem
	    12h direct connect
----------1680-------------------------------
INT 16 - MAKEY.COM - INSTALLATION CHECK
	AH = 80h
Return: AX = 1954h if installed
Note:	MAKEY is a utility by System Enhancement Associates
----------16AA-------------------------------
INT 16 - PTxxx.COM - (xxx=CGA,EGA,VGA,HER...) CALL GATE FOR GRAPHICS
	AH = AAh
	Various registers set up by high level language.
Return: Graphics performed
Note:	PT stands for Paint Tools which is a graphics library for Turbo Pascal,
	  Modula 2 and others from DataBiten in Sweden. The library is
	  installed as a memory resident driver.
----------16F0-------------------------------
INT 16 - Compaq 386 - SET CPU SPEED
	AH = F0h
	AL = speed
	    00h equivalent to 6 MHz 80286 (COMMON)
	    01h equivalent to 8 MHz 80286 (FAST)
	    02h full 16 MHz (HIGH)
	    03h toggles between 8 MHz-equivalent and speed set by system board
		switch (AUTO or HIGH)
	    08h full 16 MHz except 8 MHz-equivalent during floppy disk access
	    09h specify speed directly
		CX = speed value, 1 (slowest) to 50 (full), 3 ~= 8088
SeeAlso: AH=F1h,AH=F3h
----------16F0F0-----------------------------
INT 16 - PE.EXE - INSTALLATION CHECK
	AX = F0F0h
Return: AX = 0F0Fh if installed
	    ES:DI -> data block
Note:	PE is a TSR screen grabber included with ASMED, an integrated
	  environment for TASM and MASM

Format of data block:
Offset	Size	Description
 00h	DWORD	pointer to program tag (counted ASCII string)
 04h	WORD	???
 06h	DWORD	pointer to ???
 0Ah  4 BYTEs	???
 0Eh	DWORD	???
	more???
----------16F1-------------------------------
INT 16 - Compaq 386 - READ CURRENT CPU SPEED
	AH = F1h
Return:	AL = speed code (see AH=F0h)
	     if AL = 09h, CX = speed code
SeeAlso: AH=F0h,AH=F3h
----------16F2-------------------------------
INT 16 - Compaq 386 - DETERMINE ATTACHED KEYBOARD TYPE
	AH = F2h
Return: AL = type
	    00h if 11-bit AT keyboard is in use
	    01h if 9-bit PC keyboard is in use 
----------16F3-------------------------------
INT 16 - Compaq 80286s - SET CPU SPEED LIMIT (OVERRIDE JUMPER)
	AH = F3h
	AL = 00h limit is 6 Mhz
	   = 01h limit is 8 Mhz/6 Mhz
SeeAlso: AH=F0h,AH=F1h
----------16F400-----------------------------
INT 16 - Compaq Systempro - CACHE CONTROLLER STATUS
	AX = F400h
Return: AH = E2h
	AL = status
	    00h not present
	    01h enabled
	    02h disabled
SeeAlso: AX=F401h,AX=F402h
----------16F401-----------------------------
INT 16 - Compaq Systempro - ENABLE CACHE CONTROLLER
	AX = F401h
Return: AX = E201h
SeeAlso: AX=F400h,AX=F402h
----------16F402-----------------------------
INT 16 - Compaq Systempro - DISABLE CACHE CONTROLLER
	AX = F402h
Return: AX = E202h
SeeAlso: AX=F400h,AX=F401h
----------16FFAD-----------------------------
INT 16 - PC Tools v6.0 DESKTOP API - ???
	AX = FFADh
	???
Return: ???
----------16FFAE-----------------------------
INT 16 - PC Tools v6.0 DESKTOP API - ???
	AX = FFAEh
	???
Return: ???
----------16FFAF-----------------------------
INT 16 - PC Tools v6.0 DESKTOP API - ???
	AX = FFAFh
	???
Return: ???
----------16FFB0-----------------------------
INT 16 - PC Tools v6.0 DESKTOP API - ???
	AX = FFB0h
	???
Return: ???
----------16FFB1-----------------------------
INT 16 - PC Tools v6.0 DESKTOP API - ???
	AX = FFB1h
	???
Return: ???
----------16FFB2-----------------------------
INT 16 - PC Tools v5.5+ DESKTOP API - ???
	AX = FFB2h
Return: DS:SI -> ???
----------16FFB3-----------------------------
INT 16 - PC Tools v5.5+ DESKTOP API - ???
	AX = FFB3h
	???
Return: ???
Note:	available only when popped up
----------16FFB4-----------------------------
INT 16 - PC Tools v5.5+ DESKTOP API - ???
	AX = FFB4h
	???
Return: ???
Note:	available only when popped up
----------16FFB5-----------------------------
INT 16 - PC Tools v5.5+ DESKTOP API - GET/SET ???
	AX = FFB5h
	BX = ??? (000Fh to 0019h)
	DX = 0000h get, nonzero = set
	ES:DI -> 16-byte buffer with new values or to receive old values
----------16FFB6-----------------------------
INT 16 - PC Tools v5.5+ DESKTOP API - ???
	AX = FFB6h
	???
Return: AH = ???
	AL = ???
----------16FFB7-----------------------------
INT 16 - PC Tools v5.5+ DESKTOP API - SET ???
	AX = FFB7h
	DS:SI -> 10-byte buffer with ???
	???
Return: ???
----------16FFB8-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFB8h
	BH = subfunction
	    00h get
		Return: BL = old value of ???
	    nonzero set
		BL = new value for ???
----------16FFB9-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFB9h
	???
Return: AX = ???
	CX = ???
	DS:SI -> ???
	ES:DI -> ???
----------16FFBA-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFBAh
	???
Return: ???
Note:	available only when popped up
----------16FFBB-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFBBh
	???
Return: ???
Note:	available only when popped up
----------16FFBC-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - RESTORE ORIGINAL SCREEN???
	AX = FFBCh
----------16FFBD-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - POP DOWN???
	AX = FFBDh
	???
Return: ???
----------16FFBE-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFBEh
	???
Return: ???
Note:	available only when popped up
----------16FFBF-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFBFh
	???
Return: ???
Note:	available only when popped up
----------16FFC0-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFC0h
	???
Return: ???
Note:	available only when popped up
----------16FFC1-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFC1h
	???
Return: ???
Note:	available only when popped up
----------16FFC2-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFC2h
	???
Return: ???
Note:	available only when popped up
----------16FFC3-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFC3h
	???
Return: ???
Note:	available only when popped up
----------16FFC4-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFC4h
	???
Return: ???
Note:	available only when popped up
----------16FFC5-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - CHECK WHETHER DESKTOP LOADED RESIDENT
	AX = FFC5h
Return: BL = nonzero if loaded resident
	   = 00h if nonresident
Note:	available only when popped up
----------16FFC6-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - SET ???
	AX = FFC6h
	BL = new value for ???
----------16FFC7-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFC7h
	???
Return: ???
Note:	screen swapping???
----------16FFC8-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - GET ???
	AX = FFC8h
Return: DS:SI -> ???
----------16FFC9-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFC9h
	SI = ???
	CX = ???
Return: ???
Note:	available only when popped up
----------16FFCA-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFCAh
	DX = ???
Return: ???
Note:	available only when popped up
----------16FFCB-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFCBh
	DX = ???
Return: ???
Note:	available only when popped up
----------16FFCC-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - DISPLAY ASCIZ STRING
	AX = FFCCh
	DS:SI -> ASCIZ string
Return: AX = ???
	CX = ???
	ES:DI -> address past last character displayed
----------16FFCD-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFCDh
	DS:DX -> ???
Return: ???
Note:	available only when popped up
----------16FFCE-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - SET ??? DELAYS
	AX = FFCEh
	CX = ???
Return: nothing???
----------16FFCF-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFCFh
	???
Return: ???
Note:	available only when popped up
----------16FFD0-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFD0h
	???
Return: ???
Note:	available only when popped up
----------16FFD1-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFD1h
	???
Return: ???
Note:	available only when popped up
----------16FFD2-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFD2h
	BX = ???
Return: ???
Note:	available only when popped up
----------16FFD3-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFD3h
	???
Return: ???
----------16FFD4-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - CREATE/OPEN/DELETE FILE
	AX = FFD4h
	BH = 3Ch create file
		CX = file attributes
	     3Dh open file
	     41h delete file
	BL = access mode
	     00h read only
	     01h write only
	     02h read/write
	DS:SI -> ASCIZ filename
Return: BX = file handle
	    0000h on error
----------16FFD5-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFD5h
	???
Return: ???
Note:	available only when popped up
----------16FFD6-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFD6h
	???
Return: ???
Note:	available only when popped up
----------16FFD7-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFD7h
	???
Return: ???
Note:	available only when popped up
----------16FFD8-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - SAFE CREATE FILE
	AX = FFD8h
	DS:BX -> ASCIZ filename
Return: BX = file handle
	    0000h on error
Note:	pops up confirmation menu if file already exists
	only available when popped up???
----------16FFD9-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFD9h
	???
Return: ???
Note:	available only when popped up
----------16FFDA-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFDAh
	DS:SI -> ???
Return: DS:SI -> ???
----------16FFDB-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFDBh
	???
Return: ???
Note:	available only when popped up
----------16FFDC-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - UNHOOK
	AX = FFDCh
Return: interrupt vectors 09h, 16h, 1Ch, and 21h restored to original values
----------16FFDDBX0000-----------------------
INT 16 - PC Tools v5.1+ PCShell API - INSTALLATION CHECK
	AX = FFDDh
	BX = 0000h
Return: CX = 5555h 
	DX = 5555h if PCShell installed in resident mode
----------16FFDDBX0001-----------------------
INT 16 - PC Tools v5.1+ PCShell API - REQUEST POP-UP
	AX = FFDDh
	BX = 0001h
SeeAlso: AX=FFDDh/BX=0003h
----------16FFDDBX0002-----------------------
INT 16 - PC Tools v5.1+ PCShell API - GET ???
	AX = FFDDh
	BX = 0002h
Return: AL = 
	    00h ???
	    01h ???
----------16FFDDBX0003-----------------------
INT 16 - PC Tools v5.1+ PCShell API - REQUEST POP-UP
	AX = FFDDh
	BX = 0003h
SeeAlso: AX=FFDDh/BX=0001h
----------16FFDDBX0004-----------------------
INT 16 - PC Tools v5.1+ PCShell API - ???
	AX = FFDDh
	BX = 0004h
	???
Return: DS:SI -> ???
----------16FFDDBX0005-----------------------
INT 16 - PC Tools v5.1+ PCShell API - ???
	AX = FFDDh
	BX = 0005h
	???
Return: ???
----------16FFDDBX0006-----------------------
INT 16 - PC Tools v5.1+ PCShell API - ???
	AX = FFDDh
	BX = 0006h
	???
Return: ???
----------16FFDDBX0007-----------------------
INT 16 - PC Tools v5.1+ PCShell API - ???
	AX = FFDDh
	BX = 0007h
	???
Return: ???
----------16FFDDBX0008-----------------------
INT 16 - PC Tools v5.1+ PCShell API - ???
	AX = FFDDh
	BX = 0008h
	???
Return: ???
----------16FFDDBX0009-----------------------
INT 16 - PC Tools v6.0 PCShell API - GET ???
	AX = FFDDh
	BX = 0009h
Return: DS:SI -> ???
----------16FFDE-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFDEh
	DS:DX -> ???
Return: ???
Note:	available only when popped up
----------16FFDF-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFDFh
	???
Return: ???
----------16FFE0-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFE0h
	CX = ???
	DX = ???
Return: ???
----------16FFE1-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - BEEP
	AX = FFE1h
----------16FFE2-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFE2h
	DX = ???
Return: ???
Note:	available only when popped up
----------16FFE3-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFE3h
	BL = ???
Return: ???
----------16FFE4-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFE4h
	DX = segment of ???
Return: ???
Note:	available only when popped up
----------16FFE5-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFE5h
	DS:SI -> wildcard filename???
	DX = ???
Return: AX = ???
Note:	available only when popped up
----------16FFE6-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFE6h
	DS:SI -> ???
Return: AX = ???
----------16FFE7-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFE7h
	BX = segment of ???
Return: ???
Note:	available only when popped up
----------16FFE8-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - DISPLAY NUMBER
	AX = FFE8h
	CX = number
	DH = attribute
	DS:SI -> destination for ASCII number
Return: DS:SI buffer filled in with alternating characters and attributes
----------16FFE9-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFE9h
	???
Return: ???
Note:	available only when popped up
----------16FFEA-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - DISPLAY COUNTED STRING
	AX = FFEAh
	DS:SI -> counted string (count byte followed by string)
Return: ???
Note:	available only when popped up
----------16FFEB-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFEBh
	???
Return: ???
----------16FFEC-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFECh
	DS:SI -> FAR routine to ???
	BX = ???
Return: AX = ???
----------16FFED-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFEDh
Return: AX = ???
----------16FFEE-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFEEh
	SI = ???
Return: ???
Note:	available only when popped up
----------16FFEFCX0000-----------------------
INT 16 - PC Tools v5.1+ DESKTOP API - INSTALLATION CHECK
	AX = FFEFh
	CX = 0000h
Return: CX = ABCDh if PC Tools DESKTOP.EXE installed
	    BX = segment of resident portion
	    AX = ???
----------16FFF0-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFF0h
	DX = ???
Return: ???
Note:	available only when popped up
----------16FFF1-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ALTERNATE INSTALLATION CHECK
	AX = FFF1h
	BX = 0000h  leave ??? flag as is
	    nonzero set ??? flag
Return: CX = 5555h if installed
	DX = 5555h
----------16FFF2-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFF2h
	???
Return: ???
Note:	available only when popped up
----------16FFF3-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFF3h
	???
Return: ???
----------16FFF4-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFF4h
	???
Return: ???
Note:	available only when popped up
----------16FFF5-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - GET SCREEN ATTRIBUTE ARRAY
	AX = FFF5h
Return: ES:BX -> array of screen attributes 
		00h	BYTE  normal characters on desktop menu
		01h	BYTE  highlighted characters on desktop menu
		02h	BYTE 
		03h	BYTE
		etc.
----------16FFF6-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFF6h
	DS = ???
	BX = ???
	DX = ???
Return: ???
Note:	available only when popped up
----------16FFF7-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFF7h
	SI = ???
Return: ???
----------16FFF8-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFF8h
	DS:SI -> ???
	BX = ???
Return: ???
----------16FFF9-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFF9h
	ES:BX -> FAR routine to ???
Return: ???
Note:	available only when popped up
----------16FFFA-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFFAh
Return: ???
----------16FFFB-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFFBh
Return: ???
----------16FFFC-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - GET ???
	AX = FFFCh
Return: ES:BX = ???
	DS:DX = original INT 9 vector
----------16FFFD-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - ???
	AX = FFFDh
	???
Return: ???
----------16FFFE-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - SHOW MOUSE CURSOR
	AX = FFFEh
SeeAlso: AX=FFFFh, INT 33/AX=0001h
----------16FFFF-----------------------------
INT 16 - PC Tools v5.1+ DESKTOP API - HIDE MOUSE CURSOR
	AX = FFFFh
SeeAlso: AX=FFFEh, INT 33/AX=0002h
----------17----DX0ABC-----------------------
INT 17 - PRINTER - LPTx v5.x INSTALLATION CHECK
	DX = 0ABCh
Return: AX = AAAAh
	DX = BAAAh
	ES = code segment of resident portion
----------17----DX0B90-----------------------
INT 17 - PRINTER - LPTx v6.x INSTALLATION CHECK
	DX = 0B90h
Return: DX = ABBBh
	ES = code segment of resident portion
----------17----DX0B91-----------------------
INT 17 - PRINTER - LPTx v7.x INSTALLATION CHECK
	DX = 0B91h
Return: DX = ABCBh
	ES = code segment of resident portion
----------17----DX0F5F-----------------------
INT 17 - PRINTER - LPTx v4.x INSTALLATION CHECK
	DX = 0F5Fh
Return: AX = AAAAh
	DX = F555h
	ES = code segment of resident portion
----------1700-------------------------------
INT 17 - PRINTER - OUTPUT CHARACTER
	AH = 00h
	AL = character
	DX = printer port (0-3)
Return: AH = status bits
	    bit 0 time out
		1 unused
		2 unused
		3 I/O error
		4 selected
		5 out of paper
		6 acknowledge
		7 not busy
----------1701-------------------------------
INT 17 - PRINTER - INITIALIZE
	AH = 01h
	DX = printer port (0-3)
Return: AH = status (see AH=00h)
----------1702-------------------------------
INT 17 - PRINTER - GET STATUS
	AH = 02h
	DX = printer port (0-3)
Return: AH = status (see AH=00h)
----------1702--CX07C3-----------------------
INT 17 - INSET - INSTALLATION CHECK
	AH = 02h
	DX = 0000h
	CX = 07C3h (1987d)
Return: CX = 07C2h (1986d) if installed
Note:	INSET is a text/graphics integration program
----------1760-------------------------------
INT 17 - FLASHUP.COM - INSTALLATION CHECK
	AH = 60h
Return: AL = 60h
	DX = CS of resident code
Note:	FLASHUP.COM is part of Flash-Up Windows by The Software Bottling Co.
	FLASHUP also hooks INT 10 and received commands via INT 10/AH=09h,0Ah
	  consisting of an 80h followed by the actual command
----------1761-------------------------------
INT 17 - SPEEDSCR.COM - INSTALLATION CHECK
	AH = 61h
Return: AL = 61h
	DX = CS of resident code
Note:	SPEEDSCR.COM is by The Software Bottling Co.
----------17C0-------------------------------
INT 17 - PC Magazine PCSpool - GET CONTROL BLOCK ADDRESS
	AH = C0h
	DX = printer port (0-3)
Return: ES:BX -> control block
SeeAlso: AH=C1h
----------17C1--------------------------------
INT 17 - PC Magazine PCSpool - BUILD CONTROL RECORD
	AH = C1h
	DX = printer port (0-3)
	DS:SI -> ASCIIZ string to save for display
Note:	flushes pending writes
SeeAlso: AH=C0h,AH=C2h
----------17C2-------------------------------
INT 17 - PC Magazine PCSpool - FLUSH PENDING WRITES
	AH = C2h
	DX = printer port (0-3)
SeeAlso: AH=C3h
----------17C3-------------------------------
INT 17 - PC Magazine PCSpool - CANCEL PRINTER QUEUE (FLUSH ALL QUEUED OUTPUT)
	AH = C3h
	DX = printer port (0-3)
SeeAlso: AH=C2h,AH=C7h
----------17C4-------------------------------
INT 17 - PC Magazine PCSpool - QUERY SPOOLER ACTIVE
	AH = C4h
Return: DI = B0BFh
	SI = segment
----------17C5-------------------------------
INT 17 - PC Magazine PCSpool - JOB SKIP PRINTER QUEUE
	AH = C5h
	DX = printer port (0-3)
Note: 	cancels up to the pause record 
----------17C6-------------------------------
INT 17 - PC Magazine PCSpool - CHECK PRINTER QUEUE STATUS
	AH = C6h
	DX = printer port (0-3)
Return: AX = 0 printer not active or at pause
	   = 1 printer busy
----------17C7-------------------------------
INT 17 - PC Magazine PCSpool - CLOSE QUEUE
	AH = C7h
	DX = printer port (0-3)
SeeAlso: AH=C3h
----------17CD00-----------------------------
INT 17 - INSET - EXECUTE COMMAND STRING
	AX = CD00h
	DS:DX -> ASCIZ command string (max 80 bytes)
Return: CX = 07C2h (1986d)
Note:	user interface menus pop up after last command, unless that command
	exits INSET
----------17CD01-----------------------------
INT 17 - INSET - GET IMAGE SIZE
	AX = CD01h
	DS:DX -> ASCIZ name of image file
Return: AX = height in 1/720th inch
	BX = width in 1/720th inch
	CX = 07C2h (1986d)
----------17CD02-----------------------------
INT 17 - INSET - INITIALIZE
	AX = CD02h
Return: CX = 07C2h (1986d)
Note:	all open files are closed and the printer is reset
SeeAlso: AX=CD04h
----------17CD03-----------------------------
INT 17 - INSET - EXECUTE INSET MENU WITHIN OVERRIDE MODE
	AX = CD03h
Return: CX = 07C2h (1986d)
----------17CD04-----------------------------
INT 17 - INSET - INITIALIZE LINKED MODE
	AX = CD04h
	ES:DI -> FAR routine for linked mode
Return: CX = 07C2h
Note:	calling sequence for linked-mode routine
	AL = 00h send character in BL to printer
	   = 01h send CX bytes from DS:DX to printer
	   = 02h move print head to horizontal starting position of image
	return code for linked-mode routine:
	AX = 0000h success
	   = 0001h failure
SeeAlso: AX=CD02h,AX=CD08h
----------17CD05-----------------------------
INT 17 - INSET - START MERGING IMAGE INTO TEXT
	AX = CD05h
	DS:DX -> ASCIZ name of PIX file
	CX = left margin of text in 1/720th inch
Return: AH = printer type
	    00h page-oriented (multiple images may be placed side-by-side)
	    01h line-oriented (use AX=CD06h for vertical paper movement)
	CX = 07C2h (1986d)
SeeAlso: AX=CD07h
----------17CD06-----------------------------
INT 17 - INSET - GRAPHICS LINE FEED
	AX = CD06h
Return: AH = completion status
	    00h image complete
	    01h image incomplete
	CX = 07C2h (1986d)
SeeAlso: AX=CD09h
----------17CD07-----------------------------
INT 17 - INSET - FLUSH GRAPHICS FROM MERGE BUFFER
	AX = CD07h
Return: CX = 07C2h
SeeAlso: AX=CD05h
----------17CD08-----------------------------
INT 17 - INSET - CANCEL LINK MODE
	AX = CD08h
Return: CX = 07C2h
SeeAlso: AX=CD04h
----------17CD09-----------------------------
INT 17 - INSET - ALTER GRAPHICS LINE SPACING
	AX = CD09h
	CX = line spacing in 1/720th inch
Return: CX = 07C2h
Note:	not yet implemented, line spacing is currently fixed at 1/6 inch
SeeAlso: AX=CD06h
----------17CD0A-----------------------------
INT 17 - INSET - GET SETUP
	AX = CD0Ah
	DS:DX -> buffer for IN.SET data
Return: CX = 07C2h
----------17CD0B-----------------------------
INT 17 - INSET - START GETTING SCALED IMAGE
	AX = CD0Bh
	DS:SI -> ASCIZ pathname of .PIX file
	BX = number of bitplanes
	CX = number of rows in output bitmap
	DX = number of columns in output bitmap
Return: AX = status
	    0000h OK
	    FFFFh error	
Note:	image is returned in strips by repeated calls to AX=CD0Ch
----------17CD0C-----------------------------
INT 17 - INSET - GET NEXT IMAGE STRIP
	AX = CD0Ch
Return:	AX = status
	    0000h OK but not complete
	    0001h OK and image complete
	    FFFFh error
	DS:SI -> buffer (max 4K) for bit map strip 
	CX = start row
	DX = number of rows
	BX = offset in bytes between bit planes
Note:	buffer may be overwritten by subsequent calls
SeeAlso: AX=CD0Bh
----------18---------------------------------
INT 18 - TRANSFER TO ROM BASIC
   causes transfer to ROM-based BASIC (IBM-PC)
   often reboots a compatible; often has no effect at all
----------19---------------------------------
INT 19 - DISK BOOT
   causes reboot of disk system (no memory test performed, interrupt vectors
   preserved).	Because interrupt vectors are preserved, this interrupt usually
   causes a system hang if any TSRs have hooked vectors from 00h through 1Ch,
   particularly INT 08.

   Usually, the BIOS will try to read sector 1, head 0, track 0 from drive A:
   to 0000h:7C00h.  If this fails, and a hard disk is installed, the BIOS will
   read sector 1, head 0, track 0 of the first hard disk.  This sector should
   contain a master bootstrap loader and a partition table.  After loading the
   master boot sector at 0000h:7C00h, the master bootstrap loader is given
   control.  It will scan the partition table for an active partition, and will
   then load the operating system's bootstrap loader (contained in the first
   sector of the active partition) and give it control.

Notes:	to accomplish a warm boot equivalent to Ctrl-Alt-Del, store 1234h in
	  0040h:0072h and jump to FFFFh:0000h.	For a cold boot equivalent to
	  a reset, store 0000h at 0040h:0072h before jumping.
	VDISK.SYS hooks this interrupt to allow applications to find out how
	  much extended memory has been used by VDISKs (the three bytes at
	  offset 2Ch in the INT 19 handler's segment contain the linear address
	  of the first free extended memory).

Format of hard disk master boot sector:
Offset	Size	Description
 00h 446 BYTEs	Master bootstrap loader code
1BEh 16 BYTEs	partition record for partition 1 (see below)
1CEh 16 BYTEs	partition record for partition 2
1DEh 16 BYTEs	partition record for partition 3
1EEh 16 BYTEs	partition record for partition 4
1FEh	WORD	signature, AA55h indicates valid boot block

Format of partition record:
Offset	Size	Description
 00h	BYTE	boot indicator (80h = active partition)
 01h	BYTE	partition start head
 02h	BYTE	partition start sector (bits 0-5)
 03h	BYTE	partition start track (bits 8,9 in bits 6,7 of sector)
 04h	BYTE	operating system indicator (see below)
 05h	BYTE	partition end head
 06h	BYTE	partition end sector (bits 0-5)
 07h	BYTE	partition end track (bits 8,9 in bits 6,7 of sector)
 08h	DWORD	sectors preceding partition
 0Ch	DWORD	length of partition in sectors

Values for operating system indicator:
 00h empty
 01h DOS 12-bit FAT
 02h XENIX file system
 03h XENIX /usr file system (obsolete???)
 04h DOS 16-bit FAT
 05h DOS 3.3+ extended partition
 06h DOS Large File System
 07h QNX
 08h AIX bootable partition
 09h AIX data partition
 51h Disk Manager
 52h CP/M ???
 56h GB ???
 61h SpeedStor
 63h SysV/386
 64h Novell NetWare
 75h PC/IX
 80h Minix v1.3 and below
 81h Minix v1.5+
 DBh CP/M
 E1h SpeedStor 12-bit FAT extended partition
 E4h SpeedStor 16-bit FAT extended partition
 FFh BBT ???
----------1A00-------------------------------
INT 1A - CLOCK - GET TIME OF DAY
	AH = 00h
Return: CX:DX = clock count
	AL = 00h if clock was read or written (via AH=0,1) since the previous
		 midnight
	     Otherwise, AL > 0
Note:	IBM and many clone BIOSes set the flag for AL rather than incrementing
	  it, leading to loss of a day if two consecutive midnights pass
	  without a request for the time (e.g. if the system is on but idle)
SeeAlso: AH=02h,INT 21/AH=2Ch
----------1A01-------------------------------
INT 1A - CLOCK - SET TIME OF DAY
	AH = 01h
	CX:DX = clock count
Return: time of day set
SeeAlso: AH=03h,INT 21/AH=2Dh
----------1A02-------------------------------
INT 1A - CLOCK - READ REAL TIME CLOCK (AT,XT286,CONV,PS)
	AH = 02h
Return: CH = hours in BCD
	CL = minutes in BCD
	DH = seconds in BCD
SeeAlso: AH=00h
----------1A03-------------------------------
INT 1A - CLOCK - SET REAL TIME CLOCK (AT,XT286,CONV,PS)
	AH = 03h
	CH = hours in BCD
	CL = minutes in BCD
	DH = seconds in BCD
	DL = 01h if daylight savings, 00h if standard time
Return: CMOS clock set
SeeAlso: AH=01h
----------1A04-------------------------------
INT 1A - CLOCK - READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)
	AH = 04h
Return: DL = day in BCD
	DH = month in BCD
	CL = year in BCD
	CH = century (19h or 20h)
SeeAlso: AH=05h,INT 21/AH=2Ah
----------1A05-------------------------------
INT 1A - CLOCK - SET DATE IN REAL TIME CLOCK (AT,XT286,CONV,PS)
	AH = 05h
	DL = day in BCD
	DH = month in BCD
	CL = year in BCD
	CH = century (19h or 20h)
Return: CMOS clock set
SeeAlso: AH=04h,INT 21/AH=2Bh
----------1A06-------------------------------
INT 1A - CLOCK - SET ALARM (AT,XT286,CONV,PS)
	AH = 06h
	CH = hours in BCD
	CL = minutes in BCD
	DH = seconds in BCD
Return: CF set if alarm already set or clock inoperable
	INT 4Ah will be called when alarm goes off, every 24 hours until reset
SeeAlso: AH=07h,INT 4A
----------1A07-------------------------------
INT 1A - CLOCK - RESET ALARM (AT,XT286,CONV,PS)
	AH = 07h
Return: alarm disabled
SeeAlso: AH=06h
----------1A08-------------------------------
INT 1A - CLOCK - SET RTC ACTIVATED POWER ON MODE (CONVERTIBLE)
	AH = 08h
	CH = hours in BCD
	CL = minutes in BCD
	DH = seconds in BCD
----------1A09-------------------------------
INT 1A - CLOCK - READ RTC ALARM TIME AND STATUS (CONV,PS30)
	AH = 09h
Return: CH = hours in BCD
	CL = minutes in BCD
	DH = seconds in BCD
	DL = alarm status
	    00h alarm not enabled
	    01h alarm enabled but will not power up system
	    02h alarm will power up system
----------1A0A-------------------------------
INT 1A - CLOCK - READ SYSTEM-TIMER DAY COUNTER (XT2,PS)
	AH = 0Ah
Return: CF set on error
	CX = count of days since Jan 1,1980
SeeAlso: AH=0Bh
----------1A0B-------------------------------
INT 1A - CLOCK - SET SYSTEM-TIMER DAY COUNTER (XT2,PS)
	AH = 0Bh
	CX = count of days since Jan 1,1980
Return: CF set on error
	CF clear if successful
SeeAlso: AH=0Ah
----------1A3601-----------------------------
INT 1A - WORD PERFECT 5.0 Third Party Interface - INSTALLATION CHECK
	AX = 3601h
Return: DS:SI = routine to monitor keyboard input, immediately preceded by the
		ASCIZ string "WPCORP\0"
Notes:	WordPerfect 5.0 will call this interrupt at start up to determine if a
	  third party product wants to interface with it.  The third party
	  product must intercept this interrupt and return the address of a
	  keyboard monitor routine.
	Before checking for keyboard input, and after every key entered by the
	  user, Word Perfect will call the routine whose address was provided
	  in DS:SI with the following parameters:
		Entry:	AX = key code or 0
			BX = WordPerfect state flag
		Exit:	AX = 0 or key code
			BX = 0 or segment address of buffer with key codes
	See the "WordPerfect 5.0 Developer's Toolkit" for further information.
----------1A80-------------------------------
INT 1A - PCjr - SET UP SOUND MULTIPLEXOR
	AH = 80h
	AL = 00h source is 8253 channel 2
	     01h source is cassette input
	     02h source is I/O channel "Audio IN"
	     03h source is sound generator chip
----------1AA0-------------------------------
INT 1A - Disk Spool II - INSTALLATION CHECK
	AH = A0h
Return: AH = B0h
	ES = code segment
	BX -> name of current spool file
	SI -> current despool file
	CL = 00h despooler is disabled
	   = 41h despooler is enabled
	CH = 00h spooler is disabled
	   = 41h spooler is enabled
	DL = 00h despooler is currently active printing a file
	   = 41h despooler is standing by
SeeAlso: AH=D0h
----------1AD0-------------------------------
INT 1A - Disk Spool II - FUNCTION CALLS
	AH = D0h
	AL = function code
	    01h enable spooler and despooler
	    02h enable spooler only
	    03h enable despooler at beginning of file
	    04h disable the despooler
	    05h disable the despooler and spooler
	    06h clear the spool file
	    08h inhibit the popup menu
	    09h enable the popup menu
	    0Bh disable the spooler
	    0Ch start despooler after last successfully printed document
	    0Dh start despooler at the exact point where it last left off
	    0Eh pop up the menu
	    20h clear file pointed to be the despooler
SeeAlso: AH=A0h
----------1AFE-------------------------------
INT 1A - AT&T 6300 - READ TIME AND DATE
	AH = FEh
Return: BX = day count (0 = Jan 1, 1984)
	CH = hour
	CL = minute
	DH = second
	DL = hundredths
SeeAlso: AH=FFh,INT 21/AH=2Ah,2Ch
----------1AFF-------------------------------
INT 1A - AT&T 6300 - SET TIME AND DATE
	AH = FFh
	BX = day count (0 = Jan 1, 1984)
	CH = hour
	CL = minute
	DH = second
	DL = hundredths
Return: ???
SeeAlso: AH=FEh,INT 21/AH=2Bh,2Dh
----------1B---------------------------------
INT 1B - CTRL-BREAK KEY
   This interrupt is called when the keyboard scanner of the IBM
   machines detects CTRL and BREAK pressed at the same time. It
   normally points to a short routine in DOS which sets the
   Ctrl-C flag, thus invoking INT 23h the next time DOS checks
   for Ctrl-C.
SeeAlso: INT 23
----------1C---------------------------------
INT 1C - CLOCK TICK
   This interrupt is called (in the IBM) at the end of each time-update
   operation by the time-of-day routines.
Notes:	points to an IRET by default
	preferred interrupt to chain when a program needs to be invoked
	  regularly
SeeAlso: INT 08
----------1D---------------------------------
INT 1D - (NOT a vector!) 6845 VIDEO INIT TABLES

Format of video init tables:
Offset	Size	Description
 00h 16 BYTEs	table for modes 0 and 1		\
 10h 16 BYTEs	table for modes 2 and 3		 \  each table contains values
 20h 16 BYTEs	table for modes 4, 5, and 6	 /  for first sixteen 6485 regs
 30h 16 BYTEs	table for mode 7		/
 40h	WORD	size of video RAM for modes 0 and 1
 42h	WORD	size of video RAM for modes 2 and 3
 44h	WORD	size of video RAM for modes 4 and 5
 46h	WORD	size of video RAM for modes 6 and 7
 48h  8 BYTEs	number of colums in each of modes 0 through 7
 50h  8 BYTEs	video controller mode byte for each mode
----------1E---------------------------------
INT 1E - (NOT a vector!) DISKETTE PARAMS (BASE TABLE)
	default parameters at F000h:EFC7h in PC and most compatibles
SeeAlso: INT 41

Format of diskette parameters:
Offset	Size	Description
 00h	BYTE	4-bit step rate & 4-bit head unload times
 01h	BYTE	7-bit head load time & 1-bit DMA flag
 02h	BYTE	motor off time in clock ticks (36 to 38 typical)
 03h	BYTE	sector size in bytes (0->128, 1->256, 2->512, 3->1024)
 04h	BYTE	last sector number (8 or 9 typical)
 05h	BYTE	inter-sector gap size on read/write (42 typical)
 06h	BYTE	data transfer length (255 typical)
 07h	BYTE	inter-sector gap size on format (80 typical)
 08h	BYTE	sector fill on format (F6h typical)
 09h	BYTE	head-settle time ms (typical 25, 1.10->0, 2.10->15, 3.10->1)
 0Ah	BYTE	motor start-up time (1/8 secs) (typical 4, 2.10->2)
----------1F---------------------------------
INT 1F - (NOT a vector!) GRAPHICS SET 2
	pointer to bitmaps for high 128 chars (eight bytes per character)
---------------------------------------------
